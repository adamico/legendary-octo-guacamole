picotron cartridge // www.picotron.net
version 2

:: gfx/
:: lib/
:: lib/beholder.lua/spec/
:: lib/eggs.p8/
:: lib/lua-star/
:: lib/lua-state-machine/
:: lib/lua-state-machine/spec/
:: map/
:: sfx/
:: src/
:: src/ai/
:: src/ai/enemies/
:: src/ai/minions/
:: src/ai/primitives/
:: src/data/
:: src/entities/
:: src/game/
:: src/game/config/
:: src/lifecycle/
:: src/physics/
:: src/physics/handlers/
:: src/scenes/
:: src/systems/
:: src/ui/
:: src/utils/
:: src/world/
:: lib/beholder.lua/
:: lib/beholder.lua/spec/acceptance.lua
local beholder = require 'beholder'


describe("Acceptance", function()

  before(function()
    beholder.reset()
  end)

  test("Basic behavior", function()

    local counter = 0

    local id = beholder.observe("EVENT", function() counter = counter + 1 end)

    beholder.trigger("EVENT")
    beholder.trigger("EVENT")

    assert_equal(counter, 2)

    beholder.stopObserving(id)

    beholder.trigger("EVENT")

    assert_equal(counter, 2)

  end)

  test("several actions on the same event", function()

    local counter1, counter2 = 0,0

    local id1 = beholder.observe("EVENT", function() counter1 = counter1 + 1 end)
    local id2 = beholder.observe("EVENT", function() counter2 = counter2 + 1 end)

    beholder.trigger("EVENT")
    beholder.trigger("EVENT")

    assert_equal(counter1, 2)
    assert_equal(counter2, 2)

    beholder.stopObserving(id1)

    beholder.trigger("EVENT")
    assert_equal(counter1, 2)
    assert_equal(counter2, 3)

    beholder.stopObserving(id2)

    beholder.trigger("EVENT")
    assert_equal(counter1, 2)
    assert_equal(counter2, 3)

  end)

  test("composed events", function()
    local counter = 0
    local lastKey = ""
    local enterPressed = false
    local escapePressed = false

    beholder.observe("KEYPRESS", function() counter = counter + 1 end)
    beholder.observe("KEYPRESS", function(key) lastKey = key end)
    beholder.observe("KEYPRESS", "enter", function() enterPressed = true end)

    beholder.trigger("KEYPRESS", "space")
    assert_equal(counter, 1)
    assert_equal(lastKey, "space")
    assert_false(enterPressed)
    assert_false(escapePressed)

    beholder.trigger("KEYPRESS", "enter")
    assert_equal(counter, 2)
    assert_equal(lastKey, "enter")
    assert_true(enterPressed)
    assert_false(escapePressed)
  end)

  test("nil events", function()
    local counter = 0

    local id = beholder.observe(function(_, x) counter = counter + x end)

    beholder.trigger("FOO", 1)
    beholder.trigger("BAR", 2)

    assert_equal(3, counter)

    beholder.stopObserving(id)

    beholder.observe(function() counter = 10 end)

    beholder.trigger()

    assert_equal(10, counter)
  end)

  test("triggering all events", function()
    local even = 0
    local uneven = 1

    beholder.observe("EVEN", function(x) even = even + 2*x end)
    beholder.observe("UNEVEN", function(x) uneven = uneven + 2*x end)

    beholder.triggerAll(1)

    assert_equal(even, 2)
    assert_equal(uneven, 3)

    beholder.triggerAll(2)

    assert_equal(even, 6)
    assert_equal(uneven, 7)

  end)

  test("groups", function()

    local group = {}
    local up = 0

    beholder.group(group, function()
      beholder.observe("UP", function()
        up = up + 1
      end)
    end)

    beholder.trigger("UP")

    assert_equal(1, up)

    beholder.stopObserving(group)

    beholder.trigger("UP")

    assert_equal(1, up)

  end)


end)

:: lib/beholder.lua/spec/unit.lua
local beholder = require 'beholder'

describe("Unit", function()

  before(function()
    beholder.reset()
  end)

  describe(".observe", function()
    it("notices simple events so that trigger works", function()
      local counter = 0
      beholder.observe("EVENT", function() counter = counter + 1 end)
      beholder.trigger("EVENT")
      assert_equal(counter, 1)
    end)

    it("remembers if more than one action is associated to the same event", function()
      local counter1, counter2 = 0,0
      beholder.observe("EVENT", function() counter1 = counter1 + 1 end)
      beholder.observe("EVENT", function() counter2 = counter2 + 1 end)
      beholder.trigger("EVENT")
      assert_equal(counter1, 1)
      assert_equal(counter2, 1)
    end)

    it("allows observing composed events", function()
      local counter = 0
      beholder.observe("KEYPRESS", "start", function() counter = counter + 1 end)
      beholder.trigger("KEYPRESS", "start")
      assert_equal(counter, 1)
    end)

    it("observes all events with the nil event", function()
      local counter = 0
      beholder.observe(function(_,x) counter = counter + x end)
      beholder.trigger("FOO", 1)
      beholder.trigger("BAR", 2)
      assert_equal(3, counter)
    end)

    it("throws an error if called without at least one parameter", function()
      assert_error(function() beholder.observe() end)
    end)

    it("does not store hard references to variables", function()
      local counter = 0
      local x = {}
      beholder.observe(x, function() counter = counter + 1 end)
      beholder.triggerAll()
      x = nil
      collectgarbage("collect")
      beholder.triggerAll()
      assert_equal(1, counter)
    end)
  end)

  describe(".stopObserving", function()
    it("stops noticing events so trigger doesn't work any more", function()
      local counter = 0
      local id = beholder.observe("EVENT", function() counter = counter + 1 end)
      beholder.trigger("EVENT")
      beholder.stopObserving(id)
      beholder.trigger("EVENT")
      assert_equal(counter, 1)
    end)

    it("stops observing one id without disturbing the others", function()
      local counter1, counter2 = 0,0
      local id1 = beholder.observe("EVENT", function() counter1 = counter1 + 1 end)
      beholder.observe("EVENT", function() counter2 = counter2 + 1 end)
      beholder.trigger("EVENT")

      assert_equal(counter1, 1)
      assert_equal(counter2, 1)
      beholder.stopObserving(id1)
      beholder.trigger("EVENT")

      assert_equal(counter1, 1)
      assert_equal(counter2, 2)

    end)

    it("passes parameters to the actions", function()
      local counter = 0

      beholder.observe("EVENT", function(x) counter = counter + x end)
      beholder.trigger("EVENT", 1)

      assert_equal(counter, 1)
      beholder.trigger("EVENT", 5)

      assert_equal(counter, 6)
    end)

    it("does not raise an error when stopping observing an inexisting event or group", function()
      assert_not_error(function() beholder.stopObserving({}) end)
    end)

    it("returns false when no action was found for an id", function()
      assert_equal(false, beholder.stopObserving({}))
    end)

    it("returns false when there was a group, but it had no action", function()
      local group = {}
      beholder.group(group, function() end)
      assert_equal(false, beholder.stopObserving(group))
    end)

    it("returns true when an action was found and removed", function()
      local id = beholder.observe("X", function() end)
      assert_true(beholder.stopObserving(id))
    end)

    it("returns true when at least one action from a group was removed", function()
      local group = {}
      beholder.group(group, function()
        beholder.observe("X", function() end)
      end)
      assert_true(beholder.stopObserving(group))
    end)

  end)

  describe(".trigger", function()
    it("does not error on random stuff", function()
      assert_not_error(function() beholder.trigger("FOO") end)
    end)

    it("returns false on events with no actions", function()
      assert_equal(false, beholder.trigger("FOO"))
    end)

    it("returns false if there was a node with no actions", function()
      beholder.observe("ONE","TWO", function() end)
      assert_equal(false, beholder.trigger("ONE"))
    end)

    it("returns the number of actions executed", function()
      beholder.observe("X", function() end)
      beholder.observe("X", function() end)
      assert_equal(2, beholder.trigger("X"))
    end)

    it("triggers callbacks within the nil event only", function()
      local counter = 0
      beholder.observe("X", function() counter = counter + 10 end)
      beholder.observe(function() counter = counter + 5 end)

      beholder.trigger()

      assert_equal(5, counter)
    end)
  end)

  describe(".triggerAll", function()
    it("calls all registered callbacks", function()
      local counter = 0
      beholder.observe("X", function() counter = counter + 1 end)
      beholder.triggerAll()
      assert_equal(1, counter)
    end)
    it("passes parameters to callbacks", function()
      local counter = 0
      beholder.observe(function(x) counter = counter + x end)
      beholder.triggerAll(2)
      assert_equal(2, counter)
    end)
    it("returns false if no actions where found", function()
      assert_false(beholder.triggerAll())
    end)
    it("returns the number of actions executed", function()
      beholder.observe("X", function() end)
      beholder.observe("Y", function() end)
      assert_equal(2, beholder.triggerAll())
    end)
  end)

  describe(".group", function()
    it("throws an error when nested", function()
      assert_error(function()
        beholder.group({}, function()
          beholder.group({}, function()
          end)
        end)
      end)
    end)

    it("creates a group of events that can be cancelled", function()
      local counter = 0
      local increment = function() counter = counter + 1 end
      local group  = {}
      beholder.group(group, function()
        beholder.observe("X", increment)
        beholder.observe("Y", increment)
      end)
      beholder.trigger("X")
      beholder.trigger("Y")
      assert_equal(2, counter)

      beholder.stopObserving(group)

      beholder.trigger("X")
      beholder.trigger("Y")
      assert_equal(2, counter)
    end)
  end)



end)

:: lib/debugui.lua
--[[pod_format="raw",created="2025-03-29 18:05:23",modified="2025-09-30 09:46:24",revision=98566]]
-- Debug Panel

--[[pod_type="gfx",content={"Well, aren't you a smart looking tadpole.","Think I'll call you 'Smarty'.","","Okay Smarty, here's how this Debug Panel works.","","1. Add include(\"src/debug.lua\") to your main.lua file","2. Add debug.run() to the end of your _draw() function.","3. Run your cart","4. Press F1 to open the debug panel","","Come find me further down and I'll tell you more."},flavor=3,flipped="false",font=1,head=1001,mono="true",style=2,swapped="false",tab=0,tail=1,text_d=false,text_f=true,text_l=false]]
unpod(
"b64:bHo0AH8KAAAXFAAA9BNweHUAQygdAQAAlgAAAATw-xD-Ef8KIB7w-wgeEA7w-woOBgDzEDAOIA5QHhAe8BIOIA7wLA5wHrAOQA7wAg6gDqAe8EciABBgHQADIgCAgA6wDvAIDqAHAAQgAPEWEB4gDiAOwB4QDgAeEB4QLmA_UA4QDhAeEA4QDmAecC4AHgAOIB4AcQA_YA4gHiAaAPAAAB4QLiAuUD4QHiAuAC4gRAAxHvBCUwARAAIAACUAkSAO4A4AHiAOEBAAM2AOcAoAAAQAM4AOUCwAlTAOAB4wDoAOEB4ANQAOIA4AM2AOUBYAAgQAAgIAJvBBawAQPmkAbsAuAA4wPmcAUWAuYB4QKABYEC4ADkBnACceMGUANDAuABgAARYAIhA_YwAQHv8AUUAOIA6wGwAxMA4wLwAVgC8AEVDMAACyAAISAAljAAXKACAQLocBAxYAMi4QDgIAJPBEhAEwLhAeiAEQcKQAAVsAMHAegJoBYS5gLlAuECIAdAAOUB5gHhCAAQEmAGEwDnAeEC7aAAAYAFAuEA7wPlgA6ggO8Bwe8Ece8AYO8FIONgICBgAgME6rAADJAAACAkAQHvABBQAQDcYBYQMOkA7wf9sAUSAOwA6QogAQIFgCQiAO8A25ABcCJAAhLhB6AAJ6AQDEAAJSAhVgRgI3oA4wRAIAuAAj8INfABMQAgAAKgERcD8AEWA5AAI-ABMABAA3sB4QKgIfIEEAAiMegD8ALEAuPwAR0D0ABAICDz8AAweAAAIXAgKNAQJBADmgDhDiAScwLkEAAooBAAQAEFBsAjIeYC7OAQLAAQC7AAS_AWAwDmAO8Ht-AHtAHvAhHvCElAEPBgA1EEAoBBAEyQFQ8AIO8AXtA-EGBQ4gDkAOsC5gDvADLvABHvAHDvAnQQIAuwAi8APUAQkvACHwAuMAAhwAKgEOMgAE2wEdUNsBM6AuIEsEMXAuUAwAUCAOUD4AFQITLlkEAS0CFRAOAAA9BAEeAwJGAAEcACXwH2sAAHEBABUAHWAFAgKXARMQYwQ0UA6AEAATDlEAAQIABhYABgQANVAuQAwAALgCFSBIAAAIACTwIn0AEh4XBBGAeQAIQQIBewAQPnMEJmAeawIAAgAEeQAzIB5gJAAEHgAAowAC3QMAswQTYDAAABoAZzAeMB7wIPIABiEBCncCAvIAAIUEEbB5BBMAMAAGdwATQBgAEzAeAABGAAQMAALyAwd3AAESACPwHzMCAC0AOTAOYLECAEkBEhD4ADEuUC4MAAElATKAHgD7AjEuYC4BBiUuMN4AAP8CImAOFgIB0QBiLiAO8BwOlAKbEh4gDvBdHvBctAIPBgA1YFAOsB5ADmoDM7AekAoGIPAJyAIxAh6wTgEQgOABQKAe8APzADEe8Az_ABGgfQEQMPoCEZBMAQEVAxJAAAMRsCwBQHAO8C8VAyFwDjQAMlAOoOwAIS5QCwcBQAEB-AARIB4GASEHBx0FAs8BAHMAQIAOYD4iAQREAwAsABJQRgMiHhBkAVMOEB5wDlUHEgdtAAVJAgIhAAC6AQIIAAIWAHMQDnAOMB4gnwIbAAQAAnsAEzDjBAIQAAQcADEAHnASAhEwJAAGLAARUFgHAAwAJfAG8AAPhQAIQT4QDoDyAQODAAv6AgIEAQ_BAAIDYAMDKAEFLAAhYA7nAx8_fwATQw5ADqAcAwF1AgMGAAZ5AQAMAAQAATNgLgASAAB9ABEgCgAIfQACZAABfwAAPgIREFUGAXUAAPABBeYCIRAuAgAA8wYB-AIzQC4QDAMhEA6PByAucBQBIR6QCwYCawAiEC4xBgQiABNgJAIB5gDr8DkO8CAe8AoO8Age8FjbAgIGACJAHuECAEAJIfAT0AIQ0K4FYAsOwB7wF68CYiAOkB7wAc0CERAHARGQCAADNABUEg5ADnA0AECwDvAZ1QIAEwAAMAYRCvkAE5DqABdgvgITQJwFAM4DEkDCAhA__QkRcP4CEGC9CAnSAhKwBAMCTgQjDkB5AQAeATEAPgCtCBug2QITUAgACAQAFUA_CgZEAALrBAwyAAEMABo_2QIRwAYAEVD3AxEQtgAXAC8CABoBAg4AEZAeABWwHAAETgAIwgICMAAPigACOD5QPjgAExB3BAQEABHQBgAAIAIB5gIFPgAPiAADNTAOwBwAA4gAB8sCD4YACEkOgA4whgAGpAoEhAACSAAPhgASFj7wAhdg1gIC6AIBCAAB2gICCAYAJAADCABEHiAOoO4CEj44BhEQgAEAcAATMCYAQiAeAC4qAgJmACDwK_cEcCAO8D8e8CIIABUo7wIIBgCRQB6gLvAqDvC5JwECqQAi8CkQAAK1AgC-ABMApwYTEIkCI2AuWQgzPvC3RQAZEF4BBgcFEWBbCAxQAAwpACEOgAUBGkCJAAQfAApbBAAeAAUrACZAHk8HAZgIAScBIpAubQcBngBb8Bce8OD3AAIGAHBQDqAu8As_ZwMg8BckATEBDlAvABVawQZZ8AoOQB4fACEYDh8AAOkHE6APAQB1AAATBRFQxAMBvgMB9Q0BzAMH8AMBvAkBnAkGQwAB3QYCSQIzgC4wQQIKHAEGjwIOGgAEFAAVMA4AExBdABA_ZQwQME0OEB7wDQtZACg_AGwDBRIACFMAAlMBIwA_UQAALgYRMAYIAJcICVEAEi6zAQSmABeAGQMC9wATEAwAAbcBE1rnCwBJADBALgAOA1EOQC5wHjoBAQcCAKsNAjsABigDCAoJIPBZ5gCbQw7wLB5gDvBv1gEPBgA1UEAe8AkeiQJA8AgesP8BEAYdBhNQ3Q0QcCcOBBIQEBDLCxDgBQAV0CkAE2DkDRFwowYDKQAxQB4QlggAiggB7Q8EDgADSgIRADQCFRBjA1EgDgAucCoAAgkOAGACCgkOA_YIAYYCI-AZlQYBTQABAgAREHQIAAIAAQwABxYAAAYABPYLBK0DBGMFJCAOowsCEgADhg4BLAATEH8AHQBUAAI0DCzwGIUAED4LAQuDACM_YHkABtoIBlUMAgIACPgDBYEAHz5-AAgzDjA_fQAXEMgAGZB9AAISAAl7AC8OMHsAABVQEgAI-gAZQMMOAk4AAkIAQvAbDhAxEABVAAGCCAQpCQIQABEwkQQTAFgDEZD3AwEOACQOYCoAIi5gBAMH6w4BPgASHiwJIPAVXgFEuh7wPaMCAcASgCD_5mD_DPDqWwMg-weLACX-CAYAgDAPIPAEDfDuBAHxCw0HPbA9Bw3w7k4QDRYHBgcNkA0HBgcWDfD2CAARnRQA8BDw9w0mBwYPGx8aDxYvGg8WDxoPGwYHJg3w_A0HFi8VEwDwBR8aLxUWBw3w_Q0WDCcMPxoMJwwWDgCQBgxHDBsMRwwGDQBwAwxHPEcMAwsAEwsYABALDQDwMRsMJww7DCcMGw3w_B0rLFssKx3w9g0KDxsLGitZKxoLCQoN8PQNCxkLGhsJVwkbGgsZCw3w8w0pSxYnBgcGSykNALA5OwYXBgcGBwY7OS0AQBkDCSu8AFAmKwkDGc4AUBkDOVY5CwCw9w0LCRMpVikTCQsYAPACCxkDOwk2CTsDGQsN8Pb9BkA=")

-- Configuration
local config = {
	_X_position    = 1,
	_Y_position    = 11,
	_TOGGLE_key    = "f1",
	_FILL_color    = 1,
	_OUTLINE_color = 7,
	_SHADOW_color  = 1,
	_TEXT_color    = 7,
	_ACCENT1_color = 24,
	_ACCENT2_color = 16,
	_ACCENT3_color = 27,
}

--[[pod_type="gfx",content={"Didn't expect me so soon, eh Smarty? I'm faster than I look.","","Those locals up there are for changing some of the basic stuff","like colors and where the window starts on the screen_"},flavor=3,flipped="false",font=1,head=1001,mono="true",style=2,swapped="false",tab=0,tail=1,text_d=false,text_f=true,text_l=false]]
unpod(
	"b64:bHo0AHAGAADBCgAA9BNweHUAQyhBAQAASQAAAATw-zT-Ef8uIB7w-yweEA7w-y4OBgDwEjAuIA5ADnAOIA7wEg7wOg6QHvADDoAeYC4gDuAesA7wAxoAMAMuUAwAEAcwAEcOEA5wMAAQgEoA0wIOcA4QDmAOMA7QDtA0AEcEDnAONACwAB4gLgAuYD5gHhAOACAuIBAAoT5QHgAOIB5wLhAEALEgHhAuwB4QLmAOMBgAADYAMQA_AEIAkWAOYB4ADnAOMDgAERAcACBQPkgAIRAukAAhHiBaACPwBHEAAgIAEQCYABNwCgAGBAAA8wARAAIAVRAOUA4wBgATAAQAE6AIAACvAAAmAPEAMA4AHjAOIA4QDiAOcA5gFAAxUD4wSgAAFgAxAB6ACAAXMHIAAkIAACoAL-AFlQABAcYARxAOAD6PAAMgASRgHigAAAQAEaAEARKAIgA0DhAudQAAFAACiwAwYA4wQAFiDiA_AA6QHAAdLokAPx7wBocAAQESACAALhoAAgkCRAAOsA5xABcQEgECJgEADgATIBYAkUAOMC6wDmAOIAQAAlwAMyAOMIMAAiQAC4UABQ4BMi4QLqQAQnAeYC4bAHBALhAuIB5QPQBALlAuIIUCA9YBRCAOcC6PAREg3AAgUB5tADFwLlB9AGAwLgAuMB4YADWgHgD_AFNQLmAeEEIAQBAO8AEFALogDvA8DvAiHvB7DgkDDwYANcAwTgAO8Age8AEe8AwIA0AeHvAFlgIw8CIeJQEw0A7gMAMgkB7pAABQAUAgDvAJEgACLgAQHTIDQfA2DoArAILwEg6ADjAOcCkAATQDQhAecA4IAEEgDiAujwEiLmAIA2QOAB4QHnAIACEOMAoAIWAuHABBLiAuAAYAUmAuEB4QdgNkHiAOcD4AaAEQLqIDImAucAMWEHYAAZoBERADAwDLAREQDAATYH4CBOEBBSYAIh4gOQIBCAAiUD4UAAJjAgIbAwAmAAICABcAdQMCAgADXwIWPlAAE1A4ABFAVgADawNJPgA_UJwARBAeED6aAHpALhAOIB5gmgBQPgAOMD5mAhUwXAAAWAEEKAIABAACAgAXAHwDAQIAAWoAAHwAAkgAAQ4AAXwBEBDDAQEWAA4sAQCyADWQDhA2ATIQDkDaACMucCQAMzAOMD4BBi0DApIAEwAEAEEQLhAOAgAULocDESAkAAeOAANCABMQZAARsCgDGxCQABIQ9gEACAMAcgNJHgAucCYDMkAuYAYAATACJJAuGAAARgATAAgAAIwDAngDU2AeIA6QPAAQUFQCAcYDEVB8AwR4AKXwOQ7wVB6wHvBvFAMIBgARMD0BACIDEBMgBhAJ9gIwBQ6Q_AJA0A7wDQ8AE00yAQAZAwYlAB4QIwACQQUDPQYDMQYApQAA8wAA-wAjAC4UABIeIwMA-QECBwMRENEAFWBLBiIAPjgAAigAEXCbBBIAPQRULvAjDhB8AiUOELYCAgIAAOoCAi8FEwB0AQQMAAIEAwYcAwAcAAM0AAUEADEgDlDqAAJdBgTQAQg0ABMwMQETAAQAJPAijQA5HiA_iQAyDkAeJQUCOQACwQIF-QIFwQICFgACMgAEBAAAAgAA2wEhMC7UBQ0-AwATA0AwDjA_TAAIgwABJQADSgMBAgAAGgQTUBgAC4cAKQ4w7AICFgACNAAEBAATANQCAiQAABgBG1ASAROwSAAAAgAEiQAjHgC1AiFgLrABAKwAJC5wFAAEZwAB6wIncB4WACUuAM0DMwAOYD8GEFAhAwFWAhhw5wIBmwYCSgAq8B-RAgFUCfUHIP7-C2D_DPD-Dw5ADvD-Kw4wDvD-LAYAkDAPIPAEDfD-E7cAYA0HPbA9Bw4A8QNOEA0WBwYHDZANBwYHFg3w-xsJABGdFQDwEvD-HA0mBwYPGx8aDxYvGg8WDxoPGwYHJg3w-x0NBxYvFRQAUB8aLxUWLADBHg0WDCcMPxoMJwwWDwCRBgxHDBsMRwwGDgBxAwxHPEcMAwwAEwsaABELDgCQGwwnDDsMJwwbWABwHSssWywrHYkA8A4KDxsLGitZKxoLCQoN8P8ZDQsZCxobCVcJGxoLGTsAsRgNKUsWJwYHBkspDgCxOTsGFwYHBgcGOzkwAEAZAwkryQBRJisJAxncAFEZAzlWOQwAsRwNCwkTKVYpEwkLGgDwAwsZAzsJNgk7AxkLDfD-G-0GQA==")

----Use transparency if Wash's Color Table library is available
-- if ColorTable and ColorTable.apply then
-- 	_FILL_color		= 37
-- 	_OUTLINE_color =  7
-- 	_SHADOW_color	= 38
-- 	_ACCENT1_color	= 45
-- 	_ACCENT2_color	= 46
-- 	_ACCENT3_color	= 47
-- end


-- Create GUI root
debugui = create_gui({
	----------------
	x = config._X_position,
	y = config._Y_position,
	width = 0,
	height = 100,
	pad_x = 3,
	----------------
	show = false,
	----------------
	elements = {},
	----------------
	update = function(self)
		-- Toggle visibility
		if keyp(config._TOGGLE_key) then self.show = not self.show end
		-- Check if on
		if self.show then
			-- Update window width
			local _longest = 0
			for i = 1, #self.elements do
				_longest = max(self.elements[i].width + 6, _longest)
			end
			self.width = _longest
			-- Update handle width
			self.handle.width = debugui.width - 4
			-- Update height
			local _all_height = 15
			for i = 1, #self.elements do
				_all_height += self.elements[i].height + 1
			end
			self.height = _all_height
			-- Group y position
			for i = 1, #self.elements do
				if i == 1 then
					self.elements[i].y = 12
				else
					self.elements[i].y = self.elements[i - 1].y + self.elements[i - 1].height + 1
				end
			end
		else
			-- Reduce size and make unclickable
			self.width = 0
			self.height = 0
		end
	end,
	----------------
	draw = function(self)
		-- Border
		rrectfill(2, 2, self.width - 4, self.height - 4, 1, config._FILL_color) -- Fill
		rrect(1, 1, self.width - 2, self.height - 2, 2, config._OUTLINE_color) -- Outline
		rrect(0, 0, self.width, self.height, 4, config._SHADOW_color)       -- Shadow
	end,
	----------------
})

debugui.config = config

function debugui.run()
	-- Stash font
	debugui.stash_font()
	fetch("/system/fonts/p8.font"):poke(0x4000)
	-- Run stuff
	debugui:update_all()
	debugui:draw_all()
	-- Restore font
	debugui.restore_font()
end

function debugui.create_handle(_x, _y, _w, _h)
	local el = {
		----------------
		x = _x,
		y = _y,
		width = _w,
		height = _h,
		----------------
		clicked = false,
		dragging = false,
		----------------
		cursor = "grab",
		moffset = 0,
		----------------
		draw = function(self)
			-- Bars
			local _factor = self.height / 3
			for i = 0, _factor do
				line(2, 1 + i * _factor, self.width - 3, 1 + i * _factor, debugui.config._OUTLINE_color)
				line(2, 2 + i * _factor, self.width - 3, 2 + i * _factor, debugui.config._SHADOW_color)
			end
			-- Reset status
			self.dragging = false
		end,
		----------------
		click = function(self)
			-- Get offset
			if not self.clicked then
				local mx, my = mouse()
				self.moffset_x = self.parent.x - mx
				self.moffset_y = self.parent.y - my
			end
			self.clicked = true
		end,
		----------------
		release = function(self) self.clicked = false end,
		----------------
		drag = function(self)
			-- Now dragging
			self.dragging = true
			-- Drag parent around
			local mx, my = mouse()
			self.parent.x = mx + self.moffset_x
			self.parent.y = my + self.moffset_y
			-- Protect against edges
			if self.parent.x < 0 then self.parent.x = 0 end
			if self.parent.x > SCREEN_WIDTH - self.parent.width then
				self.parent.x = SCREEN_WIDTH -
					self.parent.width
			end
			if self.parent.y < 0 then self.parent.y = 0 end
			if self.parent.y > SCREEN_HEIGHT - self.parent.height then
				self.parent.y = SCREEN_HEIGHT -
					self.parent.height
			end
		end,
		----------------
	}
	return el
end

----------------
function debugui.create_group(c, bg, folded, func)
	local el = debugui:attach({
		----------------
		x          = 3,
		y          = 0,
		width      = 0,
		height     = 0,
		max_height = 0,
		----------------
		text_col   = c or 7,
		bg_col     = bg or 37,
		folded     = folded,
		func       = func or function(self) end,
		vars       = {},
		----------------
		init       = function(self)
			-- Prep variables
			self:func()
			-- Height
			local _height   = (#self.vars) * 7
			self.height     = _height
			self.max_height = _height
			-- Toggle
			self:tap()
		end,
		----------------
		update     = function(self)
			-- Update variables
			self:func()
			-- Update width
			local _longest = 0
			for i = 1, #self.vars do
				_longest = max(#self.vars[i] * 4, _longest)
			end
			self.width = 1 + _longest
		end,
		----------------
		draw       = function(self)
			-- Fill
			rrectfill(0, 0, self.width, self.height, 1, self.bg_col)
			-- Print Vars
			for i = 0, #self.vars do
				local _txt = self.vars[i + 1] or ""
				local _pad = string.rep(" ", max(0, 15 - #_txt))
				print(_txt.._pad, 1, 1 + (7 * i), self.text_col)
			end
		end,
		----------------
		tap        = function(self)
			-- Toggle fold
			self.folded = not self.folded
			-- Change height
			if self.folded then
				self.height = 7
			else
				self.height = self.max_height
			end
		end,
		----------------
	})

	el:init()

	return el
end

function debugui.create_toggle(c, bg, label, _upd, _drw, _tap)
	local el = debugui:attach({
		----------------
		x        = 3,
		y        = 0,
		width    = 1 + #label * 4,
		height   = 7,
		----------------
		label    = label or "[== empty ==]",
		text_col = c or 7,
		bg_col   = bg or 37,
		----------------
		on       = false,
		upd      = _upd or function() end,
		drw      = _drw or function() end,
		tp       = _tap or function() end,
		----------------
		init     = function(self) end,
		----------------
		update   = function(self)
			-- Extra stuff
			self:upd()
		end,
		----------------
		draw     = function(self)
			-- Fill
			rrectfill(0, 0, self.width, self.height, 1, self.bg_col)
			-- Print Vars
			print("\015"..self.label, 1, 1, self.text_col)
			-- Extra stuff
			self:drw()
		end,
		----------------
		tap      = function(self)
			-- Toggle color
			self.bg_col, self.text_col = self.text_col, self.bg_col
			-- Toggle on
			self.on = not self.on
			-- Extra stuff
			self:tp()
		end,
		----------------
	})

	el:init()

	return el
end

local _FONT = nil
function debugui.stash_font()
	_FONT = userdata("u8", 2048)
	memcpy(_FONT, 0x4000, 2048)
end

function debugui.restore_font()
	memcpy(0x4000, _FONT, 2048)
end

debugui.handle = debugui:attach(debugui.create_handle(2, 3, debugui.width - 4, 7, true, true))


--[[pod_type="gfx",content={"Okay Smarty, here's where the good stuff happens!","","The little colored thingies in the debug panel are called","'Elements' and there are two types. 1. Groups and 2. Toggles.","","Down below is a big list of 'em, and they need to stay there, so","don't go shufflin'em around like a goober-gobber."},flavor=3,flipped="false",font=1,head=1001,mono="true",style=2,swapped="false",tab=0,tail=1,text_d=false,text_f=true,text_l=false]]
unpod(
	"b64:bHo0ACcJAACfEAAA9BNweHUAQyhLAQAAagAAAATw-z7-Ef84IB7w-zYeEA7w-zgOBgAQQBAAoQQe8AMO8AIO8AUGAPESCQ4gDvAQDrAOkB4gHlAO8BMO8D8OEA4wDhAOAA7wAw4QJgAOLwBbgA4wDnAvAPAHEA4QHhAOEA5QDjAeAA4gHhAOAB4APhgAIqAuDgCVEB5wLlAOIA4AEAAgYD4MAKJwLhAeIB4gLmAuMAAAUgAQcCQAIS4QBgA4IC4QaQAxAA5AbwAiYB4OAHAwDgAeMA4gaQADiQAxAB4giQAQgG0ACRQAM2AOIBAAE1AIABUAEAASQBwAQT4APlBsAAQaAAYEABdAhwAwHjAuFQARgIMAQAAOEC4fAAWFAIQ_AA4wPmAeYB4ABBIAA2MADH0AVGAeIA4g_gAACAAVLh4AAhIBKh4gAgERECUAAkcAFSCeACIwLgIBcTAOMA6wDlAqABUAEgASkH0AJg6QXQABwQAZEHsAARgAMi4QLmwAQzAO8EI8AgBxABEwdQERIKAAEVB1ARNgrgBRQC5QLnA9AAQQACFwHg4AMi6ADt4BMFAuMNIBB_IAMjAOQIsAEy7eAACfAhAS6wBATx7wLnwAKlQOxAIPBgA1UTBOAA7QdAGRMA4gHvAGHvAEGwIwQA7A6QIQwOgC8QEBDlAO8Bce8BUeEB6QDvAgJAJRIA7gDmBOATPwBw41ACXwJC8AdhgO8BYOIA4vAADeAgAYA1M_AD4QDuoCFA7_AnEgLlA_AC4Q4gISACQBNh4QLhQDIhAuTgESUAYDRR4gDnBIAwFIABAONAAFmgACvAEA4gIRIKIAERAYAAIIAAACACgAHiQAExACABMACAAACgA1kA4QHgAAGAAMpwIEFAAGHAMzEA6QWAA1UA5gSgIAGgAIlwAXPpUAGT6TAD8OMD6RAARIPhAecI8AAjQDAS4ABAQAE1BIAgAYADAQDnBSAlE_UA5ALocAHD6FACcOkBoBGoCFACsOMIUAAnsBEmDfAgMaADMADoAuAAAGAAKZARMQDAAAfgMTYB4ABFwAESAqAQmFAEAQLmAe3gEgIB7eATJgLhAKAAC0AAMwAzIALgBhAWEuEC4ALmAOAARKAxFgFABTIC4wDlA6A1EQLhAeYG4DABwAERBWABIQEgKr8GQe8DweYA7wa-wCAgYAEFAiAVUe8AgOkMcCEB0KAPIC8BIOsC7wHA5gHqBO8AAe8BUsAAD7BA4sAGERHqAO8B8gABCwLwYBLgAQgAgFIh4QBAZhLhA_EC6w4gImUD74BRZwAAYAGAEBCAABCARgHiAusA6gAAESHk4GAPAAEWBAAHGADrAOMB4gmwQB_AIQCm0AES5XAQPqBBMAjgESEJEDBA8ABL8BBAMDE4AIAAKWAgsiAAEEADDgDqC_BikeIBYAFbAMADlwDsAyAAICAEMADvANAQEiED6QAAO-BUEOMB7AsQEHbQACEQYULhcGAjAABR4AASIAWRAewA6gdAICDQYmcC5MABbQMAAFOQMk8AuHAADgBAM-AADIARegKwAEaQAA-QIE2QIZkIkAQDAuAC4IABywhQBELkAOUAwAAVgAMuAOII4CAzcDApwBED6PAgHhAQGlA0IgHgAuBgEE7QITELsCAi8GAE0AQCAegB5eBBBA6QIyDnAu1wMwQB4gKAEjLnA_ACBQPt8AMDAeQJMAIR4QLAAg8AfcAhCM5QiVKQ7wLB4gHvAZ7gIPBgA7YTAu8AcOgEoJUAYOQA6wmQVxDuAecA7wFFYBQfAVDmAPAxADDQARHIYBEBAsAECQDvAaFgBfsA7QDpAuAAsA-gIAKgkzYC4gMgYwIA5QJAkRHjYEIC5gVgcwLgA_OggR0G4DGcBmAzEQDlBoBAASAAExAiI_EBYAB4YDEMA_BANwABEABAATINABAtwBAgIAEwDmBwBRCBMQAgACPAISQDEIEj4eAgA2AhHQOAAVACIABA4ABFIACh4AAHMJF1AQAAaiAwACBAI2AAacAAICAAIWAADwBRUQFgARYFoHABgAAgIAEmAaBwJoCCMOwIsDIrAuSAAIgQMETgAmAD4YAABSASwwLqkDP7AeEJIACwFuAwaSAAIiAxFQFAAArgERICAAA5IAAZYDFaBIAAVqACMOQNMJCJEGAJwDESD3AgQmAAF-CBUBewARMCMCIwAO9QEBBwYAEABQYC4ALnCkBgG3CWEALgAuMB4vAgGUAwBeAwqMAxEwTgABxQMAjgMhHmCxCSgwDqwDICAOkQIADwIg8E6kCYPwHB7wLx7wEX8DK-84BgASYEwJUQwOoB4gUAVhgA7wHg5Q5QEg8BcwBQPmCQUpABGQ3wAQwCcAOmAOUCUAIUAuNwcxPmAu0wIBbQQAkQECBgQRcAcDBFsGBT0GEg4MAAB1BhJwcQcDAQMRYE4ABA4AKfBH3AEAkgATcAoAArIIAAoAACoCA44BAS0BAu4BBFAGGQA_AAQSAADCAQIsAAsEAAHgCB0AFgAv8EmJAAYAfQsEVQARMEUCA9MDIg4A8AEJOAAFhwBDHiA_YFkCBwQAAdcCCRIAAxYALfBKgQARgCsCAOwMD38AAAEKAAJfAA9-AAIjDgDGAgChACYQDgQAGzCLDAASACTwSugBAC8DEB49DBJg6AEBOwwQMMgCA0sAAIwCBBwGBFsJAwoAA3UMABEFALcHA_gBES7CDRBEewKkEx7wfB7wER7wYasCATIPoCD_-xVg-gzw-xkqACD-NZEAJf82BgCQMA8g8AQN8P8d6QBgDQc9sD0HDgDxA04QDRYHBgcNkA0HBgcWDfD-JQkAEZ0VAPAS8P8mDSYHBg8bHxoPFi8aDxYPGg8bBgcmDfD-Jw0HFi8VFABQHxovFRYsAMEoDRYMJww-GgwnDBYPAJEGDEcMGwxHDAYOAHEDDEc8RwwDDAATCxoAEQsOAJAbDCcMOwwnDBtYAHAdKyxbLCsdiQDwDgoPGwsaK1krGgsJCg3w-yMNCxkLGhsJVwkbGgsZOwCxIg0pSxYnBgcGSykOALE5OwYXBgcGBwY7OTAAQBkDCSvJAFEmKwkDGdwAURkDOVY5DACxJg0LCRMpVikTCQsaAPADCxkDOwk2CTsDGQsN8P8l-QZA")

----------------
-- Elements
----------------
--[[pod_type="gfx",content={"this group elements displays system stuff","like cpu, ram etc."},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=0,tail=2,text_d=false,text_f=true,text_l=false]]
unpod(
	"b64:bHo0AOoBAAAPAwAA8wlweHUAQyCtHgTwn-8amSAe8JceEA7wmQ4FAMAwLgAOAA4ALhAeUB4GAAIOAHBALgAOIC4AAgBgHhAuQB4QGgACFAAxDgAOLAABCAABIgAhLlAcACEADgwAYA4QDkAOEB4AiQ4QDmAOIA4AAgBRQA4gDiBIABEgJAATUCoAAigAAgYAAAIABDoAEDAcACEuQAgAAiIAEnBiAJIuEA4QLkAOIB4YAAG2ACQeEBAAKB4QXgATLrwAES7aACAuADwAASIAEEAKAAIwACceYLoAWzAOQA4AAgASYLoABagABF4AMzAOABgAAAYAAiYABNIAI2AOYAAGuAACKAEiHlAyAWEeIB4ADmCUAANCAQJaAAJ6ASQOIBYAoR5QHhAuAB4gDhASAGRAHiAOIB5WAALJAQUtAASPARWA8QBBEB7wUiMABEYBEWCeAAACABOACAATAGQBJPBUKQBDHhAeUFQANYAeEHcACCMABUwAFSAQAQboAQZOACYuAJoAIA4w8QAlDgACACJALrUBI-BPygAAogLxCSDOYP6F8AEOQA7wlg4wDvCXDiAO8JA-IFQAQJANPg1xAPAa8JANDg8THgwODRAe8JANDxteCw0ADvCRDX4N8JMNHj8fHg3wlA0OOg4HAIAbDhsOGw3wjw==")
local system_group = debugui:attach(debugui.create_group(7, debugui.config._ACCENT1_color, true,
	function(self)
		self.vars = {
			"[== system ==]",
			"fps: "..tostring(stat(7)),
			"cpu: "..tostring(flr(stat(1) * 1000) / 1000 * 100 .. "%"),
			"ram: "..tostring(flr(stat(0) / 1048576 * 1000) / 1000 .. "MB"),
			"t(): "..
			tostring(string.format("%02d", flr(time() / 3600) % 60)..
				":"..string.format("%02d", flr(time() / 60) % 60)..":"..string.format("%02d", flr(time()) % 60)),
		}
	end))
add(debugui.elements, system_group)
----------------


--[[pod_type="gfx",content={"this group elements shows","some global variables."},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=0,tail=2,text_d=false,text_f=true,text_l=false]]
unpod(
	"b64:bHo0ALUBAADAAgAA8wlweHUAQyBtHgTwX-8aWSAe8FceEA7wWQ4FAMAwLgAOAA4ALhAeUB4GAAIOAHBALgAOIC4AAgBBHhAuUBYAExAGAHBQDhAOQA4QDACJDhAOYA4gDgACADBADiACACEuABoAOxAOUCIAEnBAAKMuEA4QLkAOIB4QGABUAC5AHhAQACIeEDwAAIIAFA4gAAh6AFswDkAOAAIAEmB6AAFuABEgJgA0cA4AAgA2LiAOQAAA2AASUFoAhB4gHgAOYC4AagABBgA0EA5QiABELgAeYC0BQEAeEB4pAAARASIwHjMAEmA1AAQCAHEOIC4QHvACogATIFAAApgAFwACAAE1AAMCABIQkgADtgBGIA7wBJcBAAIAJB5QPwAmHhBwADAeIA6bAAExAREucAA7UA4AYAALdAAfLnIAAyJADq8ARB4QHhD9ARIubAAEdQEDLQADEgAiAC6AABPgFwEAUwJwIM5g-kXwAU0AYFYOMA7wV8kAQFA-IDAkAEBQDT4NjADwGvBQDQ4PEx4MDg0QHvBQDQ8bXgsNAA7wUQ1_DfBTDR4-Hx4N8FQNDjoOBwCAGw4bDhsN8E8=")
-- add(debug.elements, debug:attach(debug.create_group(7, debug.config._ACCENT2_color, true,
-- 	function(self)
-- 		self.vars={
-- 			"[== globals ==]",
-- 			"x position: "			.. tostring(debug.x),
-- 			"y position: "			.. tostring(debug.y),
-- 			"_TOGGLE_key: "		.. tostring(debug.config._TOGGLE_key),
-- 			"_FILL_color: "		.. tostring(debug.config._FILL_color),
-- 			"_OUTLINE_color: "	.. tostring(debug.config._OUTLINE_color),
-- 			"_SHADOW_color: "		.. tostring(debug.config._SHADOW_color),
-- 			"_TEXT_color: "		.. tostring(debug.config._TEXT_color),
-- 			"_ACCENT1_color: "	.. tostring(debug.config._ACCENT1_color),
-- 			"_ACCENT2_color: "	.. tostring(debug.config._ACCENT2_color),
-- 			"_ACCENT3_color: "	.. tostring(debug.config._ACCENT2_color),
-- 		}
-- 	end)))
----------------


--[[pod_type="gfx",content={"this toggle elements shows an outline sized to","picotron's divverent video modes."},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=0,tail=2,text_d=false,text_f=true,text_l=false]]
unpod(
	"b64:bHo0AE8CAAARBAAA8wlweHUAQyDBHgTws-8arSAe8KseEA7wrQ4FAOAwLgAOAA4ALhAeQC4QHgIAYAAOIC5ALgYAEAACAFAeEC5QHiQAExAGAGJALgAeYB42AAEmAAIiAAMuALBQLhAeUA4QDkAOEC4AQQ4QDnAKADEADiACABJgCAAAOgABIAARUAgABgIAE2AIABNACAAAQgATMEIAYmAOMA4wDjoAAGQAIwAOagBjLhAOEC5QJgABYABxHlAeEA4gHhIAIh4QagAAoAATDgIAAeIAD2YAAgDCAGwOIA4QHhBmAAEoABMwFAAGAgAF1AADDgARAPQAFAACAE8uIA5A1AAIEYAOAAI_AAxuAABQARBgigAhLgACADRALgDEABIuSAAjUB7iAAB6ASEOAAIAIEAe_AAVECoAFUBAAFdQDhAeYPkBAfEBEQAIACAAHjUBASsAEw4CAAX-ARJADgAjHhAlAgIKACHwKsYAEwDAAAIIABsAGAEKFgAVIAYAAPgBBhwAABIAApABEwAQACHwLKIAB1sAIx4QHQA3QC5AOwAB-QASHh4ACVUAJx4QcQEDKAATLrQAHzCyAAIRYC8ABDoBEyCKAAI6AgQqABwgVQAzDkAOVQATIEYBB34AEB5zAgBrAANWAQEGADIQDmBjAASzAQKfAVMeIA7wJ5wBAKQDcCDOYP6Z8AFgAGCqDjAO8KsWATCkPyC8AFDwpA0_DYsA8BrwpA0ODxMeDA4NEB7wpA0PG14LDQAO8KUNfg3wpw0ePx8eDfCoDQ46DgcAgBsOGw4bDfCj")
-- add(debug.elements, debug:attach(debug.create_toggle(7, 9, "[== vid() ==]",
-- function(self)	--Draw
-- --[[pod_type="gfx",content={"see the example at the bottom","to learn how this all works."},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=15,tail=2,text_d=false,text_f=true,text_l=false]]unpod("b64:bHo0AM0BAAAmAwAA9QtweHUAQyCQHgTwkf8abfACHvBrHvABDvBtDgYAxkAeAC4ALkAuAA4ADggAAQIASQ4gLkAcABEQLAAABgAQUDsAkDAOIA4gDnAOEB8AQQ5gDiAIAAE-AAEIAJUgDmAOAA4QDmAiABEAAgAyEA4gEgADRwDgLgAeEB5gDhAuAB5QHiAIAANFAGQgHlAuEA4aABgQOwAxDgAOPQA-UA4AhAADA4IAD4QADgRJAEAwHhAukQAYEAgBBQIAECAIAQhJAAAiABAeXwAREJgAFlBRAXIwLhAeQA4gQwEQHqAAIBAeQwAERwEgEB4KAAOYACEeABYAMBAe0DsAEUBcADlADiDHAAB4ABUAqwAREIYAExDJAAJHAAoCACnwAEwAANgAJh4QgQACRgBBLhAOEOYAB0IAXx4QHhAuiQARFC6HADQwDkCHAAVdAAIQAARHACAeUAcBDEUAJR4QagECIwEALQETQKgAAQIARR4gDqBUAQG3AvASAs5g-lnwEA5ADvB5DjAO8HoOIA7wcz8gMA4QDvBzDT4NqwDwGvBzDQ4PEx4MDg0QHvBzDQ8bXgsNAA7wdA1_DfB2DR4-Hx4N8HcNDjoOBwCAGw4bDhsN8GM=")
-- 	camera()
-- 	clip()
-- 	if self.on then
-- 		local _screen_w = get_display():width()
-- 		local _col = 0x0107
-- 		local _flags = "\^o1ff"
-- 		local _fillp = {
-- 			0b10101010,
-- 			0b01010101,
-- 			0b10101010,
-- 			0b01010101,
-- 			0b10101010,
-- 			0b01010101,
-- 			0b10101010,
-- 			0b01010101}
-- 		--Draw vid() modes
-- 		fillp(unpack(_fillp))
-- 		rect(0, 0, 159,  89, _col)	--vid(0) 160x90
-- 		rect(0, 0, 239, 134, _col) --vid(0) 240x135
-- 		rect(0, 0, 479, 269, _col) --vid(0) 480x270
-- 		fillp()
-- 		print(_flags .. "160x90",  129,  81, 7)
-- 		print(_flags .. "240x135", 204, 126, 7)
-- 		print(_flags .. "480x270", 444, 261, 7)
-- 	end
-- end)))
----------------


--[[pod_type="gfx",content={"Hey smarty, Ya' made it!","Down below are some examples to copy.","","And my nephews are there to eplain","things in more detail too. *hop*"},flavor=3,flipped="false",font=1,head=1001,mono="true",style=2,swapped="false",tab=0,tail=1,text_d=false,text_f=true,text_l=false]]
unpod(
	"b64:bHo0AC4FAADHCAAA8wlweHUAQyDHVATwuf8RsyAe8LEeEA7wsw4FABAwCQD-BRYO8AIOEA5wDvAFDrAOIA4wDvA5HAABKPAAGwDxChAeEA4QDmAuAB4ADiAeEA4AHgA_AA4QDqAcABGwFgCTIC4QHmAeED4QNwABIQAABABgUA4wDgAOUADUAB4wDiAOEA6wLjAOoBQAAyYAGmCNAAJgADFgHhAnAFEQLgAOQDsAVdAOEC6gFAAAKAAMOQCiDkAugA4ADiAOAA4AUg4wLtAOrQAEFAAABABjkA4gDvA_NQCREC4wDlAuEA4gVgARUKcAUWAuIC6gEgAAAgBDUC4gHtoAqOAe8BIeIA7weg5eAQEFAPMAMC7wBw6AHvBKHvACDvAaXgCI8AYOkA7wSw4UAABSAZEgDgAuYC4gHiBUARIg7gCBHhAecC4QHhBUATJwHhAsABAe8AARIGYBI1A_IgAQLhwAE5BQAALVABMgcQECEAACAgAAFgBTgA4AHiCLAQJSARkAKgACoQECFAACAgACIQEGMgACBAAKbgACAgADRgAUPjgAAAIAhmAuAA4wPmAeEgAgAD64ACYgLjYAMBAOEMoAD2YAG0UOQA4QFgACEgA3MA6w-gAXgDoAAGABESBbAhhgZgAxLiAuYgABegERAFAAMVAuIHQBABAAEHBsAgPwAQD_ASFgLiQAEi5gAHRAHhAuAC6ApgEyDmAOBACZ8G8O8CAOQB6gEAIPBQApkEAekA7wFQ7wHqkCkwkO8AcecA7wDBsBGYAbABAIDgAVEN4AJVAe1gAAJgIGygADYAJVYD4ALiAMABAQZgIBXAIAVAIr8Ae8AwJrAQR-AQwEAAATAROwXQICZQEBGAAHEAAEOAATELsBAQ8DA6wAAwQAC2UABX0AIwA_GAAiHnBQAgJhABY_DAARUCwAMRAOIAwDD1sAAgD5AAKEABEwJQATAO0CEzCaABMw6QIACgAEDAAxUA4wOQIfELIAAQBPABMgPwAAFgIRMAgAARwAEi48AiRwHjICAAwAAr4AAjgCFABNALnwDx7wAQ7wVA7wG-UBAQUAAOoEsEAO8AcO8BkOYA6AAAFjDvALDvAmHAB28DcOYA7ADhUAMDA_AI0CAMUCMC5QHukBJAAO4QEBpwISPt0CAO0BMSAeoKsAIiAetQAj8BVWAATvABMA-gMZEJoBAtMBE1AgAAIKACIgDr4DBF0FAgoAAiAAL-AWVwAAAMkAC1cANA4wPj8EKjAuUwATkLABAwQAHS6qAAC2BRNgUQATICkAMzAOgCgEAigAD6QABCIuIKIAAisDApkBMzAOAO0DAE8AAN0DMkAuYD8DMS4ALicDEB4zBBFgQwABlwUkDjBCAYPwCB7wbA7wHMQBAHwHgCD_kGD_DPCUzAEQsKMGFLEFAIAwDyDwBA3wmDwC8QsNBz2wPQcN8JhOEA0WBwYHDZANBwYHFg3woAgAEZ0UAPAQ8KENJgcGDxsfGg8WLxoPFg8aDxsGByYN8KINBxYvFRMA8AUfGi8VFgcN8KMNFgwnDD8aDCcMFg4AkAYMRwwbDEcMBg0AcAMMRzxHDAMLABMLGAAQCw0A8DEbDCcMOwwnDBsN8KIdKyxbLCsd8KANCg8bCxorWSsaCwkKDfCeDQsZCxobCVcJGxoLGQsN8J0NKUsWJwYHBkspDQCwOTsGFwYHBgcGOzktAEAZAwkrvABQJisJAxnOAFAZAzlWOQsAsKENCwkTKVYpEwkLGADwAgsZAzsJNgk7AxkLDfCg-QZA")
--------------------------------
-- Example Group
--------------------------------
--[[pod_type="gfx",content={"here's the arguments for create_group(text_color, fill_color, start_unfolded)"},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=0,tail=2,text_d=false,text_f=true,text_l=false]]
unpod(
	"b64:bHo0ACsCAAAGBAAA9BNweHUAQyhBAQAAGAAAAATw-zT-Gv8uIB7w-yweEA7w-y4OBgBgMA4ADgAuAgBxEA4gHkAuABAAEEAQACQeABwAYB4QLhAeQBIAVC5QHgAuAgAmUB4mAFMQDhAuAD4AIFAeFgBRMB4ALoAUADUgDnASABWQQAAQQCwAAVoAtAAOIB4QLgAeIA5gkgAjDiAGAFEgDnAOEAwAEWAGAAUcABIuCABSEA4QDmASAEMOAA5ACgAOGgAGAgAzMA4QIAAXUC4AAAIAE4AcAB9gGAACAgwAADYAAgoABCAABgYAMCAOUMAAADABYB4QHlAuUBQBIB5QEAADJgAB8gABRgAxEC5ACgAwAB5Q-gAACAEiDhAMAAAWAAPiAEAwDhAeBAEJqgBOHpAeIKgAIh6QhAEQHi4ACGwABCAAERAKABtQYgERgBIACmABCAIAESCuABUwWgEPZAEBHQA0AAJIAQ9kAQEAEgAPZgEDERDqAR8QaAEXAyQBAAYAMkAeYDoAAlYCApICJR4AIgAIXAEaUBgAAo4CABIAIB4gpAJFDiAOEBwAIBAeogIESAEyYA4gLgAMGAABkAEnAA42AAEMAAHWAgNcAxRgcgMBhAPxDiDOYP7-GvABDkAO8P8rDjAO8P8sDiAO8P8lPyAwKgBAJQ0_DewAAAoAcA4PEx4MDg07AHAlDQ8bXgsNGADxBSYNfg3w-ygNHj8fHg3w-ykNDjoOCACQGw4bDhsN8P8k")
-- add(debug.elements, debug:attach(create_group(7, debug.config._ACCENT1_color, true,
-- function(self)
----[[pod_type="gfx",content={"to track a variable in a debug group add a","new line to self.vars and put the variable","inside the 'tostring(here!)' part."},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=15,tail=2,text_d=false,text_f=true,text_l=false]]unpod("b64:bHo0AM0CAADpBQAA9QtweHUAQyDEJATwxf8aofACHvCfHvABDvChDgYA9QkwLhAeQC4ALgAuEB4ADgAOQC5ADgAOAC4CAMEOIC5ALgAeUC5AHhAQAGQADhAeUB4wABEAHgBQEB5QLlBPAHFADhAOAA5QBgACAgAQIFUAAwQABAIAGRAgADlwDhAkAAAyAAICABdgDAACAgACIgAGDAAKdQAAogBEDiAeUMQAQB4gDhCeAGYOIB5gDhDeAEQeEB4QYQADCgADygAEWwAPzgAOHy7MAB0EEgAIAgA5YA4AHgAEdQADrgACbAEGHQAGqgADBgAULrQAA5MAAsYBBMgAMx4gHmMAACgABF8AA-cBIx4QOQAQICEBMi5ALtUBAe8BAzMAARkCAdsBCR8BBSAAAwIAIg4gLQEVMPEAM0AOMKwABA8BESACAAjvAA79AAJNAQT6AAgeAAxjAQRtACgeEG0ABeMBAvEBElCmACQeELgAAhwABGUAANMCDyUCAAbIABwuxgAAkgABxgAWLowABLgAEwDmAANdAAEQAAYoAA-AAAUCvwECJwAhLlBXAwJjAzYwDiAzAAKoAAN6ASUwHmEAJi5QJAADRAAAAgAI5QERLgQCCAUBADUAUi4QHhAeLQAAIAADngACPgIB4gAiUC4OACbwGgUDGwAOAQAQARkwGgAE5gAAQgACCAACHAATMDwBBg4BJ-AbWAAmLhC-AUYuAB6gFgAmHiBSABEutANiHiAOMA6AuAAJRgAAKgAKngAZsBgABB4AAAIACJ4AM4AOgAoABpgAEjAqAQKLAQRlATIukA6AABcQbwEbEA4ANyAOkE4ARSAO8BeMAQF6BfACAs5g-o3wEA5ADvCtDjAO8K4kADCnPyBAAVDwpw0_DT0A8Brwpw0ODxMeDA4NEB7wpw0PG14LDQAO8KgNfg3wqg0ePx8eDfCrDQ46DgcAgBsOGw4bDfCX")
-- 	self.vars={
-- 		"[== example ==]",
-- 		"variable: "	.. tostring("variable"),
-- 		"greeting: "	.. tostring("hello!"),
-- 		"rainbow: "		.. tostring("\f8p".."\f9r".."\fao".."\fbm".."\fci".."\fds".."\fee"),
-- }end)))
--[[pod_type="gfx",content={"\009\009\009^\009\009\009\009\009\009\009\009\009\009^","\009 label here\009\009\009\009\009\009\009variable there"},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=15,tail=2,text_d=false,text_f=true,text_l=false]]
unpod(
	"b64:bHo0AC0BAAD8AQAA9gtweHUAQyDYHgTw2f8atfACHvCzHvABDvC1DgYAcRkO8GcO8BMMAGAYDgAO8GUFACwSDigACAYAUAQOIC4AAgBRDmAOAA4KADUu8D0LAAECAGUOIC5ALgAUABRQOQAjDgACADMgDmAIAAAGAEXwPw4AAgAzEA4QCgAAHwA3cA4QKQAWcIIAYh4QHhAOYAgAMh7wPmwAQB4gDhATAGMOIB5gDhAdAB9gfgAOAqsAD3wAEwfXABJACgABEAAm8D47AAMTAAL6ABcQEgAVUEcBAY0B8BICzmD_ofAQDkAO8MEOMA7wwg4gDvC7PyAwDhAO8LsNPg15APAa8LsNDg8THgwODRAe8LsNDxteCw0ADvC8DX4N8L4NHj8fHg3wvw0OOg4HAIAbDhsOGw3wqw==")
--------------------------------


--------------------------------
-- Example Toggle
--------------------------------
--[[pod_type="gfx",content={"these (7, 9, \"label\") arguments are","text_color, fill_color, and label"},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=0,tail=2,text_d=false,text_f=true,text_l=false]]
unpod(
	"b64:bHo0APABAABsAwAA8wlweHUAQyCZHgTwi-8ahSAe8IMeEA7whQ4FAPAEMC4ADgAOAC4QHgAuUA4QLoAugBAAQA4gLgACAJEOIA4ADhAOUC4iAAEqAJAALgAeEC4QHkAKAAA0AEIOQA4QNABwDiAOYA5ADkIAA0YAAQYABBwAAAYAE0AQAAMcAAViAFMQDmAOAAIAEnBUAAFoADAAHlBSACAuwJIAgB4QHhAOgA5ACgAjDiAuAAAMAAFCABEuGAAnHmCSAABuABFgDgAAVAA3kA4gfgAXgIwACAIAApAAPDAOQJAAArAAYx4QLlAOMOIAJaAuFAFALlAOUAwABE4BA94AAZoAFh4aABdQeQEDPQAgUB4vAFEwHgAugBQAOCAOcBIAEB4-AASPASPwAIwAAqYAEVAIABMABgAAlAARMBwAHWAYABUAAgAVQBYAACAABFEAEB6hAQlPAE4ekB4gTQAiHpC2AAJJAAOTAQ_WAAwAEgAPmAADFhA0AQ_aAAYjLgDfASIQHhECAtsBFGAUAQ0YABIAAgAnLkCdARPQdwEA-wLwAiDOYP5x8AEOQA7wgg4wDvCDbQAwfD8gowBQ8HwNPg2GAPAa8HwNDg8THgwODRAe8HwNDxteCw0ADvB9DX4N8H8NHj8fHg3wgA0OOg4HAIAbDhsOGw3wew==")
-- add(debug.elements, debug:attach(debug.create_toggle(7, 2, "[== example ==]",
-- function(self)	--Update
-- --[[pod_type="gfx",content={"put your update stuff here"},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=15,tail=2,text_d=false,text_f=true,text_l=false]]unpod("b64:bHo0ADUBAADKAQAA9QtweHUAQyCEGATwhf8aYfACHvBfHvABDvBhDgYA5jAuAA4ADgAuQA4ADhAeDADTAC4AHhAuAC4ALlAeACQABRoAABYAAT0AIQ4AAgBZEA5QDgACAAEpAAcCAJEQDhAOYA4wDhAOADMgDmAIAAAGABZwiAAyEA5QbAAAAgAiHlBuAAEGAHIQDhAeUC4QQQAQHgwAAAYAMhAeYIgAESA9AD1wDgCEAAJkAAKCAD_ADhCCAAgxDjAegAAhHiAIAWNQHgAOIC47AHUuQB4gDiAeOQADlgAVUEkBAVsB8AkCzmD_TfAQDkAO8G0OMA7wbg4gDvBnPyD4AFDwZw0_DW8A8BrwZw0ODxMeDA4NEB7wZw0PG14LDQAO8GgNfg3wag0ePx8eDfBrDQ46DgcAgBsOGw4bDfBX")

-- 	if self.on then
-- --[[pod_type="gfx",content={"stuff in here only runs when the button is toggled on."},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=30,tail=2,text_d=false,text_f=true,text_l=false]]unpod("b64:bHo0ALoBAADzAgAA9RJweHUAQygDAQAAGAAAAATw-xT-GtHwER7wzx7wEA7w0Q4GAPMCQB4ALgAOAA4ALgAuQC4AHlAMANIALlAeAB4QDiAOAA5AIgBAHiAeQAgAAi4AIx5QOAADHgBQLgAuEB4WAGAQHkAuEB4CALAADiAuAB5gHgAeoGsAUDAOMA4QKwBBDiAOcAoAE0AOAAAGABFgBgAEEAACGgAEAgAKHAA5UA4QFgAApQATEAwAABwAE3AOABMgAgAGTgARkIcAIi4QIQBiHhAeYA4Q4AABsAAB-AACOwBDLkAeEAwAMwAuQPIAEhBhAAD8AC4eEHkAKC5QeQAsHhB5AAAfAA8AAREVQDcAAh4AA2EBASgAH1D8AAoVMCAABj4ADgABEB6eAAAbADRgLgAdAATMASQeEAwCAF0AER4WAAXqARYAgQARLuQBAH0AFB5CARBgDAAjLgACAAJKADUQDmBrAgF9AvAJEc5g-r3wHw5ADvDsDjAO8O0OIA7w5j8gGgJQ8OYNPg2vAPAa8OYNDg8THgwODRAe8OYNDxteCw0ADvDnDX4N8OkNHj8fHg3w6g0OOg4HAIAbDhsOGw3wxw==")

-- 	end
-- end,
-- function(self)	--Draw
-- --[[pod_type="gfx",content={"uncomment these if you want to","draw outside of the debug window."},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=15,tail=2,text_d=false,text_f=true,text_l=false]]unpod("b64:bHo0ANMBAACaAwAA9QtweHUAQyCgHgTwof8affACHvB7HvABDvB9DgYAwTAOAA4AHiAeEB4ALgIAYB4QLkAuABYAEC4UAKBALgAuQA4ADhAeFAAACgAEJABFEB7wAkIAAQIAEiAeABIuCgBTEA5gDhAYADEgDnAQABUAAgABSgADAgAEKgAPUAACBAIAJB4QKgABgACJAB5gDhAeUC5QAB8uTgAWJw4gKgACPgAAogAzgA4AAgADBAENUAAyQB4ADgEBkAAdAHYABkIBIGAuWAELSAA3HvADfAEhHhAuAUYADlAecgEAQAASUHoBARQAFUAmADQQHkBiACEeIDIAGpDjAAcLAQFxADIQDjCVAAN7ARlwDgAGEQETYC4AGQACAAZdAACCAApZABMuLwAhHlAGAAKWAQIMAD8QHhBVABIEAgAlLkBXAACuAAY9AA_wAAcAnwELWwASLlkAAagAA1cAANYCIg4QPgEARgEETwAAWgEWLt4CFABUARAuogEEnQEBKwPwCQLOYP5p8BAOQA7wiQ4wDvCKDiAO8IM-IKgAUPCDDT4NkwDwGvCDDQ4PEx4MDg0QHvCDDQ8bXgsNAA7whA1_DfCGDR4-Hx4N8IcNDjoOBwCAGw4bDhsN8HM=")
-- 	camera()
-- 	clip()

-- --[[pod_type="gfx",content={"put your draw stuff here"},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=15,tail=2,text_d=false,text_f=true,text_l=false]]unpod("b64:bHo0ACUBAAC4AQAA9QtweHUAQyB8GATwff8aWfACHvBXHvABDvBZDgYA4zAuAA4ADgAuQA4ADhAeDABBHhAuABgAM1AeACAAAiIAAAgAMQAuUDkAIQ4AAgBZEA5QDgACAAEpAAkQADEwDhAKADMgDmAIAAAGABZwgAAyEA5QaAAAAgARHlEAIR4QEgAyQC4QPQBQHhAeUC4GADIQHmCAABEgOQA-cA4AfAAFTy5gDhB6AAgxDjAeeAAyHiAeagAABgAEAgFFIA4gHjcAAhoAJS5QNwEBSQHwCQLOYP5F8BAOQA7wZQ4wDvBmDiAO8F8-IO4AUPBfDT4NbQDwGvBfDQ4PEx4MDg0QHvBfDQ8bXgsNAA7wYA1_DfBiDR4-Hx4N8GMNDjoOBwCAGw4bDhsN8E8=")

-- 	if self.on then
-- --[[pod_type="gfx",content={"stuff in here only runs when the button is toggled on."},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=30,tail=2,text_d=false,text_f=true,text_l=false]]unpod("b64:bHo0ALoBAADzAgAA9RJweHUAQygDAQAAGAAAAATw-xT-GtHwER7wzx7wEA7w0Q4GAPMCQB4ALgAOAA4ALgAuQC4AHlAMANIALlAeAB4QDiAOAA5AIgBAHiAeQAgAAi4AIx5QOAADHgBQLgAuEB4WAGAQHkAuEB4CALAADiAuAB5gHgAeoGsAUDAOMA4QKwBBDiAOcAoAE0AOAAAGABFgBgAEEAACGgAEAgAKHAA5UA4QFgAApQATEAwAABwAE3AOABMgAgAGTgARkIcAIi4QIQBiHhAeYA4Q4AABsAAB-AACOwBDLkAeEAwAMwAuQPIAEhBhAAD8AC4eEHkAKC5QeQAsHhB5AAAfAA8AAREVQDcAAh4AA2EBASgAH1D8AAoVMCAABj4ADgABEB6eAAAbADRgLgAdAATMASQeEAwCAF0AER4WAAXqARYAgQARLuQBAH0AFB5CARBgDAAjLgACAAJKADUQDmBrAgF9AvAJEc5g-r3wHw5ADvDsDjAO8O0OIA7w5j8gGgJQ8OYNPg2vAPAa8OYNDg8THgwODRAe8OYNDxteCw0ADvDnDX4N8OkNHj8fHg3w6g0OOg4HAIAbDhsOGw3wxw==")
-- 		circfill(240, 136, 18,  1)
-- 		for i = 0, 6 do circfill(240, 136, 17-i*2,  8+i) end
-- 		circfill(240, 136,  3,  1)
-- 		rrectfill(216, 137, 49, 19, 2, 1)
-- 		rrectfill(217, 138, 47, 17, 2, 7)
-- 		print("promise", 227, 144, 1)
-- 	end
-- end,
-- function(self)	--Tap
-- --[[pod_type="gfx",content={"anything here gets run when","this toggle is clicked."},flavor=4,flipped="false",font=2,head=1048,mono="true",style=2,swapped="true",tab=15,tail=2,text_d=false,text_f=true,text_l=false]]unpod("b64:bHo0ALcBAADqAgAA9QtweHUAQyCIHgTwif8aZfACHvBjHvABDvBlDgYAsjAuAB4QDgAOAC4ABgBCHiAeQAoAUC4ALlAeBgAyEB5AHgAgHlAGAAMoABFgPwAlDgACADUQDhAGADEADmAGABMgDABTIA4wDhAUAAICAAFlAAUkABNQjAAAEQBVLhAOEC5HAACgAMIeEB5QDiAeIA4QLkCuAARBAAO_ABhQjAAbIIoABGwAFyCYADMwDjAWAAMiACUuACQACU0AFACKAAOcABhADAARLh4AARYBJxAeRwABBgAZUGUBARcAAEkBERDPAEAADiAuDAARUAoAIxAeNwAwHvALMAAVQMAAM3AOEJgAAAIAAA4ABEwBFSCwACPwCjQAAI0AKC5QMgAgHmAzAQQyAAB6AAgwAAFkACQwDjIABAIAAGgAAB4BD2gABgUBAjEQHhAnAgELASMeYC0CA8wAVS4QDvAHBAEBewLwCQLOYP5R8BAOQA7wcQ4wDvByDiAO8Gs-IGgAUfBrDT4NZwDwGWsNDg8THgwODRAe8GsNDxteCw0ADvBsDX4N8G4NHj8fHg3wbw0OOg4HAIAbDhsOGw3wWw==")

-- end)))
--------------------------------

:: lib/eggs.p8/eggs.lua
do
 local function oadd(arr,x)
  local l,r,m=1,#arr,nil
  while l<=r do
   m=(l+r)\2
   if arr[m]<x then l=m+1 else r=m-1 end
  end
  add(arr,x,l)
 end

 local function mkmsk(tags)
  local msk,ts={},tags=="" and {} or split(tags)
  for i=1,#ts do msk[ts[i]]=true end
  return msk
 end

 local function mkid(msk)
  local a={}
  for t in pairs(msk) do oadd(a,t) end
  local id=a[1] or ""
  for i=2,#a do id..=","..a[i] end
  return id
 end

 local function link(filt,col)
  local em=col.msk
  for k in pairs(filt.msk) do
   if not em[k] then return end
  end
  filt.cols[col]=true
 end

_ENV.eggs=function()
 local tids,cols,filts,e2col={},{},{},{}

 local function mkcol(id)
  local col={id=id,msk=mkmsk(id),n=0}
  for _,filt in pairs(filts) do link(filt,col) end
  return col
 end

 local function mkfilt(id)
  local filt={cols={},msk=mkmsk(id)}
  for _,col in pairs(cols) do link(filt,col) end
  return filt
 end

 local function ent(tags,e)
  assert(not e2col[e], "entity already exists")
  tids[tags]=tids[tags] or mkid(mkmsk(tags))
  local id=tids[tags]
  cols[id]=cols[id] or mkcol(id)
  local col=cols[id]
  col.n+=1
  local n=col.n
  col[e],col[n]=n,e
  e2col[e]=col
  return e
 end

 local function edel(e)
  local col=e2col[e]
  if not col then return end
  local i,n=col[e],col.n
  if i<n then
   local last=col[n]
   col[last],col[i]=i,last
  end
  col[e],col[n],col.n=nil,nil,n-1
  e2col[e]=nil
 end

 return {
  ent = ent,
  del = edel,
  sys = function(tags,fn)
   tids[tags]=tids[tags] or mkid(mkmsk(tags))
   local id=tids[tags]
   filts[id]=filts[id] or mkfilt(id)
   local fcols=filts[id].cols
   return function()
    for col in pairs(fcols) do
     for i=col.n,1,-1 do
      fn(col[i])
     end
    end
   end
  end,
  msk = function(e)
   local col=e2col[e]
   return col and col.msk
  end,
  tag = function(e,tags)
   local col=e2col[e]
   if not col or tags =="" then return end
   if col.id~="" then
    tags..=","..col.id
   end
   edel(e)
   ent(tags,e)
  end,
  unt = function(e,tags)
   local col=e2col[e]
   if not col or tags=="" then return end
   local msk,ts={},split(tags)
   for t in pairs(col.msk) do msk[t]=true end
   for i=1,#ts do msk[ts[i]]=nil end
   tags=""
   for t in pairs(msk) do
    tags=tags=="" and t or tags..","..t
   end
   edel(e)
   ent(tags,e)
  end,
 }
end
end

:: lib/log.lua
--- A simple logging library
--- @script log.lua
--- @author Andrea D'Amico AKA kc00l
--- @license MIT
local log = {}

--- @table Levels: level names to numbers
local Levels = {
	trace = 1,
	debug = 2,
	info = 3,
	warn = 4,
	error = 5,
	fatal = 6,
}

--- @table log.levels: level names and colors for terminal logging
log.levels = {
	{ name = "trace", color = "\27[34m", },
	{ name = "debug", color = "\27[36m", },
	{ name = "info",  color = "\27[32m", },
	{ name = "warn",  color = "\27[33m", },
	{ name = "error", color = "\27[31m", },
	{ name = "fatal", color = "\27[35m", },
}

log.current_level = Levels.info
log.outfile = nil

--- Formats a timestamp into MM:SS.mmm format
--- @param timestamp number
--- @return string
local function format_timestamp(timestamp)
	local minutes = math.floor(timestamp / 60)
	local seconds = math.floor(timestamp % 60)
	local milliseconds = math.floor((timestamp % 1) * 1000)
	return string.format("%02d:%02d.%03d", minutes, seconds, milliseconds)
end

--- Formats a log entry
--- @param level_index integer
--- @param level_name string
--- @param timestamp number
--- @param message string
--- @return string
local function format_log_entry(level_index, level_name, timestamp, message)
	return log.levels[level_index].color .. " " .. level_name .. " " .. format_timestamp(timestamp) .. "\t" .. message
end

--- Prints a message to the console or to an outfile
--- @param level_index integer
--- @param level_name string
--- @param message any
--- @param ... any
local function log_message(level_index, level_name, message, ...)
	if level_index < log.current_level then return end

	local formatted_message = string.format(message, ...)
	local presentation = format_log_entry(level_index, level_name, time(), formatted_message)
	printh(presentation)

	if log.outfile then
		store(log.outfile, presentation)
	end
end

for i, level in ipairs(log.levels) do
	log[level.name] = function(message, ...) log_message(i, level.name:upper(), message, ...) end
end

function log.init(level_name)
	log.set_level(Levels[level_name] or log.current_level)
end

function log.set_level(level)
	log.current_level = level
end

function log.set_outfile(filename)
	log.outfile = filename
end

function log.get_outfile()
	return log.outfile
end

return log

:: lib/lua-star/lua-star.lua
--[[
    lua-star - A* path finding for Lua
    Copyright 2018 Wesley Werner <wesley.werner@gmail.com>
    HEAVILY OPTIMIZED for Picotron performance
]] --

local module = {}

-- OPTIMIZATION: Maximum nodes to explore before giving up (balanced for performance vs capability)
local MAX_NODES = 500 -- Increased from 300 to handle heavily obstructed rooms

-- Track explored nodes for debugging
local last_explored_count = 0
function module:getLastExploredCount()
   return last_explored_count
end

--- Clears all cached paths.
function module:clearCached()
   module.cache = nil
end

-- (Internal) Generate hash key for a tile coordinate
local function nodeKey(x, y)
   return x * 10000 + y
end

-- (Internal) Return the distance between two points (squared for performance).
local function distance(x1, y1, x2, y2)
   local dx = x1 - x2
   local dy = y1 - y2
   return dx * dx + dy * dy
end

-- (Internal) Clamp a value to a range.
local function clamp(x, min_val, max_val)
   return x < min_val and min_val or (x > max_val and max_val or x)
end

-- (Internal) Insert node into sorted list (maintains order, avoids full resort)
local function insertSorted(list, node)
   -- List is sorted high score to low (so we pop lowest from end)
   local score = node.score
   local pos = #list + 1
   for i = 1, #list do
      if list[i].score < score then
         pos = i
         break
      end
   end
   table.insert(list, pos, node)
end

-- (Internal) Requests adjacent map values around the given node.
local function getAdjacent(width, height, node, positionIsOpenFunc)
   local result = {}
   local nx, ny = node.x, node.y

   -- Cardinal directions only (no diagonals) - inline for speed
   local px, py

   -- Top
   py = ny - 1
   if py >= 1 and positionIsOpenFunc(nx, py) then
      result[#result + 1] = {x = nx, y = py}
   end

   -- Left
   px = nx - 1
   if px >= 1 and positionIsOpenFunc(px, ny) then
      result[#result + 1] = {x = px, y = ny}
   end

   -- Bottom
   py = ny + 1
   if py <= height and positionIsOpenFunc(nx, py) then
      result[#result + 1] = {x = nx, y = py}
   end

   -- Right
   px = nx + 1
   if px <= width and positionIsOpenFunc(px, ny) then
      result[#result + 1] = {x = px, y = ny}
   end

   return result
end

-- Returns the path from start to goal, or false if no path exists.
function module:find(width, height, start, goal, positionIsOpenFunc, useCache, excludeDiagonalMoving)
   local open = {}
   local nodes_explored = 0

   -- Hash tables for O(1) lookups
   local closed_hash = {}
   local open_hash = {}

   -- Initialize start node
   local start_H = distance(start.x, start.y, goal.x, goal.y)
   start.score = start_H
   start.G = 0
   start.parent = nil

   open[1] = start
   open_hash[nodeKey(start.x, start.y)] = start

   local goal_key = nodeKey(goal.x, goal.y)

   while #open > 0 do
      nodes_explored = nodes_explored + 1
      if nodes_explored > MAX_NODES then
         last_explored_count = nodes_explored
         return false
      end

      -- Pop lowest score node (at end of list)
      local current = table.remove(open)
      local current_key = nodeKey(current.x, current.y)

      open_hash[current_key] = nil
      closed_hash[current_key] = current

      -- Goal reached?
      if current_key == goal_key then
         -- Build path by traversing parents
         local path = {}
         local node = current
         while node do
            path[#path + 1] = {x = node.x, y = node.y}
            node = node.parent
         end
         -- Reverse path
         local reversed = {}
         for i = #path, 1, -1 do
            reversed[#reversed + 1] = path[i]
         end
         return reversed
      end

      -- Process adjacent cells
      local adjacentList = getAdjacent(width, height, current, positionIsOpenFunc)

      for i = 1, #adjacentList do
         local adjacent = adjacentList[i]
         local adj_key = nodeKey(adjacent.x, adjacent.y)

         if not closed_hash[adj_key] and not open_hash[adj_key] then
            local G = current.G + 1
            local H = distance(adjacent.x, adjacent.y, goal.x, goal.y)
            adjacent.score = G + H
            adjacent.G = G
            adjacent.parent = current

            insertSorted(open, adjacent)
            open_hash[adj_key] = adjacent
         end
      end
   end

   return false
end

return module

:: lib/lua-star/pathfinder.lua
-- Pathfinding wrapper for Pizak
-- Provides tile-based pathfinding using lua-star
-- Integrates with DungeonManager for walkability checks
-- OPTIMIZED: Failed path cache, reduced search margin

local luastar = require("lib/lua-star/lua-star")

local Pathfinder = {}

-- Constants
local GRID_SIZE = 16 -- Tile size in pixels
local MAP_W = 256    -- Map width in tiles (extended map)
local MAP_H = 256    -- Map height in tiles (extended map)

-- Cache for the current room's walkability (cleared on room transition)
local walkability_cache = {}
local cache_room_key = nil

-- OPTIMIZATION: Cache failed pathfinding attempts (tile coords -> expiry time)
-- This prevents repeated expensive A* calls for unreachable destinations
local failed_path_cache = {}
local FAILED_CACHE_TTL = 1.0 -- Reduced from 5s - retry failed paths more frequently

-- Debug logging rate limiter (avoid terminal spam)
local DEBUG_LOG_INTERVAL = 1.0 -- Seconds between log messages
local last_log_time = 0

local function log_trace_limited(msg)
   local now = t()
   if now - last_log_time >= DEBUG_LOG_INTERVAL then
      Log.trace(msg)
      last_log_time = now
   end
end

--- Clear the walkability cache (call on room transitions)
function Pathfinder.clear_cache()
   walkability_cache = {}
   failed_path_cache = {} -- Also clear failed cache on room change
   cache_room_key = nil
   luastar:clearCached()
end

--- Check if a tile is walkable
--- @param tx number Tile X
--- @param ty number Tile Y
--- @param room table|nil Optional room for obstacle checks
--- @param is_goal_tile boolean|nil If true, skip all walkability checks (entity exists there so it's reachable)
--- @return boolean
function Pathfinder.is_walkable(tx, ty, room, is_goal_tile)
   -- Bounds check (always required)
   if tx < 0 or tx >= MAP_W or ty < 0 or ty >= MAP_H then
      return false
   end

   -- Goal tiles skip all walkability checks - if an entity is at that position, it's reachable
   if is_goal_tile then
      return true
   end

   -- Check cache first
   local key = tx..","..ty
   if walkability_cache[key] ~= nil then
      return walkability_cache[key]
   end

   -- Query the map tile
   local tile = mget(tx, ty)

   -- Check if solid via sprite flag (flag 0 = solid)
   if fget(tile, SOLID_FLAG) then
      walkability_cache[key] = false
      return false
   end

   -- Check for pit tiles (by ID or by sprite flag)
   if tile == PIT_TILE or fget(tile, FEATURE_FLAG_PIT) then
      walkability_cache[key] = false
      return false
   end

   -- Check floor tiles
   local is_floor = false
   if tile == 0 or tile == EMPTY_TILE then
      is_floor = true
   else
      for _, f in ipairs(FLOOR_TILES) do
         if tile == f then
            is_floor = true
            break
         end
      end
   end

   if not is_floor then
      walkability_cache[key] = false
      return false
   end

   -- Check for dynamic obstacles (rocks, destructibles) in room
   -- NOTE: We do NOT cache these results because obstacles can be destroyed mid-game
   if room and room.obstacle_entities then
      for _, obs in ipairs(room.obstacle_entities) do
         if not obs.destroyed then
            -- Use stored tile coordinates if available (fixes pixel offset mismatch)
            -- Fall back to pixel calculation for backwards compatibility
            local obs_tx = obs.tile_x or flr(obs.x / GRID_SIZE)
            local obs_ty = obs.tile_y or flr(obs.y / GRID_SIZE)
            if tx == obs_tx and ty == obs_ty then
               return false -- Don't cache - obstacle may be destroyed later
            end
         end
      end
   end

   walkability_cache[key] = true
   return true
end

--- Convert pixel coordinates to tile coordinates
--- @param px number Pixel X
--- @param py number Pixel Y
--- @return number, number Tile X, Tile Y
function Pathfinder.pixel_to_tile(px, py)
   return flr(px / GRID_SIZE), flr(py / GRID_SIZE)
end

--- Convert tile coordinates to pixel coordinates (center of tile)
--- @param tx number Tile X
--- @param ty number Tile Y
--- @return number, number Pixel X, Pixel Y (center)
function Pathfinder.tile_to_pixel(tx, ty)
   return tx * GRID_SIZE + GRID_SIZE / 2, ty * GRID_SIZE + GRID_SIZE / 2
end

--- Try to nudge a position to a nearby walkable tile
--- @param tx number Tile X
--- @param ty number Tile Y
--- @param room table|nil Optional room for obstacle checks
--- @return number|nil, number|nil Nudged tile coordinates, or nil if none found
local function nudge_to_walkable(tx, ty, room)
   for dy = -1, 1 do
      for dx = -1, 1 do
         if Pathfinder.is_walkable(tx + dx, ty + dy, room) then
            return tx + dx, ty + dy
         end
      end
   end
   return nil, nil
end

--- Find a path from start to goal (pixel coordinates)
--- @param start_x number Start pixel X
--- @param start_y number Start pixel Y
--- @param goal_x number Goal pixel X
--- @param goal_y number Goal pixel Y
--- @param room table|nil Optional room for obstacle checks
--- @return table|false Path as list of {x, y} pixel waypoints, or false if no path
function Pathfinder.find_path(start_x, start_y, goal_x, goal_y, room)
   local sx, sy = Pathfinder.pixel_to_tile(start_x, start_y)
   local gx, gy = Pathfinder.pixel_to_tile(goal_x, goal_y)

   -- Quick check: if start is unwalkable, try to nudge
   -- Use is_goal_tile=true since if an entity is at that position, it's valid
   if not Pathfinder.is_walkable(sx, sy, room, true) then
      local nsx, nsy = nudge_to_walkable(sx, sy, room)
      if nsx then
         log_trace_limited("Pathfinder: nudged start from ("..sx..","..sy..") to ("..nsx..","..nsy..")")
         sx, sy = nsx, nsy
      else
         log_trace_limited("Pathfinder: NO PATH - start tile ("..sx..","..sy..") is unwalkable and no nudge found")
         return false -- No valid start found
      end
   end

   -- Quick check: if goal is unwalkable, try to nudge
   -- Use is_goal_tile=true since if an entity is at that position, it's reachable
   -- This skips all walkability checks (walls, pits, obstacles) for the goal tile
   if not Pathfinder.is_walkable(gx, gy, room, true) then
      local ngx, ngy = nudge_to_walkable(gx, gy, room)
      if ngx then
         log_trace_limited("Pathfinder: nudged goal from ("..gx..","..gy..") to ("..ngx..","..ngy..")")
         gx, gy = ngx, ngy
      else
         log_trace_limited("Pathfinder: NO PATH - goal tile ("..gx..","..gy..") is unwalkable and no nudge found")
         return false -- No valid goal found
      end
   end

   -- Same tile? No path needed
   if sx == gx and sy == gy then
      return {}
   end

   -- OPTIMIZATION: Check failed path cache before expensive A* call
   local cache_key = sx..","..sy..">"..gx..","..gy
   local cached_failure = failed_path_cache[cache_key]
   if cached_failure and cached_failure > t() then
      log_trace_limited("Pathfinder: NO PATH - cached failure ("..
         cache_key.."), TTL="..string.format("%.1f", cached_failure - t()).."s")
      return false -- Still within TTL, skip pathfinding
   end

   -- Calculate bounded search area (only search tiles near start/goal)
   -- Balance: larger margin finds more paths, smaller is faster
   local SEARCH_MARGIN = 20 -- Increased from 12 to allow paths around larger obstacles
   local min_x = min(sx, gx) - SEARCH_MARGIN
   local max_x = max(sx, gx) + SEARCH_MARGIN
   local min_y = min(sy, gy) - SEARCH_MARGIN
   local max_y = max(sy, gy) + SEARCH_MARGIN

   -- Create callback for lua-star with bounded checking
   local function is_open(x, y)
      -- Quick bounds check first
      if x < min_x or x > max_x or y < min_y or y > max_y then
         return false
      end
      return Pathfinder.is_walkable(x, y, room)
   end

   -- Find path in tile space (no diagonals for grid-aligned movement)
   -- Use bounded search area instead of full map
   local tile_path = luastar:find(
      max_x + 1, max_y + 1, -- Use max bounds as effective map size
      {x = sx, y = sy},
      {x = gx, y = gy},
      is_open,
      false, -- No caching (dynamic obstacles)
      true   -- Exclude diagonal movement
   )

   if not tile_path then
      -- OPTIMIZATION: Cache failed attempt to avoid retrying too soon
      failed_path_cache[cache_key] = t() + FAILED_CACHE_TTL
      log_trace_limited("Pathfinder: NO PATH - A* failed from ("..sx..","..sy..") to ("..gx..","..gy..")")
      return false
   end

   -- Convert to pixel waypoints (center of each tile)
   local pixel_path = {}
   for i, node in ipairs(tile_path) do
      -- Skip first waypoint if it's the current position
      if i > 1 then
         local px, py = Pathfinder.tile_to_pixel(node.x, node.y)
         add(pixel_path, {x = px, y = py})
      end
   end

   return pixel_path
end

return Pathfinder

:: lib/lua-state-machine/spec/fsm_spec.lua
require("busted")

local machine = require("statemachine")
local _ = require("luassert.match")._

describe("Lua state machine framework", function()
  describe("A stop light", function()
    local fsm
    local stoplight = {
      { name = 'warn',  from = 'green',  to = 'yellow' },
      { name = 'panic', from = 'yellow', to = 'red'    },
      { name = 'calm',  from = 'red',    to = 'yellow' },
      { name = 'clear', from = 'yellow', to = 'green'  }
    }

    before_each(function()
      fsm = machine.create({ initial = 'green', events = stoplight })
    end)

    it("should start as green", function()
      assert.are_equal(fsm.current, 'green')
    end)

    it("should not let you get to the wrong state", function()
      assert.is_false(fsm:panic())
      assert.is_false(fsm:calm())
      assert.is_false(fsm:clear())
    end)

    it("should let you go to yellow", function()
      assert.is_true(fsm:warn())
      assert.are_equal(fsm.current, 'yellow')
    end)

    it("should tell you what it can do", function()
      assert.is_true(fsm:can('warn'))
      assert.is_false(fsm:can('panic'))
      assert.is_false(fsm:can('calm'))
      assert.is_false(fsm:can('clear'))
    end)

    it("should tell you what it can't do", function()
      assert.is_false(fsm:cannot('warn'))
      assert.is_true(fsm:cannot('panic'))
      assert.is_true(fsm:cannot('calm'))
      assert.is_true(fsm:cannot('clear'))
    end)

    it("should support checking states", function()
      assert.is_true(fsm:is('green'))
      assert.is_false(fsm:is('red'))
      assert.is_false(fsm:is('yellow'))
    end)

    it("should fire callbacks", function()
      local fsm = machine.create({
        initial = 'green',
        events = stoplight,
        callbacks = {
          onbeforewarn = stub.new(),
          onleavegreen = stub.new(),
          onenteryellow = stub.new(),
          onafterwarn = stub.new(),
          onstatechange = stub.new(),
          onyellow = stub.new(),
          onwarn = stub.new()
        }
      })

      fsm:warn()

      assert.spy(fsm.onbeforewarn).was_called_with(_, 'warn', 'green', 'yellow')
      assert.spy(fsm.onleavegreen).was_called_with(_, 'warn', 'green', 'yellow')

      assert.spy(fsm.onenteryellow).was_called_with(_, 'warn', 'green', 'yellow')
      assert.spy(fsm.onafterwarn).was_called_with(_, 'warn', 'green', 'yellow')
      assert.spy(fsm.onstatechange).was_called_with(_, 'warn', 'green', 'yellow')

      assert.spy(fsm.onyellow).was_not_called()
      assert.spy(fsm.onwarn).was_not_called()
    end)

    it("should fire handlers", function()
      fsm.onbeforewarn = stub.new()
      fsm.onleavegreen = stub.new()
      fsm.onenteryellow = stub.new()
      fsm.onafterwarn = stub.new()
      fsm.onstatechange = stub.new()

      fsm.onyellow = stub.new()
      fsm.onwarn = stub.new()

      fsm:warn()

      assert.spy(fsm.onbeforewarn).was_called_with(_, 'warn', 'green', 'yellow')
      assert.spy(fsm.onleavegreen).was_called_with(_, 'warn', 'green', 'yellow')

      assert.spy(fsm.onenteryellow).was_called_with(_, 'warn', 'green', 'yellow')
      assert.spy(fsm.onafterwarn).was_called_with(_, 'warn', 'green', 'yellow')
      assert.spy(fsm.onstatechange).was_called_with(_, 'warn', 'green', 'yellow')

      assert.spy(fsm.onyellow).was_not_called()
      assert.spy(fsm.onwarn).was_not_called()
    end)

    it("should accept additional arguments to handlers", function()
      fsm.onbeforewarn = stub.new()
      fsm.onleavegreen = stub.new()
      fsm.onenteryellow = stub.new()
      fsm.onafterwarn = stub.new()
      fsm.onstatechange = stub.new()

      fsm:warn('bar')

      assert.spy(fsm.onbeforewarn).was_called_with(_, 'warn', 'green', 'yellow', 'bar')
      assert.spy(fsm.onleavegreen).was_called_with(_, 'warn', 'green', 'yellow', 'bar')
      
      assert.spy(fsm.onenteryellow).was_called_with(_, 'warn', 'green', 'yellow', 'bar')
      assert.spy(fsm.onafterwarn).was_called_with(_, 'warn', 'green', 'yellow', 'bar')
      assert.spy(fsm.onstatechange).was_called_with(_, 'warn', 'green', 'yellow', 'bar')
    end)

    it("should fire short handlers as a fallback", function()
      fsm.onyellow = stub.new()
      fsm.onwarn = stub.new()

      fsm:warn()

      assert.spy(fsm.onyellow).was_called_with(_, 'warn', 'green', 'yellow')
      assert.spy(fsm.onwarn).was_called_with(_, 'warn', 'green', 'yellow')
    end)

    it("should cancel the warn event from onleavegreen", function()
      fsm.onleavegreen = function(self, name, from, to) 
        return false
      end

      local result = fsm:warn()

      assert.is_false(result)
      assert.are_equal(fsm.current, 'green')
    end)

    it("should cancel the warn event from onbeforewarn", function()
      fsm.onbeforewarn = function(self, name, from, to) 
        return false
      end

      local result = fsm:warn()

      assert.is_false(result)
      assert.are_equal(fsm.current, 'green')
    end)

    it("pauses when async is passed", function()
      fsm.onleavegreen = function(self, name, from, to)
        return fsm.ASYNC
      end
      fsm.onenteryellow = function(self, name, from, to)
        return fsm.ASYNC
      end

      local result = fsm:warn()
      assert.is_true(result)
      assert.are_equal(fsm.current, 'green')
      assert.are_equal(fsm.currentTransitioningEvent, 'warn')
      assert.are_equal(fsm.asyncState, 'warnWaitingOnLeave')

      result = fsm:transition(fsm.currentTransitioningEvent)
      assert.is_true(result)
      assert.are_equal(fsm.current, 'yellow')
      assert.are_equal(fsm.currentTransitioningEvent, 'warn')
      assert.are_equal(fsm.asyncState, 'warnWaitingOnEnter')

      result = fsm:transition(fsm.currentTransitioningEvent)
      assert.is_true(result)
      assert.are_equal(fsm.current, 'yellow')
      assert.is_nil(fsm.currentTransitioningEvent)
      assert.are_equal(fsm.asyncState, fsm.NONE)
    end)

    it("should accept additional arguments to async handlers", function()
      fsm.onbeforewarn = stub.new()
      fsm.onleavegreen = spy.new(function(self, name, from, to, arg)
        return fsm.ASYNC
      end)
      fsm.onenteryellow = spy.new(function(self, name, from, to, arg)
        return fsm.ASYNC
      end)
      fsm.onafterwarn = stub.new()
      fsm.onstatechange = stub.new()

      fsm:warn('bar')
      assert.spy(fsm.onbeforewarn).was_called_with(_, 'warn', 'green', 'yellow', 'bar')
      assert.spy(fsm.onleavegreen).was_called_with(_, 'warn', 'green', 'yellow', 'bar')

      fsm:transition(fsm.currentTransitioningEvent)
      assert.spy(fsm.onenteryellow).was_called_with(_, 'warn', 'green', 'yellow', 'bar')

      fsm:transition(fsm.currentTransitioningEvent)
      assert.spy(fsm.onafterwarn).was_called_with(_, 'warn', 'green', 'yellow', 'bar')
      assert.spy(fsm.onstatechange).was_called_with(_, 'warn', 'green', 'yellow', 'bar')
    end)

    it("should properly transition when another event happens during leave async", function()
      local tempStoplight = {}
      for _, event in ipairs(stoplight) do
        table.insert(tempStoplight, event)
      end
      table.insert(tempStoplight, { name = "panic", from = "green", to = "red" })
      
      local fsm = machine.create({
        initial = 'green',
        events = tempStoplight
      })

      fsm.onleavegreen = function(self, name, from, to)
        return fsm.ASYNC
      end

      fsm:warn()

      local result = fsm:panic()
      local transitionResult = fsm:transition(fsm.currentTransitioningEvent)

      assert.is_true(result)
      assert.is_true(transitionResult)
      assert.is_nil(fsm.currentTransitioningEvent)
      assert.are_equal(fsm.asyncState, fsm.NONE)
      assert.are_equal(fsm.current, 'red')
    end)

    it("should properly transition when another event happens during enter async", function()
      fsm.onenteryellow = function(self, name, from, to)
        return fsm.ASYNC
      end

      fsm:warn()

      local result = fsm:panic()

      assert.is_true(result)
      assert.is_nil(fsm.currentTransitioningEvent)
      assert.are_equal(fsm.asyncState, fsm.NONE)
      assert.are_equal(fsm.current, 'red')
    end)

    it("should properly cancel the transition if asked", function()
      fsm.onleavegreen = function(self, name, from, to)
        return fsm.ASYNC
      end

      fsm:warn()
      fsm:cancelTransition(fsm.currentTransitioningEvent)

      assert.is_nil(fsm.currentTransitioningEvent)
      assert.are_equal(fsm.asyncState, fsm.NONE)
      assert.are_equal(fsm.current, 'green')

      fsm.onleavegreen = nil
      fsm.onenteryellow = function(self, name, from, to)
        return fsm.ASYNC
      end

      fsm:warn()
      fsm:cancelTransition(fsm.currentTransitioningEvent)

      assert.is_nil(fsm.currentTransitioningEvent)
      assert.are_equal(fsm.asyncState, fsm.NONE)
      assert.are_equal(fsm.current, 'yellow')
    end)

    it("todot generates dot file (graphviz)", function()
      assert.has_no_error(function()
        fsm:todot('stoplight.dot')
      end)
      assert.is_equal(io.open('stoplight.dot'):read('*a'), io.open('stoplight.dot.ref'):read('*a'))
    end)
  end)

  describe("A monster", function()
    local fsm
    local monster = {
      { name = 'eat',  from = 'hungry',                                to = 'satisfied' },
      { name = 'eat',  from = 'satisfied',                             to = 'full'      },
      { name = 'eat',  from = 'full',                                  to = 'sick'      },
      { name = 'rest', from = {'hungry', 'satisfied', 'full', 'sick'}, to = 'hungry'    }
    }

    before_each(function()
      fsm = machine.create({ initial = 'hungry', events = monster })
    end)

    it("can eat unless it is sick", function()
      assert.are_equal(fsm.current, 'hungry')
      assert.is_true(fsm:can('eat'))
      fsm:eat()
      assert.are_equal(fsm.current, 'satisfied')
      assert.is_true(fsm:can('eat'))
      fsm:eat()
      assert.are_equal(fsm.current, 'full')
      assert.is_true(fsm:can('eat'))
      fsm:eat()
      assert.are_equal(fsm.current, 'sick')
      assert.is_false(fsm:can('eat'))
    end)

    it("can always rest", function()
      assert.are_equal(fsm.current, 'hungry')
      assert.is_true(fsm:can('rest'))
      fsm:eat()
      assert.are_equal(fsm.current, 'satisfied')
      assert.is_true(fsm:can('rest'))
      fsm:eat()
      assert.are_equal(fsm.current, 'full')
      assert.is_true(fsm:can('rest'))
      fsm:eat()
      assert.are_equal(fsm.current, 'sick')
      assert.is_true(fsm:can('rest'))
      fsm:rest()
      assert.are_equal(fsm.current, 'hungry')
    end)
  end)
end)

:: lib/lua-state-machine/statemachine.lua
local machine = {}
machine.__index = machine

local NONE = "none"
local ASYNC = "async"

-- Compatibility for Lua 5.1 vs 5.2+
local unpack = unpack or table.unpack

local function call_handler(handler, params)
  if handler then
    return handler(unpack(params))
  end
end

local function create_transition(name)
  local can, to, from, params

  local function transition(self, ...)
    if self.asyncState == NONE then
      can, to = self:can(name)
      from = self.current
      params = { self, name, from, to, ...}

      if not can then return false end
      self.currentTransitioningEvent = name

      local beforeReturn = call_handler(self["onbefore" .. name], params)
      local leaveReturn = call_handler(self["onleave" .. from], params)

      if beforeReturn == false or leaveReturn == false then
        return false
      end

      self.asyncState = name .. "WaitingOnLeave"

      if leaveReturn ~= ASYNC then
        transition(self, ...)
      end
      
      return true
    elseif self.asyncState == name .. "WaitingOnLeave" then
      self.current = to

      local enterReturn = call_handler(self["onenter" .. to] or self["on" .. to], params)

      self.asyncState = name .. "WaitingOnEnter"

      if enterReturn ~= ASYNC then
        transition(self, ...)
      end
      
      return true
    elseif self.asyncState == name .. "WaitingOnEnter" then
      call_handler(self["onafter" .. name] or self["on" .. name], params)
      call_handler(self["onstatechange"], params)
      self.asyncState = NONE
      self.currentTransitioningEvent = nil
      return true
    else
    	if string.find(self.asyncState, "WaitingOnLeave") or string.find(self.asyncState, "WaitingOnEnter") then
    		self.asyncState = NONE
    		transition(self, ...)
    		return true
    	end
    end

    self.currentTransitioningEvent = nil
    return false
  end

  return transition
end

local function add_to_map(map, event)
  if type(event.from) == 'string' then
    map[event.from] = event.to
  else
    for _, from in ipairs(event.from) do
      map[from] = event.to
    end
  end
end

function machine.create(options)
  assert(options.events)

  local fsm = {}
  setmetatable(fsm, machine)

  fsm.options = options
  fsm.current = options.initial or 'none'
  fsm.asyncState = NONE
  fsm.events = {}

  for _, event in ipairs(options.events or {}) do
    local name = event.name
    fsm[name] = fsm[name] or create_transition(name)
    fsm.events[name] = fsm.events[name] or { map = {} }
    add_to_map(fsm.events[name].map, event)
  end
  
  for name, callback in pairs(options.callbacks or {}) do
    fsm[name] = callback
  end

  return fsm
end

function machine:is(state)
  return self.current == state
end

function machine:can(e)
  local event = self.events[e]
  local to = event and event.map[self.current] or event.map['*']
  return to ~= nil, to
end

function machine:cannot(e)
  return not self:can(e)
end

function machine:todot(filename)
  local dotfile = io.open(filename,'w')
  assert(dotfile~=nil)
  dotfile:write('digraph {\n')
  local transition = function(event,from,to)
    dotfile:write(string.format('%s -> %s [label=%s];\n',from,to,event))
  end
  for _, event in pairs(self.options.events) do
    if type(event.from) == 'table' then
      for _, from in ipairs(event.from) do
        transition(event.name,from,event.to)
      end
    else
      transition(event.name,event.from,event.to)
    end
  end
  dotfile:write('}\n')
  dotfile:close()
end

function machine:transition(event)
  if self.currentTransitioningEvent == event then
    return self[self.currentTransitioningEvent](self)
  end
end

function machine:cancelTransition(event)
  if self.currentTransitioningEvent == event then
    self.asyncState = NONE
    self.currentTransitioningEvent = nil
  end
end

machine.NONE = NONE
machine.ASYNC = ASYNC

return machine

:: lib/pgui.lua
--[[
	pgui - an Immediate Mode GUI library for Picotron
	v1.0.4
	By Sergio Rodriguez Gomez
	https://srsergior.itch.io/ | https://srsergiorodriguez.github.io/code?lang=en
	MIT License
	Donate:
	https://ko-fi.com/srsergior | https://buymeacoffee.com/srsergior
]] --

pgui_components = {}

pgui_components.unknown = {fns = {}, data = {text = "?", _id = "unknown"}}
pgui_components.unknown.fns.draw = function(self) print("[?]", self.pos.x, self.pos.y, 8) end

pgui_components.placeholder = {fns = {}, data = {_id = "placeholder", visible = false}}
pgui_components.placeholder.fns.draw = function(self) if (self.visible) then print("[x]", self.pos.x, self.pos.y, 8) end end

pgui_components.text = {fns = {}, data = {_id = "text", text = "TEXT", size = vec(0, 7)}}
pgui_components.text.fns.update = function(self)
   return self.text
end
pgui_components.text.fns.draw = function(self)
   pgui:_text(self.text, self, self.color[4])
end

pgui_components.rect = {fns = {}, data = {_id = "rect", size = vec(16, 16)}}
pgui_components.rect.fns.draw = function(self)
   pgui:_rect(self.pos.x + self.offset.x, self.pos.y + self.offset.y, self.size.x, self.size.y, self.color[4], false)
end

pgui_components.line = {fns = {}, data = {_id = "line", size = vec(16, 16)}}
pgui_components.line.fns.draw = function(self)
   local x = self.pos.x + self.offset.x
   local y = self.pos.y + self.offset.y
   line(x, y, x + self.size.x, y + self.size.y, self.color[4])
end

pgui_components.radiocircle = {fns = {}, data = {_id = "radiocircle", r = 4, on = false}}
pgui_components.radiocircle.fns.update = function(self)
   self.size = vec(self.r * 2, self.r * 2)
end
pgui_components.radiocircle.fns.draw = function(self)
   local fill = self.color[3]
   local stroke = self.color[4]
   pgui:_radiocirc(self, self.r, fill, stroke, self.on)
end

pgui_components.multibox = {fns = {}, data = {_id = "multibox", size = vec(8, 8), on = false}}
pgui_components.multibox.fns.draw = function(self)
   -- this is a single box, but used for multiple selection components!
   local fill = self.color[3]
   local stroke = self.color[4]
   local pos = self.pos + self.offset
   if (self.on) then pgui:_rect(pos.x, pos.y, self.size.x, self.size.y, fill, true) end
   pgui:_rect(pos.x, pos.y, self.size.x, self.size.y, stroke, false)
end

pgui_components.box = {fns = {}, data = {_id = "box", size = vec(16, 16), stroke = true, active = false, hover = false}}
pgui_components.box.fns.draw = function(self)
   local fill = self.color[1]
   local mouse_events = pgui:mouse_events(self)
   if (mouse_events.over and self.hover) then fill = self.color[2] end
   if (mouse_events.left_btn and self.active) then fill = self.color[3] end
   local stroke = self.stroke and self.color[4] or fill
   pgui:_box(self, self.size.x, self.size.y, fill, stroke)
end

pgui_components.text_box = {fns = {}, data = {_id = "text_box", text = "TEXTBOX", margin = 2, stroke = true, active = false, hover = false}}
pgui_components.text_box.fns.update = function(self)
   if pgui.stats.memos.text_width[self.text] == nil then
      pgui.stats.memos.text_width[self.text] = pgui:get_text_width(self.text)
   end
   local text_width = pgui.stats.memos.text_width[self.text]
   local lines = #split(self.text, "\n")
   local text_height = lines == 1 and 6 or lines * 9
   self.size = vec(text_width + (self.margin * 2), (self.margin * 2) + text_height)
   pgui:component("box", {size = self.size, hover = self.hover, active = self.active, stroke = self.stroke}, self)
   pgui:component("text", {pos = vec(self.margin, self.margin), active = self.active, text = self.text}, self)
   return self.text
end

pgui_components.sprite = {fns = {}, data = {_id = "sprite", sprite = 0, size = vec(0, 7), fn = function() end, reset_palt = true}}
pgui_components.sprite.fns.draw = function(self)
   self.fn()
   pgui:_sprite(self.sprite, self)
   if (self.reset_palt) then palt() end
end

pgui_components.sprite_box = {fns = {}, data = {_id = "sprite_box", sprite = 0, margin = 2, stroke = true, active = false, hover = false, fn = function() end}}
pgui_components.sprite_box.fns.update = function(self)
   local sprite_width = get_spr(self.sprite):width() - 1
   local sprite_height = get_spr(self.sprite):height() - 1
   self.size = vec(sprite_width + (self.margin * 2), (self.margin * 2) + sprite_height)
   local box = pgui:precomponent("box", {size = self.size, hover = self.hover, active = self.active, stroke = self
   .stroke}, self)
   box:_update()
   pgui:component("sprite", {pos = vec(self.margin, self.margin), active = self.active, sprite = self.sprite, p = self.p},
      self)
   return pgui:mouse_events(box).clicked
end

pgui_components.input = {fns = {}, data = {label = "input", _id = "input", text = "INPUT", charlen = 16, margin = 2}}
pgui_components.input.fns.update = function(self)
   if (pgui:get_store(self.label, true) == nil) then
      local text_width = pgui:get_text_width(self.text)
      pgui:set_store(self.label, {
         cursor_pos = self.margin + text_width,
         cursor_idx = 0,
         active = false,
      }, true)
   end

   local text_box = pgui:precomponent("text_box", {text = self.text, margin = self.margin}, self)
   text_box:_update()
   text_box.size.x = (6 * self.charlen) + (self.margin * 2)
   self.size = text_box.size:copy()

   local mouse_events = pgui:mouse_events(text_box)
   local store = pgui:get_store(self.label, true)
   if mouse_events.clicked then
      local relx = mouse_events.rel_pos.x
      local cursor_pos = pgui:get_cursor_pos(self.margin, self.text, relx)
      store.cursor_pos = cursor_pos[1]
      store.cursor_idx = cursor_pos[2]
      store.cursor_line = 0
      store.active = true
   elseif pgui:get_mouse().mb == 1 and not mouse_events.left_btn then
      store.active = false
   end

   if store.active then
      local lines = #split(self.text, "\n")
      local col = self.color[3]
      if pgui.stats.blink then
         pgui:component("box", {
            pos = vec(store.cursor_pos, self.margin - 1 + (store.cursor_line * 9)),
            size = vec(1, 8),
            color = {col, 0, 0, col}
         }, self)
      end
      if keyp("backspace") and store.cursor_idx > 0 then
         local removed = sub(self.text, store.cursor_idx, store.cursor_idx)
         self.text = sub(self.text, 0, store.cursor_idx - 1)..sub(self.text, store.cursor_idx + 1)
         store.cursor_pos -= pgui:get_text_width(removed)
         store.cursor_idx -= 1
      elseif keyp("left") and store.cursor_idx > 0 then
         local prevchar = sub(self.text, store.cursor_idx, store.cursor_idx)
         store.cursor_pos -= pgui:get_text_width(prevchar)
         store.cursor_idx -= 1
      elseif keyp("right") and store.cursor_idx < #self.text then
         local nextchar = sub(self.text, store.cursor_idx + 1, store.cursor_idx + 1)
         store.cursor_pos += pgui:get_text_width(nextchar)
         store.cursor_idx += 1
      end
      local is_shift = false
      if (key("shift")) then is_shift = true end
      for i, scancode in ipairs(pgui.stats.scancodes) do
         if keyp(scancode) and self.charlen > #self.text then
            local str = scancode == "space" and " " or scancode
            -- str = str == "enter" and "\n" or str --for future text field
            str = str == "enter" and "" or str
            str = is_shift and get_scancode_upper(i) or
            str                                     -- Use my scancode_upper func to do the work instead of lua's upper()
            self.text = sub(self.text, 0, store.cursor_idx)..str..sub(self.text, store.cursor_idx + 1)
            store.cursor_pos += pgui:get_text_width(str)
            store.cursor_idx += 1
         end
      end

      -- this will help to create a text field component in the future
      -- store.cursor_line += #split(self.text,"\n") - lines

      store.cursor_pos = max(0, store.cursor_pos)
      store.cursor_idx = max(0, store.cursor_idx)
   end

   return self.text
end

pgui_components.button = {fns = {}, data = {_id = "button", text = "BUTTON", margin = 2, stroke = true, disable = false}}
pgui_components.button.fns.update = function(self)
   local text_box = pgui:precomponent("text_box",
      {text = self.text, hover = not self.disable, active = not self.disable, stroke = self.stroke, margin = self.margin},
      self)
   text_box:_update()
   local mouse_events = pgui:mouse_events(text_box)
   self.size = text_box.size:copy()
   return mouse_events.clicked
end

pgui_components.vstack = {fns = {}, data = {_id = "vstack", stroke = true, height = 0, margin = 3, gap = 3, contents = {}, box = true}}
pgui_components.vstack.fns.update = function(self)
   self.size = vec(0, self.margin * 2)
   local y = self.margin
   if (self.box) then pgui:component("box", {size = self.size, stroke = self.stroke}, self) end
   local upds = {}
   for content in all(self.contents) do
      local com = pgui:precomponent(content[1], content[2], self)
      com.pos = vec(self.margin + com.pos.x, y + com.pos.y)
      if (com._id == "dropdown") then com.grow = true end
      local upd = com:_update()
      add(upds, upd)
      self.size.x = com.size.x > self.size.x and com.size.x + com.pos.x or self.size.x
      self.size.y += com.size.y + self.gap
      y += (com.size.y + self.gap)
   end
   self.size.x += self.margin * 2
   self.size.y = self.height != 0 and self.height or self.size.y - self.gap
   return upds
end

pgui_components.hstack = {fns = {}, data = {_id = "hstack", stroke = true, width = 0, margin = 3, gap = 3, contents = {}, box = true}}
pgui_components.hstack.fns.update = function(self)
   self.size = vec(self.margin * 2, 0)
   local x = self.margin
   if (self.box) then pgui:component("box", {size = self.size, stroke = self.stroke}, self) end
   local upds = {}
   for content in all(self.contents) do
      local com = pgui:precomponent(content[1], content[2], self)
      com.pos = vec(x + com.pos.x, self.margin + com.pos.y)
      if (com._id == "dropdown") then com.grow = false end
      local upd = com:_update()
      add(upds, upd)
      self.size.y = com.size.y > self.size.y and com.size.y + com.pos.y or self.size.y
      self.size.x += com.size.x + self.gap
      x += (com.size.x + self.gap)
   end
   self.size.y += self.margin * 2
   self.size.x = self.width > 0 and self.width or self.size.x - self.gap
   return upds
end

pgui_components.topbar = {fns = {}, data = {_id = "topbar", width = 479, gap = 3, contents = {}}}
pgui_components.topbar.fns.update = function(self)
   return pgui:component("hstack", {gap = self.gap, width = self.width, stroke = false, margin = 0, contents = self
   .contents}, self)
end

pgui_components.dropdown = {fns = {}, data = {label = "dd", _id = "dropdown", grow = false, text = "DROPDOWN", stroke = true, margin = 2, gap = 3, contents = {}, disable = false}}
pgui_components.dropdown.fns.update = function(self)
   if (pgui:get_store(self.label, true) == nil) then pgui:set_store(self.label, false, true) end
   local button = pgui:precomponent("button",
      {size = self.size, stroke = self.stroke, text = self.text, margin = self.margin, disable = self.disable}, self)
   local clicked = button:_update()
   self.size = button.size:copy()
   pgui:component("line", {pos = vec(0, button.size.y), size = vec(self.size.x, 0)}, self)
   if clicked and not self.disable then
      local toggle = not pgui:get_store(self.label, true)
      pgui:set_store(self.label, toggle, true)
   end
   if pgui:get_store(self.label, true) then
      local y = button.size.y
      local vstack = pgui:precomponent("vstack",
         {layer = self.layer + 1, pos = vec(0, y), margin = self.margin, gap = self.gap, contents = self.contents}, self)
      local upd = vstack:_update()
      if (self.grow) then self.size.y += vstack.size.y end
      return upd
   end
   return {}
end

pgui_components.scrollable = {fns = {}, data = {label = "scrll", _id = "scrollable", scroll_x = false, scroll_y = true, size = vec(50, 50), sensibility = 4, content = {"text_box", {text = "scrollable", margin = 50}}}}
pgui_components.scrollable.fns.update = function(self)
   if (pgui:get_store(self.label, true) == nil) then pgui:set_store(self.label, {scrolling = vec(0, 0)}, true) end
   local store = pgui:get_store(self.label, true)
   local com = pgui:precomponent(self.content[1], self.content[2], self)
   com.pos = store.scrolling
   com.clip = {self.pos.x + self.offset.x, self.pos.y + self.offset.y, self.size.x, self.size.y}
   local upd = com:_update()
   if (not self.scroll_x or (com.size.x < self.size.x)) then self.size.x = com.size.x end
   if (not self.scroll_y or (com.size.y < self.size.y)) then self.size.y = com.size.y end

   function limit(com, scroller)
      if com.size.y - scroller.size.y + com.pos.y <= 0 then
         com.pos.y = scroller.size.y - com.size.y
      elseif com.pos.y > 0 then
         com.pos.y = 0
      end
      if com.size.x - scroller.size.x + com.pos.x <= 0 then
         com.pos.x = scroller.size.x - com.size.x
      elseif com.pos.x > 0 then
         com.pos.x = 0
      end
   end

   local mouse_events = pgui:mouse_events(self)
   if mouse_events.over then
      if (self.scroll_y) then store.scrolling.y += mouse_events.vs * self.sensibility end
      if (self.scroll_x) then store.scrolling.x += mouse_events.hs * self.sensibility end
      limit(com, self)
   end
   return upd
end

pgui_components.hslider = {fns = {}, data = {_id = "hslider", format = function(v) return v end, min = 0, max = 100, value = 50, size = vec(100, 10), stroke = true, flr = false}}
pgui_components.hslider.fns.update = function(self)
   local box = pgui:precomponent("box", {size = self.size, stroke = self.stroke}, self)
   box:_update()
   local mouse_events = pgui:mouse_events(box)
   local range = self.max - self.min
   if mouse_events.left_btn then
      self.value = self.min + (mouse_events.rel_pos.x / self.size.x) * range
   end
   self.value = mid(self.min, self.value, self.max)
   local width = ((self.value - self.min) / range) * self.size.x
   if (self.flr) then self.value = flr(self.value) end
   local s = vec(width, self.size.y)
   local col = {self.color[3], 0, 0, self.color[4]}
   if (width > 0) then pgui:component("box", {size = s, stroke = self.stroke, color = col}, self) end
   local text_pos = vec(2, (self.size.y - 6) / 2)
   pgui:component("text", {text = self.format(self.value), pos = text_pos}, self)
   return self.value
end

pgui_components.radio = {fns = {}, data = {_id = "radio", gap = 3, r = 3, sep = 4, selected = 1, options = {}}}
pgui_components.radio.fns.update = function(self)
   local y = 0
   local i = 1
   local d = self.r * 2
   local tw = 0
   for opt in all(self.options) do
      if pgui.stats.memos.text_width[opt] == nil then
         pgui.stats.memos.text_width[opt] = pgui:get_text_width(opt)
      end
      local text_width  = pgui.stats.memos.text_width[opt]
      tw                = text_width > tw and text_width or tw
      local pos         = vec(0, y)
      local on          = self.selected == i
      local radiocircle = pgui:precomponent("radiocircle", {pos = pos, r = self.r, on = on}, self)
      radiocircle:_update()
      local text_pos = pos + vec(d + self.sep, (d - 6) / 2)
      pgui:component("text", {text = opt, pos = text_pos}, self)
      y += d + self.gap
      local clicked = pgui:mouse_events(radiocircle).clicked
      if (clicked) then self.selected = i end
      i += 1
   end
   self.size = vec(tw + self.sep + d, y - self.gap)
   return self.selected
end

pgui_components.multi_select = {fns = {}, data = {_id = "multi_select", gap = 3, box_size = 7, sep = 4, selected = {}, options = {}}}
pgui_components.multi_select.fns.update = function(self)
   if (#self.selected < #self.options) then
      notify("#options and #selected do not match in multi_select")
      return
   end
   local y = 0
   local i = 1
   local d = self.box_size
   local tw = 0
   local selected = pgui:copy_table(self.selected)
   for opt in all(self.options) do
      if pgui.stats.memos.text_width[opt] == nil then
         pgui.stats.memos.text_width[opt] = pgui:get_text_width(opt)
      end
      local text_width = pgui.stats.memos.text_width[opt]
      tw               = text_width > tw and text_width or tw
      local pos        = vec(0, y)
      local on         = selected[i]
      local multibox   = pgui:precomponent("multibox", {pos = pos, size = vec(d, d), on = on}, self)
      multibox:_update()
      local text_pos = pos + vec(d + self.sep, (d - 6) / 2)
      pgui:component("text", {text = opt, pos = text_pos}, self)
      y += d + self.gap
      local clicked = pgui:mouse_events(multibox).clicked
      if (clicked) then selected[i] = not selected[i] end
      i += 1
   end
   self.size = vec(tw + self.sep + d, y - self.gap)
   return selected
end

pgui_components.checkbox = {fns = {}, data = {_id = "checkbox", text = "CHECKBOX", value = false, box_size = 8, sep = 4}}
pgui_components.checkbox.fns.update = function(self)
   local select = pgui:precomponent("multi_select",
      {sep = self.sep, selected = {self.value}, options = {self.text}, box_size = self.box_size}, self)
   local upd = select:_update()
   self.size = select.size
   return upd[1]
end

pgui_components.palette = {fns = {}, data = {_id = "palette", columns = 4, gap = 3, box_size = 10, colors = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}, selected = 1}}
pgui_components.palette.fns.update = function(self)
   local i = 0
   local memo_code = self.columns.."_"..self.box_size.."_"..self.gap
   if pgui.stats.memos.palette_pos[memo_code] == nil then
      pgui.stats.memos.palette_pos[memo_code] = {}
   end
   local pos = pgui.stats.memos.palette_pos[memo_code]
   for col in all(self.colors) do
      local new_palette = pgui:copy_table(self.color)
      new_palette[1] = col
      new_palette[4] = self.selected == col and new_palette[3] or new_palette[4]

      if pos[i] == nil then
         pos[i] = vec((i % self.columns), flr(i / self.columns))
         pos[i] = pos[i] * (self.box_size + self.gap)
      end

      local box = pgui:precomponent("box",
         {pos = pos[i], size = vec(self.box_size, self.box_size), stroke = true, color = new_palette}, self)
      box:_update()
      if (pgui:mouse_events(box).clicked) then self.selected = col end
      i += 1
   end
   pgui.stats.memos.palette_pos[memo_code] = pos

   self.size = vec(
      ((self.box_size + self.gap) * self.columns) - self.gap,
      ((self.box_size + self.gap) * ceil(#self.colors / self.columns)) - self.gap
   )
   return self.selected
end

------ end of components -------

pgui_methods = {}

-- CYCLE METHODS
function pgui_methods:refresh()
   self.components = {}
   self.stats.t += 1
   self.stats.blink = flr(self.stats.t / 20 % 2) == 1
   self.stats.prev_mouse = self:copy_table(self.stats.mouse)
   self.stats.mouse = self:get_mouse()
end

function pgui_methods:draw(callback)
   callback = callback and callback or function() end
   self:sort_table(self.components, "layer")
   for component in all(self.components) do
      if self.components.layer == 4 then
         callback()
      end
      if self.stats.clipping and #component.clip == 4 then
         clip(component.clip[1], component.clip[2], component.clip[3], component.clip[4] + 1)
         component:draw()
         clip()
      else
         component:draw()
      end
   end
end

-- COMPONENT METHODS

function pgui_methods:component(name, opts, parent_opts)
   local template = pgui_components[name]
   if not template then
      notify("ERROR: pgui component '"..tostring(name).."' does not exist")
      local component = self:new_component(pgui_components["unknown"], {})
      return component:_update()
   else
      local component = self:new_component(template, opts, parent_opts)
      return component:_update()
   end
end

function pgui_methods:precomponent(name, opts, parent_opts)
   local template = pgui_components[name]
   return self:new_component(template, opts, parent_opts)
end

function pgui_methods:new_component(template, opts, parent_opts)
   local base_data = {pos = vec(0, 0), size = vec(0, 0), offset = vec(0, 0), color = pgui_methods:copy_table(self.stats
   .palette), clip = {}, layer = 0}
   local data = {}
   for k, v in pairs(base_data) do
      local value = v
      if parent_opts then
         if (k == "layer") then value = parent_opts.layer end
         if (k == "clip") then value = parent_opts.clip end
         if (k == "color") then value = parent_opts.color end
         if (k == "offset") then value = parent_opts.children_offset end
      end
      if (opts[k] != nil) then value = opts[k] end
      data[k] = value
   end
   for k, v in pairs(template.data) do
      local value = v
      if (opts[k] != nil) then value = opts[k] end
      data[k] = value
   end

   local fns = template.fns
   function fns:_update()
      if (self.draw) then addcomponent(self) end
      if (self.update) then
         self.children_offset = self.pos + self.offset
         local upd = self:update(self.children_offset)
         return upd == nil and self._id or upd
      else
         return self._id
      end
   end

   function addcomponent(component)
      add(self.components, component)
   end

   local component = setmetatable(data, {__index = template.fns})
   return component
end

-- UPDATE METHODS

function pgui_methods:close_dropdown(label)
   self:set_store(label, false, true)
end

function pgui_methods:get_mouse()
   local mx, my, mb, hs, vs = mouse()
   return {mx = mx, my = my, mb = mb, hs = hs, vs = vs}
end

function pgui_methods:get_text_width(str)
   local lines = split(str, "\n")

   function tw(text)
      local sum = 0
      local charlist = split(text, "")
      for ch in all(charlist) do
         if ch == "I" or ch == "i" or ch == "l" or ch == "1" then
            sum += 4
         elseif ch == "M" or ch == "T" or ch == "W" or ch == "m" or ch == "w" then
            sum += 6
         else
            sum += 5
         end
      end
      return sum
   end

   if (#lines == 1) then return tw(str) end

   local width = 0
   for text in all(lines) do
      local w = tw(text)
      width = width > w and width or w
   end

   return width
end

function pgui_methods:get_cursor_pos(margin, text, relx)
   local sum = margin
   local i = 0
   for ch in all(text) do
      local v = 0
      if ch == "I" or ch == "i" or ch == "l" or ch == "1" then
         v = 4
      elseif ch == "M" or ch == "T" or ch == "W" or ch == "m" or ch == "w" then
         v += 6
      else
         v += 5
      end
      if (sum + v > relx) then return {sum, i} end
      sum += v
      i += 1
   end
   return {sum, i}
end

function pgui_methods:get_scancodes()
   local scancodes = {
      "-", "=", "[", "]", "\\", ";",
      "'", ",", ".", "/", "`",
      "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
      "a", "b", "c", "d", "e", "f", "g", "h",
      "i", "j", "k", "l", "m", "n", "o", "p",
      "q", "r", "s", "t", "u", "v", "w", "x",
      "y", "z", "space", "enter"
   }
   return scancodes
end

function get_scancode_upper(index)
   local scancodesupper = {
      "_", "+", "{", "}", "|", ":",
      "\"", "<", ">", "?", "~",
      ")", "!", "@", "#", "$", "%", "^", "&", "*", "(",
      "A", "B", "C", "D", "E", "F", "G", "H",
      "I", "J", "K", "L", "M", "N", "O", "P",
      "Q", "R", "S", "T", "U", "V", "W", "X",
      "Y", "Z", "space", "enter"
   }
   return scancodesupper
   [index]                    -- Get index of scancodes, MAKE SURE SPECIAL CHARACTERS ARE IN THE SAME ORDER AS THEIR LOWERCASE VERSIONS
end

function pgui_methods:copy_table(table)
   local new_table = {}
   for k, v in pairs(table) do
      if type(v) == "table" then
         new_table[k] = self:copy_table(v)
      else
         new_table[k] = v
      end
   end
   return new_table
end

function pgui_methods:mouse_events(data)
   local mx = self.stats.mouse.mx
   local my = self.stats.mouse.my
   local mb = self.stats.mouse.mb
   local hs = self.stats.mouse.hs
   local vs = self.stats.mouse.vs
   local pmb = self.stats.prev_mouse.mb

   -- adjust response to clipping
   local colrect = data.pos + data.offset -- collision rectangle position
   local colsize = data.size:copy()   -- collision rectangle size

   if self.stats.clipping then
      if #data.clip == 4 then
         local cx = data.clip[1]
         local cw = data.clip[3]
         local cy = data.clip[2]
         local ch = data.clip[4]

         if colrect.x < cx then
            colsize.x = (colrect.x + colsize.x) - cx
            colrect.x = cx
         elseif colrect.x + data.size.x > cx + cw then
            colsize.x = colsize.x - ((colrect.x + colsize.x) - (cx + cw))
         end
         if colrect.y < cy then
            colsize.y = (colrect.y + colsize.y) - cy
            colrect.y = cy
         elseif colrect.y + data.size.y > cy + ch then
            colsize.y = colsize.y - ((colrect.y + colsize.y) - (cy + ch))
         end
      end
   end
   ---

   local collision = self:rect_collision(colrect, {x = mx, y = my}, colsize, {x = 1, y = 1})
   local lb = collision and mb == 1
   local rb = collision and mb == 2
   local clicked = pmb == 0 and lb
   local released = pmb == 1 and collision and mb == 0
   return {over = collision, left_btn = lb, right_btn = rb, clicked = clicked, released = released, rel_pos = vec(mx, my) -
   data.offset - data.pos, hs = hs, vs = vs}
end

function pgui_methods:rect_collision(apos, bpos, as, bs)
   -- check if two rectangles are colliding
   local colliding = true
   if (apos.x + as.x < bpos.x or
         apos.x > bpos.x + bs.x or
         apos.y + as.y < bpos.y or
         apos.y > bpos.y + bs.y) then
      colliding = false
   end
   return colliding
end

-- RENDER METHODS

function pgui_methods:set_palette(palette)
   if (#palette >= 4) then
      self.stats.palette = palette
   else
      notify("Palette must be a table with 4 indexes")
   end
end

function pgui_methods:activate_clipping()
   self.stats.clipping = true
end

function pgui_methods:_text(text, com, col)
   local x = com.pos.x + com.offset.x
   local y = com.pos.y + com.offset.y
   print(tostring(text), x, y, col)
end

function pgui_methods:_rect(x, y, w, h, c, f)
   palt(0, true)
   line(x + 1, y, x + w - 1, y, c)
   line(x, y + 1, x, y + h - 1, c)
   line(x + 1, y + h, x + w - 1, y + h, c)
   line(x + w, y + 1, x + w, y + h - 1, c)
   if f then
      rectfill(x + 1, y + 1, x + w - 1, y + h - 1)
   end
end

function pgui_methods:_box(com, w, h, fill, stroke)
   local x = com.pos.x + com.offset.x
   local y = com.pos.y + com.offset.y
   self:_rect(x, y, w, h, fill, true)
   self:_rect(x, y, w, h, stroke, false)
end

function pgui_methods:_radiocirc(com, r, fill, stroke, f)
   local x = com.pos.x + com.offset.x + r
   local y = com.pos.y + com.offset.y + r
   if (f) then circfill(x, y, r, fill) end
   circ(x, y, r, stroke)
end

function pgui_methods:_sprite(sprite, com)
   local x = com.pos.x + com.offset.x
   local y = com.pos.y + com.offset.y
   spr(sprite, x, y)
end

-- STORE METHODS

function pgui_methods:uid()
   local uid = split(date(), " ")
   uid = table.concat(split(uid[1], "-"), "")..table.concat(split(uid[2], ":"), "")..sub(tostring(rnd() * 1000), 0, 3)
   return uid
end

function pgui_methods:set_store(id, data, alt)
   if not alt then
      self.store[id] = data
   else
      self.alt_store[id] = data
   end
end

function pgui_methods:get_store(id, alt)
   if not alt then
      return self.store[id]
   else
      return self.alt_store[id]
   end
end

function pgui_methods:sort_table(tbl, key)
   local n = #tbl
   local sorted = false

   while not sorted do
      sorted = true
      for i = 1, n - 1 do
         if tbl[i][key] > tbl[i + 1][key] then
            tbl[i], tbl[i + 1] = tbl[i + 1], tbl[i]
            sorted = false
         end
      end
      n = n - 1
   end
end

pgui = setmetatable({
      components = {},
      store = {},
      alt_store = {},
      stats = {
         t = 0,
         blink = false,
         palette = {7, 18, 12, 0},
         clipping = false,
         memos = {text_width = {}, palette_pos = {}},
         scancodes = pgui_methods:get_scancodes(),
         mouse = pgui_methods:get_mouse(),
         prev_mouse = pgui_methods:get_mouse()
      }
   },
   {__index = pgui_methods}
)

return pgui

:: lib/qsort.lua
-- Picotron-compatible Quicksort Library
-- by @Felice from https://www.lexaloffle.com/bbs/?pid=50453
local function ascending(a, b) return a < b end

local function qsort(array, comparator, left, right)
    comparator, left, right = comparator or ascending, left or 1, right or #array
    if left < right then
        if comparator(array[right], array[left]) then
            array[left], array[right] = array[right], array[left]
        end
        local less_than, greater_than, current, pivot_low, pivot_high = left + 1, right - 1, left + 1, array[left],
           array[right]
        while current <= greater_than do
            if comparator(array[current], pivot_low) then
                array[current], array[less_than] = array[less_than], array[current]
                less_than += 1
            elseif not comparator(array[current], pivot_high) then
                while comparator(pivot_high, array[greater_than]) and current < greater_than do
                    greater_than -= 1
                end
                array[current], array[greater_than] = array[greater_than], array[current]
                greater_than -= 1
                if comparator(array[current], pivot_low) then
                    array[current], array[less_than] = array[less_than], array[current]
                    less_than += 1
                end
            end
            current += 1
        end
        less_than -= 1
        greater_than += 1
        array[left], array[less_than] = array[less_than], array[left]
        array[right], array[greater_than] = array[greater_than], array[right]
        qsort(array, comparator, left, less_than - 1)
        qsort(array, comparator, less_than + 1, greater_than - 1)
        qsort(array, comparator, greater_than + 1, right)
    end
end

return qsort

:: lib/require.lua
--[[
   Simple require - path-based module loading with caching
   Loads modules relative to cart root. Supports:
   - Direct files: require("lib/middleclass") -> lib/middleclass.lua
   - Directories:  require("scenes") -> scenes/init.lua
]]

local _LOADED = {}

function require(filename)
   -- Return cached module if already loaded
   if _LOADED[filename] then
      return _LOADED[filename]
   end

   -- Try direct file path first
   local path = filename:gsub("%.lua$", "")..".lua"
   local src = fetch(path)

   -- If not found, try as directory with init.lua
   if type(src) ~= "string" then
      local init_path = filename.."/init.lua"
      src = fetch(init_path)
      if type(src) == "string" then
         path = init_path
      end
   end

   -- Error if module not found
   if type(src) ~= "string" then
      local error_msg = "Module '"..filename.."' not found"
      printh(error_msg)
      error(error_msg)
   end

   -- Compile and execute module
   local func, err = load(src, "@"..path, "t", _ENV)
   if not func then
      local error_msg = "Error loading '"..filename.."': "..err
      printh(error_msg)
      error(error_msg)
   end

   -- Cache and return result
   _LOADED[filename] = func() or true
   return _LOADED[filename]
end

:: main.lua
--[[pod_format="raw",created="2025-12-18 09:37:41",modified="2026-01-04 08:23:43",revision=6]]
-- before release do:
--   cp -f /desktop/projects/[project_name]/src /ram/cart/src
--   cp -f /desktop/projects/[project_name]/lib /ram/cart/lib
-- and comment the next 3 lines before release
--local projects_dir = "/desktop/projects/"
--local project_name = "pizak"
--local full_path = projects_dir..project_name

CARTPATH = ""

if not fetch("src/main.lua") then
	cd(full_path)
	CARTPATH = project_name..".p64/"
end


include("src/main.lua")

:: src/ai.lua
return require("src/ai/init")

:: src/ai/enemies/dasher.lua
-- Dasher enemy AI profile
-- FSM: patrol -> windup -> dash -> stun -> puzzled -> patrol
-- Self-contained (doesn't use wander/chase primitives due to unique movement)

local machine = require("lib/lua-state-machine/statemachine")
local Emotions = require("src/systems/emotions")
local HitboxUtils = require("src/utils/hitbox_utils")
local Dash = require("src/ai/primitives/dash")

local PUZZLED_DURATION = 60 -- frames to stay puzzled before patrol

-- Cardinal directions for patrol: {dx, dy}
local CARDINAL_DIRS = {
   {0,  -1}, -- up
   {0,  1},  -- down
   {-1, 0},  -- left
   {1,  0},  -- right
}

-- Get orthogonal directions to current direction
local function get_orthogonal_directions(dx, dy)
   if dx == 0 then
      -- Currently moving vertically, return horizontal options
      return {{-1, 0}, {1, 0}}
   else
      -- Currently moving horizontally, return vertical options
      return {{0, -1}, {0, 1}}
   end
end

-- Initialize Dasher FSM on entity
local function init_fsm(entity)
   -- Pick initial random direction
   local initial_dir = CARDINAL_DIRS[flr(rnd(4)) + 1]
   entity.patrol_dir_x = initial_dir[1]
   entity.patrol_dir_y = initial_dir[2]

   entity.dasher_fsm = machine.create({
      initial = "patrol",
      events = {
         {name = "spot",    from = "patrol",  to = "windup"},  -- Player spotted, facing them
         {name = "charge",  from = "windup",  to = "dash"},    -- Windup complete
         {name = "collide", from = "dash",    to = "stun"},    -- Hit wall or player
         {name = "recover", from = "stun",    to = "puzzled"}, -- Stun timer finished
         {name = "wander",  from = "puzzled", to = "patrol"},  -- Puzzled timer finished
      },
      callbacks = {
         onenterwindup = function()
            Emotions.set(entity, "alert")
            entity.dasher_timer = entity.windup_duration
            entity.vel_x = 0
            entity.vel_y = 0
            if entity.fsm and entity.fsm:can("attack") then
               entity.fsm:attack()
            end
         end,
         onenterdash = function()
            entity.rotation_timer = 0
            entity.rotation_angle = 0
         end,
         onenterstun = function()
            Emotions.set(entity, "stunned")
            entity.dasher_timer = entity.stun_duration
            entity.vel_x = 0
            entity.vel_y = 0
            entity.dasher_collision = nil
            entity.rotation_angle = 0
         end,
         onenterpuzzled = function()
            Emotions.set(entity, "confused")
            entity.puzzled_timer = PUZZLED_DURATION
            entity.vel_x = 0
            entity.vel_y = 0
         end,
         onenterpatrol = function(self, event)
            if entity.fsm and entity.fsm:is("attacking") and entity.fsm:can("finish") then
               entity.fsm:finish()
            end

            local dir = CARDINAL_DIRS[flr(rnd(4)) + 1]
            entity.patrol_dir_x = dir[1]
            entity.patrol_dir_y = dir[2]
            entity.rotation_angle = 0
         end,
      }
   })
end

--- Main AI update for Dasher enemy type
--- @param entity The dasher entity
--- @param player The player entity (target)
local function dasher_ai(entity, player)
   -- Initialize FSM if needed
   if not entity.dasher_fsm then
      init_fsm(entity)
   end

   local fsm = entity.dasher_fsm

   -- Calculate distance to player (treat nil player as infinitely far)
   local in_range = false
   local dx, dy, dist = 0, 0, math.huge
   if player then
      local hb_p = HitboxUtils.get_hitbox(player)
      local hb_e = HitboxUtils.get_hitbox(entity)
      dx = (hb_p.x + hb_p.w / 2) - (hb_e.x + hb_e.w / 2)
      dy = (hb_p.y + hb_p.h / 2) - (hb_e.y + hb_e.h / 2)
      dist = sqrt(dx * dx + dy * dy)
      in_range = dist <= entity.vision_range
   end

   -- State-specific behavior
   if fsm:is("patrol") then
      -- Check if blocked by wall last frame
      if entity.hit_wall then
         -- Pick a random orthogonal direction
         local ortho = get_orthogonal_directions(entity.patrol_dir_x, entity.patrol_dir_y)
         local choice = ortho[flr(rnd(2)) + 1]
         entity.patrol_dir_x = choice[1]
         entity.patrol_dir_y = choice[2]
         entity.hit_wall = false -- Clear flag
      end

      -- Move in patrol direction
      entity.vel_x = entity.patrol_dir_x * entity.max_speed
      entity.vel_y = entity.patrol_dir_y * entity.max_speed
      entity.dir_x = entity.patrol_dir_x ~= 0 and entity.patrol_dir_x or entity.dir_x
      entity.dir_y = entity.patrol_dir_y ~= 0 and entity.patrol_dir_y or entity.dir_y

      -- Transition: player in range
      if in_range then
         -- Cache the dash direction (normalized toward player)
         if dist > 0 then
            entity.dash_target_dx = dx / dist
            entity.dash_target_dy = dy / dist
         end
         fsm:spot()
      end
   elseif fsm:is("windup") then
      -- Track player during windup so dash is accurate
      Dash.windup(entity, dx, dy, dist, false)

      entity.dasher_timer = entity.dasher_timer - 1
      if entity.dasher_timer <= 0 then
         fsm:charge()
      end
   elseif fsm:is("dash") then
      -- Move at 4x speed in cached direction
      local hit_wall = Dash.update(entity)

      -- Rotate sprite
      entity.rotation_timer = (entity.rotation_timer or 0) + 1
      if entity.rotation_timer >= 8 then
         entity.rotation_timer = 0
         -- Rotate 90 degrees every 8 frames (always clockwise internally, flip_x handles visual direction)
         entity.rotation_angle = (entity.rotation_angle or 0) + 90
      end

      -- Transition: collision with wall (hit_wall) or player (dasher_collision)
      if entity.dasher_collision or hit_wall then
         fsm:collide()
      end
   elseif fsm:is("stun") then
      -- Stay idle (already set by callback)
      entity.vel_x = 0
      entity.vel_y = 0

      entity.dasher_timer = entity.dasher_timer - 1
      if entity.dasher_timer <= 0 then
         fsm:recover()
      end
   elseif fsm:is("puzzled") then
      -- Stand still, wait for timer (grace period - cannot spot during this time)
      entity.vel_x = 0
      entity.vel_y = 0

      entity.puzzled_timer = entity.puzzled_timer - 1
      if entity.puzzled_timer <= 0 then
         fsm:wander()
      end
   end
end

return dasher_ai

:: src/ai/enemies/shooter.lua
-- Shooter enemy AI profile
-- FSM: wandering <-> engaging <-> puzzled
-- Uses: wander primitive, chase primitive (maintain_distance)

local machine = require("lib/lua-state-machine/statemachine")
local Wander = require("src/ai/primitives/wander")
local Chase = require("src/ai/primitives/chase")
local Emotions = require("src/systems/emotions")
local HitboxUtils = require("src/utils/hitbox_utils")

local SHOOTER_VISION_RANGE = 200
local SHOOTER_TARGET_DIST = 100
local SHOOTER_TARGET_DIST_VARIANCE = 20
local PUZZLED_DURATION = 60 -- frames to stay puzzled before wandering

-- Initialize Shooter FSM on entity
local function init_fsm(entity)
   entity.shooter_fsm = machine.create({
      initial = "wandering",
      events = {
         {name = "spot",   from = "wandering", to = "engaging"},
         {name = "lose",   from = "engaging",  to = "puzzled"},
         {name = "wander", from = "puzzled",   to = "wandering"},
      },
      callbacks = {
         onenterengaging = function()
            Emotions.set(entity, "alert")
            Wander.reset(entity)
         end,
         onenterpuzzled = function()
            Emotions.set(entity, "confused")
            entity.puzzled_timer = PUZZLED_DURATION
            entity.vel_x = 0
            entity.vel_y = 0
         end,
         onenterwandering = function()
            -- No emotion on entering wandering, puzzled already showed "?"
         end,
      }
   })
end

--- Main AI update for Shooter enemy type
-- @param entity The shooter entity
-- @param player The player entity (target)
local function shooter_ai(entity, player)
   -- Initialize FSM if needed
   if not entity.shooter_fsm then
      init_fsm(entity)
   end

   local fsm = entity.shooter_fsm
   local vision_range = entity.vision_range or SHOOTER_VISION_RANGE

   -- Calculate distance to player (treat nil player as infinitely far)
   local dist = math.huge
   local dx, dy = 0, 0
   if player then
      -- Calculate centers using hitbox (more accurate for targeting)
      local my_hb = HitboxUtils.get_hitbox(entity)
      local my_cx = my_hb.x + my_hb.w / 2
      local my_cy = my_hb.y + my_hb.h / 2

      local target_hb = HitboxUtils.get_hitbox(player)
      local target_cx = target_hb.x + target_hb.w / 2
      local target_cy = target_hb.y + target_hb.h / 2

      -- Account for z-axis (aim at visual height)
      if player.z then target_cy = target_cy - player.z end
      if entity.z then my_cy = my_cy - entity.z end

      dx = target_cx - my_cx
      dy = target_cy - my_cy
      dist = sqrt(dx * dx + dy * dy)
   end

   if fsm:is("wandering") then
      if dist <= vision_range then
         fsm:spot()
      else
         Wander.update(entity)
      end
   elseif fsm:is("engaging") then
      if dist > vision_range then
         fsm:lose()
      elseif player then
         -- Maintain ideal distance using chase primitive
         Chase.maintain_distance(entity, player.x, player.y, SHOOTER_TARGET_DIST, SHOOTER_TARGET_DIST_VARIANCE)

         -- Set shooting direction (actual spawning handled by Shooter system)
         if dist > 0 then
            entity.shoot_dir_x = dx / dist
            entity.shoot_dir_y = dy / dist
         else
            entity.shoot_dir_x = 0
            entity.shoot_dir_y = 0
         end
      end
   elseif fsm:is("puzzled") then
      -- Stand still, wait for timer (grace period - cannot spot during this time)
      entity.vel_x = 0
      entity.vel_y = 0
      entity.shoot_dir_x = 0
      entity.shoot_dir_y = 0

      entity.puzzled_timer = entity.puzzled_timer - 1
      if entity.puzzled_timer <= 0 then
         fsm:wander()
      end
   end
end

return shooter_ai

:: src/ai/enemies/skulker.lua
-- Skulker enemy AI profile
-- FSM: wandering <-> chasing <-> puzzled
-- Uses: wander primitive, chase primitive

local machine = require("lib/lua-state-machine/statemachine")
local Wander = require("src/ai/primitives/wander")
local Chase = require("src/ai/primitives/chase")
local Emotions = require("src/systems/emotions")
local HitboxUtils = require("src/utils/hitbox_utils")

local PUZZLED_DURATION = 60 -- frames to stay puzzled before wandering

-- Initialize Skulker FSM on entity
local function init_fsm(entity)
   entity.skulker_fsm = machine.create({
      initial = "wandering",
      events = {
         {name = "spot",   from = "wandering", to = "chasing"},
         {name = "lose",   from = "chasing",   to = "puzzled"},
         {name = "wander", from = "puzzled",   to = "wandering"},
      },
      callbacks = {
         onenterchasing = function()
            Emotions.set(entity, "alert")
            Wander.reset(entity)
         end,
         onenterpuzzled = function()
            Emotions.set(entity, "confused")
            entity.puzzled_timer = PUZZLED_DURATION
            entity.vel_x = 0
            entity.vel_y = 0
         end,
         onenterwandering = function()
            -- No emotion on entering wandering, puzzled already showed "?"
         end,
      }
   })
end

--- Main AI update for Skulker enemy type
--- @param entity The skulker entity
--- @param player The player entity (target)
local function skulker_ai(entity, player)
   -- Initialize FSM if needed
   if not entity.skulker_fsm then
      init_fsm(entity)
   end

   local fsm = entity.skulker_fsm
   local vision_range = entity.vision_range

   -- Calculate distance to player (treat nil player as infinitely far)
   local in_range = false
   if player then
      local dx = player.x - entity.x
      local dy = player.y - entity.y
      local dist = sqrt(dx * dx + dy * dy)
      -- If no vision_range defined, always chase (original behavior)
      in_range = not vision_range or dist <= vision_range
   end

   if fsm:is("wandering") then
      if in_range then
         fsm:spot()
      else
         Wander.update(entity)
      end
   elseif fsm:is("chasing") then
      if not in_range then
         fsm:lose()
         -- ... (inside skulker_ai)
      elseif player then
         local hb = HitboxUtils.get_hitbox(player)
         local tx = hb.x + hb.w / 2
         local ty = hb.y + hb.h / 2
         Chase.toward(entity, tx, ty)
      end
   elseif fsm:is("puzzled") then
      -- Stand still, wait for timer (grace period - cannot spot during this time)
      entity.vel_x = 0
      entity.vel_y = 0

      entity.puzzled_timer = entity.puzzled_timer - 1
      if entity.puzzled_timer <= 0 then
         fsm:wander()
      end
   end
end

return skulker_ai

:: src/ai/init.lua
-- AI module aggregator
-- Exposes primitives for composition and enemy-type dispatch

-- Primitives (reusable building blocks)
local Wander = require("src/ai/primitives/wander")
local Chase = require("src/ai/primitives/chase")

-- Enemy AI profiles (per-enemy-type controllers)
local skulker_ai = require("src/ai/enemies/skulker")
local skull_ai = require("src/ai/enemies/skull")
local shooter_ai = require("src/ai/enemies/shooter")
local dasher_ai = require("src/ai/enemies/dasher")
local boss_ai = require("src/ai/enemies/boss")

-- Minion AI profiles
local ChickAI = require("src/ai/minions/chick")
local egg_ai = require("src/ai/minions/egg")

local AI = {}

-- Expose primitives for external use (testing, custom compositions)
AI.primitives = {
   wander = Wander,
   chase = Chase,
}

-- Enemy AI lookup table (maps enemy_type to AI function)
local enemy_profiles = {
   Skulker = skulker_ai,
   Skull = skull_ai,
   Shooter = shooter_ai,
   Dasher = dasher_ai,
   GreenWitch = boss_ai,
}

-- Minion AI lookup table (maps minion_type to AI function)
local minion_profiles = {
   Chick = ChickAI.update, -- ChickAI is a module with update + target painting
   Egg = egg_ai,
}

-- Expose ChickAI for target painting access
AI.ChickAI = ChickAI

--- Dispatch AI update to the appropriate enemy profile
-- @param entity The entity to process
-- @param player The player entity (target)
function AI.dispatch(entity, player)
   local profile = enemy_profiles[entity.enemy_type]
   if profile then
      profile(entity, player)
   end
end

--- Dispatch AI update for minions
-- @param entity The minion entity to process
-- @param world The ECS world (for spawning entities)
function AI.dispatch_minion(entity, world)
   local profile = minion_profiles[entity.minion_type]
   if profile then
      profile(entity, world)
   end
end

return AI

:: src/ai/minions/chick.lua
-- Chick AI behavior
-- FSM: wandering <-> seeking_food <-> chasing <-> attacking
-- Priority: hungry > enemy in range > wander
-- Uses A* pathfinding for navigation

local machine = require("lib/lua-state-machine/statemachine")
local Wander = require("src/ai/primitives/wander")
local Chase = require("src/ai/primitives/chase")
local PathFollow = require("src/ai/primitives/path_follow")
local SeekFood = require("src/ai/primitives/seek_food")
local FloatingText = require("src/systems/floating_text")
local Emotions = require("src/systems/emotions")
local HitboxUtils = require("src/utils/hitbox_utils")
local DungeonManager = require("src/world/dungeon_manager")

-- Configuration: How long to try reaching an unreachable target before giving up
local MAX_CHASE_STUCK_FRAMES = 60      -- ~1 second at 60fps
local UNREACHABLE_BLACKLIST_TIME = 5.0 -- Seconds to blacklist an unreachable enemy

-- Target painting: enemy hit by player becomes priority target for all chicks
local painted_target = nil

--- Check if any food (yolk splats) exists within range
--- Used to decide if chick should abandon combat to seek food
--- @param entity table - The chick
--- @param world table - ECS world
--- @return boolean - True if food is nearby
local function food_exists_nearby(entity, world, range)
   range = range or 100
   local range_sq = range * range
   local ex, ey = entity.x, entity.y
   local found = false

   world.sys("yolk_splat", function(food)
      if found then return end -- Early exit
      local dx = food.x - ex
      local dy = food.y - ey
      local dist_sq = dx * dx + dy * dy
      if dist_sq < range_sq then
         found = true
      end
   end)()

   return found
end

local function init_fsm(entity)
   entity.chick_fsm = machine.create({
      initial = "wandering",
      events = {
         {
            name = "get_hungry",
            from = {"wandering", "chasing", "attacking", "following"},
            to = "seeking_food"
         },
         {
            name = "spot_enemy",
            from = {"wandering", "seeking_food", "following"},
            to = "chasing"
         },
         {
            name = "reach_enemy",
            from = "chasing",
            to = "attacking"
         },
         {
            name = "lose_target",
            from = {"chasing", "attacking"},
            to = "wandering"
         },
         {
            name = "back_off",
            from = "attacking",
            to = "chasing"
         },
         {
            name = "eat_done",
            from = "seeking_food",
            to = "wandering"
         },
         {
            name = "start_following",
            from = "wandering",
            to = "following"
         },
         {
            name = "stop_following",
            from = "following",
            to = "wandering"
         },
         {
            name = "die",
            from = "*",
            to = "death"
         },
      },
      callbacks = {
         onwandering = function(self, event, from, to) Emotions.set(entity, "idle") end,
         onseeking_food = function(self, event, from, to) Emotions.set(entity, "seeking_food") end,
         onchasing = function(self, event, from, to) Emotions.set(entity, "chasing") end,
         onfollowing = function(self, event, from, to) Emotions.set(entity, "following") end,
         onenterdeath = function(self, event, from, to)
            Emotions.set(entity, "seeking_food")
            entity.vel_x = 0
            entity.vel_y = 0
            entity.acc_x = 0
            entity.acc_y = 0
            entity.anim_timer = 0
         end
      }
   })
   entity.fsm = entity.chick_fsm
end

--- Find nearest enemy within vision range (current room only)
--- OPTIMIZED: Uses squared distances, takes pre-fetched room bounds
--- Skips enemies that are temporarily blacklisted as unreachable
--- @param entity table - The chick
--- @param world table - ECS world
--- @param room_bounds table|nil - Pre-fetched room bounds
--- @param player table|nil - Player (for vision bonus)
--- @return table|nil, number - Nearest enemy and distance squared (or nil if none)
local function find_nearest_enemy(entity, world, room_bounds, player)
   -- Apply player's vision bonus if available
   local vision_range = entity.vision_range + ((player and player.minion_vision_bonus) or 0)
   local vision_range_sq = vision_range * vision_range
   local nearest_enemy = nil
   local nearest_dist_sq = vision_range_sq

   local ex, ey = entity.x, entity.y

   -- Initialize blacklist if needed
   entity.unreachable_blacklist = entity.unreachable_blacklist or {}

   -- Clean up expired blacklist entries
   local now = t()
   for enemy, expire_time in pairs(entity.unreachable_blacklist) do
      if expire_time < now then
         entity.unreachable_blacklist[enemy] = nil
      end
   end

   -- Target painting: If painted target exists and is alive, prioritize it
   if painted_target and painted_target.hp and painted_target.hp > 0 then
      -- Don't skip painted target even if blacklisted (player specifically marked it)
      local dx = painted_target.x - ex
      local dy = painted_target.y - ey
      local dist_sq = dx * dx + dy * dy
      -- Always target painted enemy if within extended vision (2x range)
      if dist_sq < vision_range_sq * 4 then
         return painted_target, dist_sq
      end
   else
      -- Clear stale painted target
      painted_target = nil
   end

   world.sys("enemy", function(enemy)
      -- Skip blacklisted enemies (temporarily unreachable)
      if entity.unreachable_blacklist[enemy] then
         return
      end

      -- Skip if enemy is outside current room bounds (padded by 1 tile to include walls)
      if room_bounds then
         local etx = flr(enemy.x / 16)
         local ety = flr(enemy.y / 16)
         -- Fix: Widen bounds by 1 to include enemies overlapping walls (e.g. Dashers)
         if etx < room_bounds.x1 - 1 or etx > room_bounds.x2 + 1 or
            ety < room_bounds.y1 - 1 or ety > room_bounds.y2 + 1 then
            return -- Skip enemies outside room
         end
      end

      local dx = enemy.x - ex
      local dy = enemy.y - ey
      local dist_sq = dx * dx + dy * dy
      if dist_sq < nearest_dist_sq then
         nearest_dist_sq = dist_sq
         nearest_enemy = enemy
      end
   end)()

   return nearest_enemy, nearest_dist_sq
end

--- Apply attack to target enemy
--- @param entity table - The chick
--- @param target table - The enemy being attacked
--- @param player table|nil - The player (for bonus damage)
local function attack_enemy(entity, target, player)
   -- Check attack cooldown
   if entity.attack_timer and entity.attack_timer > 0 then
      return false -- Still on cooldown
   end

   -- Deal damage (base + player bonus)
   local damage = entity.attack_damage
   if player and player.minion_damage_bonus then
      damage = damage + player.minion_damage_bonus
   end
   target.hp = target.hp - damage
   target.invuln_timer = 5 -- Brief invuln
   FloatingText.spawn_at_entity(target, -damage, "damage")

   -- Subtle flash effect on hit
   target.flash_timer = 2
   target.flash_color = 7 -- White

   -- Knockback the chick away from enemy (recoil)
   local dx = entity.x - target.x
   local dy = entity.y - target.y
   local len_sq = dx * dx + dy * dy
   if len_sq > 0 then
      local len = sqrt(len_sq)
      dx = dx / len
      dy = dy / len
   else
      dx, dy = 0, -1
   end

   local knockback = entity.attack_knockback
   entity.knockback_vel_x = dx * knockback
   entity.knockback_vel_y = dy * knockback

   -- Reset attack cooldown (apply player's reduction bonus if available)
   local base_cooldown = entity.attack_cooldown
   local reduction = (player and player.minion_cooldown_reduction) or 0
   entity.attack_timer = math.max(5, base_cooldown - reduction)

   return true
end

--- Main AI update for Chick minion
--- OPTIMIZED: Caches queries, uses squared distances, reduces redundant calculations
--- @param entity table - The chick entity
--- @param world table - ECS world
local function chick_ai(entity, world)
   -- Initialize FSM if needed
   if not entity.chick_fsm then
      init_fsm(entity)
   end

   -- Decrement attack timer
   if entity.attack_timer and entity.attack_timer > 0 then
      entity.attack_timer = entity.attack_timer - 1
   end

   -- Check for death
   if entity.hp and entity.hp <= 0 then
      if entity.chick_fsm and not entity.chick_fsm:is("death") then
         entity.chick_fsm:die()
      end
   end

   -- Abort updates if dead
   if entity.chick_fsm and entity.chick_fsm:is("death") then
      return
   end

   -- OPTIMIZATION: Cache player reference early (needed for Face-Hugger and bonuses)
   local player = nil
   world.sys("player", function(p) player = p end)()

   -- One-time bonus application: Add minion HP bonus when first spawned
   if not entity.bonuses_applied and player then
      local hp_bonus = player.minion_hp_bonus or 0
      if hp_bonus > 0 then
         entity.max_hp = (entity.max_hp or 20) + hp_bonus
         entity.hp = (entity.hp or entity.max_hp) + hp_bonus
      end
      entity.bonuses_applied = true
   end

   -- Face-Hugger attachment: Skip normal AI while attached to enemy
   if entity.attachment_target then
      local target = entity.attachment_target

      -- Check if target is still valid (exists and alive)
      if target.hp and target.hp > 0 then
         -- Follow target position (stick to enemy)
         entity.x = target.x
         entity.y = target.y

         -- Attack while attached (guaranteed hits, no range check needed)
         if (entity.attack_timer or 0) <= 0 then
            attack_enemy(entity, target, player)
         end

         -- Decrement attachment timer
         entity.attachment_timer = (entity.attachment_timer or 0) - 1

         -- Detach when timer expires
         if entity.attachment_timer <= 0 then
            entity.attachment_target = nil
            -- Initialize FSM to wandering state after detaching
            if entity.chick_fsm then
               Emotions.set(entity, "idle")
            end
         end
      else
         -- Target died, detach immediately
         entity.attachment_target = nil
      end

      return -- Skip rest of AI while attached
   end

   local fsm = entity.chick_fsm

   -- OPTIMIZATION: Cache room and bounds once per frame
   local room = DungeonManager.current_room
   local room_bounds = room and room:get_inner_bounds()


   -- OPTIMIZATION: Cache player hitbox center if player exists (reused multiple times)
   local player_cx, player_cy
   if player then
      local phb = HitboxUtils.get_hitbox(player)
      player_cx = phb.x + phb.w / 2
      player_cy = phb.y + phb.h / 2
   end

   -- Gather perception data
   local is_hungry = entity.hp < (entity.max_hp or 20) / 2
   local nearest_enemy, enemy_dist_sq = find_nearest_enemy(entity, world, room_bounds, player)
   local has_target = nearest_enemy ~= nil

   -- OPTIMIZATION: Use squared distances for range comparisons
   -- For attack range: distance from chick center to EDGE of target hitbox (not center)
   local attack_range_sq = entity.attack_range * entity.attack_range
   local in_attack_range = false
   if has_target then
      -- Get chick center and target hitbox
      local chk_hb = HitboxUtils.get_hitbox(entity)
      local chk_cx, chk_cy = chk_hb.x + chk_hb.w / 2, chk_hb.y + chk_hb.h / 2
      local tgt_hb = HitboxUtils.get_hitbox(nearest_enemy)

      -- Calculate distance to nearest edge of target hitbox
      local closest_x = max(tgt_hb.x, min(chk_cx, tgt_hb.x + tgt_hb.w))
      local closest_y = max(tgt_hb.y, min(chk_cy, tgt_hb.y + tgt_hb.h))
      local edge_dx, edge_dy = chk_cx - closest_x, chk_cy - closest_y
      local edge_dist_sq = edge_dx * edge_dx + edge_dy * edge_dy

      in_attack_range = edge_dist_sq < attack_range_sq
   end

   -- State transitions based on priority: hungry > attack > chase > follow > wander
   -- Track previous target to detect target changes
   local prev_target = entity.chase_target

   if fsm:is("wandering") then
      if is_hungry then
         fsm:get_hungry()
      elseif has_target then
         fsm:spot_enemy()
         entity.chase_target = nearest_enemy
      elseif player then
         -- Check if we should start following player
         local dx = player.x - entity.x
         local dy = player.y - entity.y
         local dist_sq = dx * dx + dy * dy
         local trigger_dist = entity.follow_trigger_dist or 100
         local trigger_dist_sq = trigger_dist * trigger_dist

         if dist_sq > trigger_dist_sq then
            -- Too far, start following
            Wander.reset(entity)
            fsm:start_following()
         end
      end
   elseif fsm:is("following") then
      -- Priority checks (override following)
      if is_hungry then
         fsm:get_hungry()
      elseif has_target then
         -- Switching from player to enemy target
         PathFollow.clear_path(entity)
         fsm:spot_enemy()
         entity.chase_target = nearest_enemy
      elseif player then
         -- Check if we should stop following
         local dx = player.x - entity.x
         local dy = player.y - entity.y
         local dist_sq = dx * dx + dy * dy
         local stop_dist = entity.follow_stop_dist or 50
         local stop_dist_sq = stop_dist * stop_dist

         if dist_sq < stop_dist_sq then
            -- Close enough, resume wandering
            PathFollow.clear_path(entity)
            fsm:stop_following()
         end
      else
         -- Player lost/dead? Wander
         PathFollow.clear_path(entity)
         fsm:stop_following()
      end
   elseif fsm:is("seeking_food") then
      -- OPTIMIZATION: Only update emotion if not already set (debounce)
      if not entity.emotion and rnd(1) < 0.02 then
         Emotions.set(entity, "seeking_food")
      end
   elseif fsm:is("chasing") then
      -- If hungry AND food exists, prioritize food
      -- (Don't abandon combat for non-existent food - that causes the bug where chicks
      -- lose their target at 50% HP and never reacquire it)
      if is_hungry and food_exists_nearby(entity, world, entity.food_seek_range) then
         PathFollow.clear_path(entity)
         fsm:get_hungry()
         entity.chase_target = nil
         -- Lost target? Go back to wandering
      elseif not has_target then
         PathFollow.clear_path(entity)
         fsm:lose_target()
         entity.chase_target = nil
         -- Close enough to attack?
      elseif in_attack_range then
         fsm:reach_enemy()
         entity.chase_target = nearest_enemy
      else
         -- Update chase target to nearest enemy
         entity.chase_target = nearest_enemy
      end
   elseif fsm:is("attacking") then
      -- If hungry AND food exists, prioritize food
      -- (Don't abandon attack for non-existent food)
      if is_hungry and food_exists_nearby(entity, world, entity.food_seek_range) then
         fsm:get_hungry()
         entity.chase_target = nil
         -- Lost target?
      elseif not has_target then
         fsm:lose_target()
         entity.chase_target = nil
         -- Target moved out of range? Chase again
      elseif not in_attack_range then
         fsm:back_off()
         entity.chase_target = nearest_enemy
      else
         entity.chase_target = nearest_enemy
      end
   end

   -- Clear path if target entity changed (prevents following stale path to old target)
   if entity.chase_target ~= prev_target and prev_target ~= nil then
      PathFollow.clear_path(entity)
   end

   -- Execute behavior based on current state
   if fsm:is("seeking_food") then
      local range = entity.food_seek_range
      local heal = entity.food_heal_amount
      local found_food = SeekFood.update(entity, world, range, heal)

      -- If no food found and not hungry anymore, go back to wandering
      if not found_food and not is_hungry then
         fsm:eat_done()
      elseif not found_food then
         -- No food found. If we have an enemy, fight them instead of wandering aimlessly.
         if has_target then
            fsm:spot_enemy()
            entity.chase_target = nearest_enemy
         elseif player and player_cx then
            local dx = player.x - entity.x
            local dy = player.y - entity.y
            local dist_sq = dx * dx + dy * dy
            local trigger_dist = entity.follow_trigger_dist or 100
            local stop_dist = entity.follow_stop_dist or 50
            local trigger_dist_sq = trigger_dist * trigger_dist
            local stop_dist_sq = stop_dist * stop_dist

            -- Hysteresis logic
            if dist_sq > trigger_dist_sq then
               entity.seeking_follow_active = true
            elseif dist_sq < stop_dist_sq then
               entity.seeking_follow_active = false
            end

            if entity.seeking_follow_active then
               -- Too far, run towards player (hoping they lead to food)
               -- We stay in 'seeking_food' state but mimic chase behavior
               local speed_mult = entity.follow_speed_mult or 1.1
               Chase.toward(entity, player_cx, player_cy, speed_mult)
               -- OPTIMIZATION: Only set emotion if different
               if entity.emotion ~= "seeking_food" then
                  Emotions.set(entity, "seeking_food")
               end
            else
               -- Close enough, just wander
               Wander.update(entity)
               if entity.emotion ~= "seeking_food" then
                  Emotions.set(entity, "seeking_food")
               end
            end
         else
            -- No player, just wander
            Wander.update(entity)
            if entity.emotion ~= "seeking_food" then
               Emotions.set(entity, "seeking_food")
            end
         end
      end
   elseif fsm:is("chasing") then
      local target = entity.chase_target
      if target then
         local thb = HitboxUtils.get_hitbox(target)
         local tx, ty = thb.x + thb.w / 2, thb.y + thb.h / 2

         -- Get entity center for distance/LOS checks
         local hb = HitboxUtils.get_hitbox(entity)
         local ex, ey = hb.x + hb.w / 2, hb.y + hb.h / 2
         local chase_dx, chase_dy = tx - ex, ty - ey
         local chase_dist = sqrt(chase_dx * chase_dx + chase_dy * chase_dy)

         -- For close targets with clear line-of-sight, use direct chase (no pathfinding overhead)
         -- This also fixes the "no path" freeze when target is very close
         local DIRECT_CHASE_DIST = 48
         local has_los = PathFollow.has_line_of_sight(ex, ey, tx, ty, room)

         if chase_dist < DIRECT_CHASE_DIST and has_los then
            -- Close enough with clear path - use direct Chase
            Chase.toward(entity, tx, ty, entity.chase_speed_mult)
            entity.chase_stuck_frames = 0
         else
            -- Far away or blocked - use A* pathfinding
            PathFollow.toward(entity, tx, ty, entity.chase_speed_mult, room)

            -- Stuck detection: if no valid path for too long, abandon this target
            local has_path = PathFollow.has_path(entity)
            if not has_path then
               entity.chase_stuck_frames = (entity.chase_stuck_frames or 0) + 1
               -- Can't reach enemy - try to return to player instead of wandering
               if player and player_cx then
                  PathFollow.toward(entity, player_cx, player_cy, entity.chase_speed_mult, room)
               else
                  Wander.update(entity)
               end
               if entity.chase_stuck_frames >= MAX_CHASE_STUCK_FRAMES then
                  -- Can't reach target, give up and return to player
                  -- Clear blacklist so chick can retarget from new position
                  entity.unreachable_blacklist = {}
                  PathFollow.clear_path(entity)
                  fsm:lose_target()
                  entity.chase_target = nil
                  entity.chase_stuck_frames = 0
               end
            else
               entity.chase_stuck_frames = 0 -- Reset counter when path exists
            end
         end
      else
         PathFollow.clear_path(entity)
         Wander.update(entity)
      end
   elseif fsm:is("following") then
      if player and player_cx then
         local speed_mult = entity.follow_speed_mult or 1.1
         PathFollow.toward(entity, player_cx, player_cy, speed_mult, room)
      else
         PathFollow.clear_path(entity)
         Wander.update(entity)
      end
   elseif fsm:is("attacking") then
      local target = entity.chase_target
      if target then
         -- Attack the target
         attack_enemy(entity, target, player)
         -- Stop moving while attacking (knockback will push us back)
         entity.vel_x = 0
         entity.vel_y = 0
      else
         Wander.update(entity)
      end
   else -- wandering (default)
      Wander.update(entity)
   end
end

-- Track active chicks for blacklist clearing (set during update)
local active_chicks = {}

-- Module exports (AI function + target painting utilities)
return {
   update = function(entity, world)
      -- Track this chick for blacklist clearing
      active_chicks[entity] = true
      return chick_ai(entity, world)
   end,
   -- Paint a target for all chicks to prioritize
   -- Also clears the enemy from all chick blacklists so they retry reaching it
   paint_target = function(enemy)
      -- Clear outline from previous target
      if painted_target and painted_target ~= enemy then
         painted_target.outline_color = nil
      end
      painted_target = enemy
      -- Add orange outline to show painted status
      if enemy then
         enemy.outline_color = 9 -- Orange/yolk color
         -- Clear this enemy from all chick blacklists
         for chick, _ in pairs(active_chicks) do
            if chick.unreachable_blacklist then
               chick.unreachable_blacklist[enemy] = nil
            end
         end
      end
   end,
   -- Clear the painted target (called on room transition or target death)
   clear_target = function()
      if painted_target then
         painted_target.outline_color = nil
      end
      painted_target = nil
   end,
   -- Get current painted target (for debugging)
   get_painted_target = function()
      return painted_target
   end,
   -- Clear active chicks tracking (call on room transition)
   clear_active_chicks = function()
      active_chicks = {}
   end,
}

:: src/ai/minions/egg.lua
-- Egg AI behavior (hatching into a chick)
local Entities = require("src/entities")
local GameConstants = require("src/game/game_config")

return function(entity, world)
   -- Apply gravity while falling (z > 0)
   if entity.z and entity.z > 0 then
      entity.vel_z = (entity.vel_z or 0) + (entity.gravity_z or -0.15)
      entity.z = entity.z + entity.vel_z
      if entity.z <= 0 then
         entity.z = 0
         entity.vel_z = 0
         entity.landed = true
      end
      return -- Don't hatch while falling
   end

   -- Initialize hatch_time_max on first frame after landing
   if not entity.hatch_time_max then
      entity.hatch_time_max = entity.hatch_timer or 120
   end

   -- Update sprite based on hatch progress
   local hatch_frames = GameConstants.Minion.Egg.hatch_frames
   local frame_count = #hatch_frames
   local progress = 1 - (entity.hatch_timer / entity.hatch_time_max) -- 0 to 1
   local frame_idx = flr(progress * frame_count) + 1
   frame_idx = mid(1, frame_idx, frame_count)                        -- Clamp to valid range
   entity.sprite_index = hatch_frames[frame_idx]

   -- Decrement hatch timer
   if entity.hatch_timer and entity.hatch_timer > 0 then
      entity.hatch_timer = entity.hatch_timer - 1

      -- Hatch into chick when timer reaches 0
      if entity.hatch_timer <= 0 then
         -- Prepare chick options
         local chick_opts = {
            attachment_target = entity.attachment_target,
            attachment_timer = entity.attachment_timer,
         }

         -- Apply Broodmother mutation stats (Double base stats)
         if entity.broodmother_active then
            local base_config = GameConstants.Minion.Chick
            chick_opts.hp = (base_config.hp or 20) * 2
            chick_opts.attack_damage = (base_config.attack_damage or 3) * 2
            chick_opts.attack_cooldown = math.floor((base_config.attack_cooldown or 30) / 2)
            -- Optionally double other stats if needed
         end

         -- Pass attachment data to chick (Face-Hugger mechanic)
         Entities.spawn_chick(world, entity.x, entity.y, chick_opts)
         world.del(entity)
      end
   end
end

:: src/ai/primitives/chase.lua
-- Chase primitive
-- Provides simple "move toward target" behavior
-- This is a stateless primitive - just calculates movement

local Chase = {}

--- Move entity toward a target position
--- @param entity The entity to move
--- @param target_x Target X position
--- @param target_y Target Y position
--- @param speed_mult Optional speed multiplier (default 1.0)
--- @return dist The distance to target
function Chase.toward(entity, target_x, target_y, speed_mult)
   local dx = target_x - entity.x
   local dy = target_y - entity.y
   local dist = sqrt(dx * dx + dy * dy)
   local speed = entity.max_speed * (speed_mult or 1.0)

   if dist > 0 then
      entity.vel_x = (dx / dist) * speed
      entity.vel_y = (dy / dist) * speed
      entity.dir_x = sgn(dx)
      entity.dir_y = sgn(dy)
   end

   return dist
end

--- Move entity away from a target position (flee)
--- @param entity The entity to move
--- @param target_x Target X position to flee from
--- @param target_y Target Y position to flee from
--- @param speed_mult Optional speed multiplier (default 1.0)
--- @return dist The distance to target
function Chase.away(entity, target_x, target_y, speed_mult)
   local dx = target_x - entity.x
   local dy = target_y - entity.y
   local dist = sqrt(dx * dx + dy * dy)
   local speed = entity.max_speed * (speed_mult or 1.0)

   if dist > 0 then
      entity.vel_x = -(dx / dist) * speed
      entity.vel_y = -(dy / dist) * speed
      entity.dir_x = sgn(dx) -- Face toward target even when fleeing
      entity.dir_y = sgn(dy)
   end

   return dist
end

--- Maintain a specific distance from target (orbit-like)
--- @param entity The entity to position
--- @param target_x Target X position
--- @param target_y Target Y position
--- @param ideal_dist The ideal distance to maintain
--- @param tolerance How much variance is acceptable
--- @return dist The current distance to target
function Chase.maintain_distance(entity, target_x, target_y, ideal_dist, tolerance)
   local dx = target_x - entity.x
   local dy = target_y - entity.y
   local dist = sqrt(dx * dx + dy * dy)

   if dist > ideal_dist + tolerance then
      -- Too far, move closer
      Chase.toward(entity, target_x, target_y)
   elseif dist < ideal_dist - tolerance then
      -- Too close, back away
      Chase.away(entity, target_x, target_y, 1.5)
   else
      -- At ideal distance, slow down
      entity.vel_x = entity.vel_x * 0.9
      entity.vel_y = entity.vel_y * 0.9
   end

   -- Always face target
   if dist > 0 then
      entity.dir_x = sgn(dx)
      entity.dir_y = sgn(dy)
   end

   return dist
end

return Chase

:: src/ai/primitives/dash.lua
-- Dash primitive
-- Provides dash behavior: windup (aiming) and charge (rapid movement)
local EntityUtils = require("src/utils/entity_utils")

local Dash = {}

--- Handle windup phase: aim at target
--- @param entity table The dasher entity
--- @param dx number X distance to target
--- @param dy number Y distance to target
--- @param dist number Total distance to target
--- @param lock_aim boolean If true, do not update aim direction (aim is locked)
function Dash.windup(entity, dx, dy, dist, lock_aim)
   -- Stop moving during windup
   entity.vel_x = 0
   entity.vel_y = 0

   -- Update aim if target exists and aim is not locked
   if dist > 0 and not lock_aim then
      entity.dash_target_dx = dx / dist
      entity.dash_target_dy = dy / dist

      -- Update facing direction to match target so animation rotates correctly
      entity.dir_x = sgn(entity.dash_target_dx)
      entity.dir_y = sgn(entity.dash_target_dy)

      -- Force update current_direction for animation system (since vel is 0)
      entity.current_direction = EntityUtils.get_direction_name(
         entity.dash_target_dx,
         entity.dash_target_dy,
         entity.current_direction
      )

      return true -- Aim updated
   end

   return false -- Aim not updated (locked or no target)
end

--- Handle dash movement
--- @param entity table The dasher entity
--- @return boolean True if hit wall
function Dash.update(entity)
   -- Move at dash speed in cached direction
   local speed_mult = entity.dash_speed_multiplier or 4
   local dash_speed = entity.max_speed * speed_mult

   entity.vel_x = entity.dash_target_dx * dash_speed
   entity.vel_y = entity.dash_target_dy * dash_speed
   entity.dir_x = sgn(entity.dash_target_dx)
   entity.dir_y = sgn(entity.dash_target_dy)

   -- Return true if wall collision occurred
   if entity.hit_wall then
      entity.hit_wall = false
      return true
   end

   return false
end

return Dash

:: src/ai/primitives/path_follow.lua
-- PathFollow AI Primitive
-- Provides pathfinding-based movement toward a target
-- Uses A* via the Pathfinder wrapper
-- OPTIMIZED: Frame budget guard, extended staggering, increased direct move distance

local Pathfinder = require("lib/lua-star/pathfinder")
local EntityUtils = require("src/utils/entity_utils")
local HitboxUtils = require("src/utils/hitbox_utils")

local PathFollow = {}

-- Configuration
local REPATH_INTERVAL = 180    -- Frames between path recalculations (3 seconds) - INCREASED from 90
local WAYPOINT_RADIUS = 8      -- Distance to consider waypoint reached
local STUCK_THRESHOLD = 5      -- Frames without progress before re-pathing
local STUCK_DIST_THRESHOLD = 2 -- Minimum movement per frame to not be "stuck"
local DIRECT_MOVE_DIST = 80    -- Use direct movement if target within this distance (5 tiles) - INCREASED from 64
local MAX_PATH_LENGTH = 50     -- Increased from 30 to handle paths across large rooms
local MAX_PATHS_PER_FRAME = 1  -- Maximum A* calculations per frame (frame budget) - REDUCED from 2

-- Entity counter for staggering (distributes pathfinding across frames)
local entity_counter = 0

-- Frame budget tracking (reset each frame by calling reset_frame_budget)
local paths_this_frame = 0
local last_frame_time = 0

--- Reset the frame budget counter (call once per frame from main update)
function PathFollow.reset_frame_budget()
   paths_this_frame = 0
end

--- Check if there's a clear line-of-sight between two points (no solid tiles in the way)
--- Uses Bresenham-style stepping along the line
--- @param x1 number Start X (pixels)
--- @param y1 number Start Y (pixels)
--- @param x2 number End X (pixels)
--- @param y2 number End Y (pixels)
--- @param room table|nil Room for obstacle checks
--- @return boolean True if path is clear
local function has_line_of_sight(x1, y1, x2, y2, room)
   local dx = x2 - x1
   local dy = y2 - y1
   local dist = sqrt(dx * dx + dy * dy)
   if dist < 8 then return true end -- Very close, assume clear

   -- Step along the line in 8-pixel increments
   local steps = ceil(dist / 8)
   local step_x = dx / steps
   local step_y = dy / steps

   for i = 1, steps do
      local px = x1 + step_x * i
      local py = y1 + step_y * i
      local tx, ty = flr(px / 16), flr(py / 16)

      if not Pathfinder.is_walkable(tx, ty, room) then
         return false
      end
   end

   return true
end

--- Initialize pathfinding state on an entity
--- @param entity table Entity to initialize
local function init_path_state(entity)
   if not entity.path_state then
      -- Give each entity a unique stagger offset to distribute pathfinding
      -- OPTIMIZATION: Increased spread from 10 to 15 entities over 90 frames
      entity_counter = entity_counter + 1
      local stagger = (entity_counter % 15) * 6 -- Spread across ~90 frames (6 frames apart)

      entity.path_state = {
         path = nil,             -- Current path waypoints
         path_index = 1,         -- Current waypoint index
         repath_timer = stagger, -- Start staggered to avoid all pathing same frame
         target_x = nil,         -- Last known target position
         target_y = nil,
         last_x = nil,           -- Position last frame (stuck detection)
         last_y = nil,
         stuck_frames = 0,       -- Consecutive frames with no progress
      }
   end
end

--- Clear the current path (call when changing targets or states)
--- @param entity table Entity to clear path for
function PathFollow.clear_path(entity)
   if entity.path_state then
      entity.path_state.path = nil
      entity.path_state.path_index = 1
      entity.path_state.repath_timer = 0
      entity.path_state.stuck_frames = 0
   end
end

--- Check if entity has an active path
--- @param entity table Entity to check
--- @return boolean
function PathFollow.has_path(entity)
   return entity.path_state and entity.path_state.path and #entity.path_state.path > 0
end

--- Move entity toward a target using pathfinding
--- @param entity table Entity to move
--- @param target_x number Target pixel X
--- @param target_y number Target pixel Y
--- @param speed_mult number|nil Speed multiplier (default 1.0)
--- @param room table|nil Current room for obstacle awareness
--- @return number Distance to target
function PathFollow.toward(entity, target_x, target_y, speed_mult, room)
   init_path_state(entity)
   local state = entity.path_state
   local speed = entity.max_speed * (speed_mult or 1.0)

   -- Get entity center position
   local hb = HitboxUtils.get_hitbox(entity)
   local ex = hb.x + hb.w / 2
   local ey = hb.y + hb.h / 2

   -- Calculate distance to final target
   local dx = target_x - ex
   local dy = target_y - ey
   local dist_to_target = sqrt(dx * dx + dy * dy)

   -- Check if we need to recalculate path
   local need_repath = false

   -- Decrement repath timer
   state.repath_timer = max(0, state.repath_timer - 1)

   -- Reasons to repath:
   -- 1. No path exists
   if not state.path then
      need_repath = true
      -- 2. Timer expired
   elseif state.repath_timer <= 0 then
      need_repath = true
      -- 3. Target moved significantly (> 2 tiles)
   elseif state.target_x and state.target_y then
      local target_moved = abs(target_x - state.target_x) + abs(target_y - state.target_y)
      if target_moved > 32 then
         need_repath = true
      end
      -- 4. Entity is stuck
   elseif state.stuck_frames >= STUCK_THRESHOLD then
      need_repath = true
      state.stuck_frames = 0
   end

   -- Calculate new path if needed
   if need_repath then
      -- Skip pathfinding if target is close enough for direct movement
      if dist_to_target < DIRECT_MOVE_DIST then
         state.path = nil
         state.repath_timer = REPATH_INTERVAL
      else
         -- OPTIMIZATION: Frame budget guard - skip A* if budget exhausted
         if paths_this_frame < MAX_PATHS_PER_FRAME then
            paths_this_frame = paths_this_frame + 1
            local new_path = Pathfinder.find_path(ex, ey, target_x, target_y, room)
            -- Only use path if it's reasonably short
            if new_path and #new_path <= MAX_PATH_LENGTH then
               state.path = new_path
            else
               state.path = nil -- Too long or no path, use direct movement
            end
            state.path_index = 1
            state.target_x = target_x
            state.target_y = target_y
            state.repath_timer = REPATH_INTERVAL
         else
            -- Budget exhausted, delay repath by a few frames
            state.repath_timer = 3 + (entity_counter % 5) -- Staggered retry
         end
      end
   end

   -- Stuck detection: check if we moved since last frame
   if state.last_x and state.last_y then
      local moved = abs(ex - state.last_x) + abs(ey - state.last_y)
      if moved < STUCK_DIST_THRESHOLD then
         state.stuck_frames = state.stuck_frames + 1
      else
         state.stuck_frames = 0
      end
   end
   state.last_x = ex
   state.last_y = ey

   -- If no valid path, stop movement and let caller handle (e.g., wander, give up)
   -- Previously this fell back to direct movement, but that caused entities to walk
   -- into pits/walls when A* correctly determined no path exists
   if not state.path or #state.path == 0 then
      entity.vel_x = 0
      entity.vel_y = 0
      return dist_to_target
   end

   -- Get current waypoint
   local waypoint = state.path[state.path_index]
   if not waypoint then
      -- Reached end of path, clear it
      PathFollow.clear_path(entity)
      return dist_to_target
   end

   -- PATH SMOOTHING: Try to skip ahead to a further waypoint if we have line-of-sight
   -- Check waypoints from furthest to nearest, use the furthest one we can see
   local best_waypoint_idx = state.path_index
   for i = #state.path, state.path_index + 1, -1 do
      local future_wp = state.path[i]
      if has_line_of_sight(ex, ey, future_wp.x, future_wp.y, room) then
         best_waypoint_idx = i
         break -- Found furthest visible waypoint
      end
   end

   -- Also check if we can move directly to the final target
   if has_line_of_sight(ex, ey, target_x, target_y, room) then
      -- Direct path to target is clear! Skip all waypoints
      dx = target_x - ex
      dy = target_y - ey
      local direct_dist = sqrt(dx * dx + dy * dy)
      if direct_dist > 0 then
         entity.vel_x = (dx / direct_dist) * speed
         entity.vel_y = (dy / direct_dist) * speed
         entity.dir_x = sgn(dx)
         entity.dir_y = sgn(dy)
         entity.current_direction = EntityUtils.get_direction_name(dx, dy, entity.current_direction)
      end
      return dist_to_target
   end

   -- Update waypoint to the best (furthest visible) one
   if best_waypoint_idx > state.path_index then
      state.path_index = best_waypoint_idx
   end
   waypoint = state.path[state.path_index]

   -- Calculate direction to waypoint
   local wx = waypoint.x - ex
   local wy = waypoint.y - ey
   local dist_to_waypoint = sqrt(wx * wx + wy * wy)

   -- Check if waypoint reached
   if dist_to_waypoint < WAYPOINT_RADIUS then
      state.path_index = state.path_index + 1
      -- Check if path complete
      if state.path_index > #state.path then
         PathFollow.clear_path(entity)
         return dist_to_target
      end
      -- Move to next waypoint
      waypoint = state.path[state.path_index]
      wx = waypoint.x - ex
      wy = waypoint.y - ey
      dist_to_waypoint = sqrt(wx * wx + wy * wy)
   end

   -- Move toward current waypoint
   if dist_to_waypoint > 0 then
      entity.vel_x = (wx / dist_to_waypoint) * speed
      entity.vel_y = (wy / dist_to_waypoint) * speed
      entity.dir_x = sgn(wx)
      entity.dir_y = sgn(wy)
      entity.current_direction = EntityUtils.get_direction_name(wx, wy, entity.current_direction)
   end

   return dist_to_target
end

--- Debug: Draw the current path (call from rendering system)
--- @param entity table Entity with path
--- @param color number|nil Line color (default 11 = green)
function PathFollow.debug_draw(entity, color)
   if not entity.path_state or not entity.path_state.path then return end

   color = color or 11
   local path = entity.path_state.path
   local idx = entity.path_state.path_index or 1

   if #path == 0 or idx > #path then return end

   -- Draw line from entity to first waypoint
   local first_wp = path[idx]
   if first_wp then
      local ex = entity.x + (entity.width or 16) / 2
      local ey = entity.y + (entity.height or 16) / 2
      line(ex, ey, first_wp.x, first_wp.y, color)
   end

   -- Draw remaining path segments
   for i = idx, #path - 1 do
      local p1 = path[i]
      local p2 = path[i + 1]
      line(p1.x, p1.y, p2.x, p2.y, color)
   end

   -- Draw waypoints
   for i = idx, #path do
      local p = path[i]
      circfill(p.x, p.y, 2, color)
   end
end

-- Export line-of-sight check for external use (e.g., chick AI direct chase)
PathFollow.has_line_of_sight = has_line_of_sight

return PathFollow

:: src/ai/primitives/seek_food.lua
-- AI Primitive: Seek Food
-- Causes entity to seek towards YolkSplat entities and consume them for health
-- OPTIMIZED: No intermediate table allocation, squared distances

local HitboxUtils = require("src/utils/hitbox_utils")
local GameConstants = require("src/game/game_config")
local FloatingText = require("src/systems/floating_text")

local SeekFood = {}

-- Check if entity is overlapping food
local function check_collision(entity, food)
   local hb1 = HitboxUtils.get_hitbox(entity)
   local hb2 = HitboxUtils.get_hitbox(food)

   return hb1.x < hb2.x + hb2.w and
      hb1.x + hb1.w > hb2.x and
      hb1.y < hb2.y + hb2.h and
      hb1.y + hb1.h > hb2.y
end

--- Update SeekFood behavior
--- OPTIMIZED: Find nearest directly in ECS callback (no table allocation)
--- @param entity Entity - The hungry entity
--- @param world table - ECS world for querying and deleting entities
--- @param range number - Scanning range (default 100)
--- @param heal_amount number - Amount to heal (default 5)
--- @return boolean - Returns true if food was found/pursued/eaten, false otherwise
function SeekFood.update(entity, world, range, heal_amount)
   range = range or 100
   heal_amount = heal_amount or 5

   -- Find nearest YolkSplat directly in callback (avoid table allocation)
   local nearest_food = nil
   local nearest_dist_sq = range * range -- Distance squared
   local ex, ey = entity.x, entity.y

   -- OPTIMIZATION: Find nearest directly in ECS query callback
   world.sys("yolk_splat", function(food)
      local dx = food.x - ex
      local dy = food.y - ey
      local dist_sq = dx * dx + dy * dy

      if dist_sq < nearest_dist_sq then
         nearest_dist_sq = dist_sq
         nearest_food = food
      end
   end)()

   if nearest_food then
      -- Move towards food (need sqrt only for movement direction)
      local dx = nearest_food.x - ex
      local dy = nearest_food.y - ey
      local dist = sqrt(nearest_dist_sq)

      if dist > 0 then
         dx = dx / dist
         dy = dy / dist

         entity.vel_x = dx * (entity.max_speed or 0.5)
         entity.vel_y = dy * (entity.max_speed or 0.5)

         -- Check if reached/eating
         if check_collision(entity, nearest_food) then
            -- Eat it!
            world.del(nearest_food)
            entity.hp = math.min((entity.max_hp or 10), entity.hp + heal_amount)
            -- Spawn heal text or effect
            if FloatingText then
               FloatingText.spawn_at_entity(entity, heal_amount, "heal")
            end
         end
         return true -- Busy eating
      end
   end

   return false -- No food found
end

return SeekFood

:: src/ai/primitives/wander.lua
-- Wander primitive
-- Provides random wandering movement for entities without a current target
-- This is a stateful primitive that tracks wander state on the entity

local EntityUtils = require("src/utils/entity_utils")
local Emotions = require("src/systems/emotions")

local Wander = {}

-- Pick a random destination within radius of current position
local function pick_wander_target(entity)
   local radius = entity.wander_radius or 48
   local angle = rnd(1) * 2 * 3.14159            -- Random angle in radians
   local dist = rnd(radius * 0.5) + radius * 0.5 -- Between 50-100% of radius

   entity.wander_target_x = entity.x + cos(angle / (2 * 3.14159)) * dist
   entity.wander_target_y = entity.y + sin(angle / (2 * 3.14159)) * dist

   -- Set pause timer for when we reach target
   local pause_min = entity.wander_pause_min or 30
   local pause_max = entity.wander_pause_max or 90
   entity.wander_pause_duration = flr(rnd(pause_max - pause_min)) + pause_min
end

-- Initialize wandering state on entity if needed
local function init_wandering(entity)
   if not entity.wander_initialized then
      entity.wander_initialized = true
      entity.wander_state = "moving" -- "moving" or "pausing"
      entity.wander_timer = 0
      pick_wander_target(entity)
   end
end

--- Execute wander behavior for one frame
-- Updates entity velocity and direction
-- @param entity The entity to wander
function Wander.update(entity)
   init_wandering(entity)

   local speed_mult = entity.wander_speed_mult or 0.5
   local speed = entity.max_speed * speed_mult

   if entity.wander_state == "pausing" then
      -- Stand still during pause
      entity.vel_x = 0
      entity.vel_y = 0

      entity.wander_timer = entity.wander_timer - 1
      if entity.wander_timer <= 0 then
         -- Done pausing, pick new target and start moving
         pick_wander_target(entity)
         entity.wander_state = "moving"
      end
   else
      -- Moving toward target
      local dx = entity.wander_target_x - entity.x
      local dy = entity.wander_target_y - entity.y
      local dist = sqrt(dx * dx + dy * dy)

      -- Check if we hit a wall last frame (flag set by collision system)
      if entity.hit_wall then
         -- Pick a new target when blocked
         pick_wander_target(entity)
         entity.hit_wall = false
         dx = entity.wander_target_x - entity.x
         dy = entity.wander_target_y - entity.y
         dist = sqrt(dx * dx + dy * dy)
      end

      if dist > 4 then
         -- Move toward target
         entity.vel_x = (dx / dist) * speed
         entity.vel_y = (dy / dist) * speed
         entity.dir_x = sgn(dx)
         entity.dir_y = sgn(dy)

         -- Update direction for animation system
         entity.current_direction = EntityUtils.get_direction_name(dx, dy, entity.current_direction)
      else
         -- Reached target, start pausing
         entity.wander_state = "pausing"
         entity.wander_timer = entity.wander_pause_duration
         entity.vel_x = 0
         entity.vel_y = 0

         -- Show idle emotion when pausing (50% chance to avoid spam)
         if rnd(1) > 0.5 then
            Emotions.set(entity, "idle")
         end
      end
   end
end

--- Reset wandering state (call when switching to combat mode)
-- @param entity The entity to reset
function Wander.reset(entity)
   entity.wander_initialized = false
   entity.wander_state = nil
   entity.wander_timer = nil
   entity.wander_target_x = nil
   entity.wander_target_y = nil
end

return Wander

:: src/entities.lua
return require("src/entities/init")

:: src/entities/bomb.lua
-- Bomb entity factory
-- Handles spawning PlacedBomb entities (the timed explosive, not the pickup)

local GameConstants = require("src/game/game_config")
local EntityUtils = require("src/utils/entity_utils")

local Bomb = {}

-- Spawn a placed bomb at the given position
-- @param world - ECS world
-- @param x, y - Position in pixels (will be tile-aligned)
function Bomb.spawn(world, x, y)
   local config = GameConstants.PlacedBomb

   -- Tile-align the position (snap to 16x16 grid)
   local tile_x = flr(x / GRID_SIZE) * GRID_SIZE
   local tile_y = flr(y / GRID_SIZE) * GRID_SIZE

   local entity = {
      type = config.entity_type,
      x = tile_x,
      y = tile_y,
      width = config.width,
      height = config.height,
      sprite_index = config.sprite_index,
      fuse_timer = config.fuse_time,
      explosion_radius = config.explosion_radius,
      shadow_offset_y = config.shadow_offset_y,
      shadow_offset_x = config.shadow_offset_x or 0,
      shadow_width = config.shadow_width,
   }

   return EntityUtils.spawn_entity(world, config.tags, entity)
end

return Bomb

:: src/entities/enemy.lua
-- Enemy entity factory (Type Object pattern)
-- All enemy types are defined as pure data in GameConstants.Enemy
-- This factory simply instantiates entities from their type config
local GameConstants = require("src/game/game_config")
local EntityUtils = require("src/utils/entity_utils")

local Enemy = {}

-- Unified spawn function using Type Object pattern
-- @param world - ECS world
-- @param x, y - spawn position
-- @param enemy_type - type key in GameConstants.Enemy (default: "Skulker")
-- @param instance_data - optional table with instance-specific overrides
function Enemy.spawn(world, x, y, enemy_type, instance_data)
    enemy_type = enemy_type or "Skulker"
    instance_data = instance_data or {}

    local config = GameConstants.Enemy[enemy_type]
    if not config then
        Log.error("Attempted to spawn unknown enemy type: "..tostring(enemy_type))
        return nil
    end

    -- 1. Base identity and physics state
    local enemy = {
        type = config.entity_type or "Enemy",
        enemy_type = enemy_type,
        x = x,
        y = y,
        vel_x = 0,
        vel_y = 0,
        sub_x = 0,
        sub_y = 0,
        dir_x = 0,
        dir_y = 1, -- Default facing down
        flip_x = false,
        hp = config.hp or 10,
        max_hp = config.hp or 10,
    }

    -- 2. Bulk copy all non-table values from config (stats, bounds, offsets)
    for k, v in pairs(config) do
        if type(v) ~= "table" then
            enemy[k] = v
        end
    end

    -- 3. Static table references (offsets, directional maps)
    enemy.sprite_index_offsets = config.sprite_index_offsets
    enemy.shadow_offsets_y = config.shadow_offsets_y
    enemy.shadow_offsets_x = config.shadow_offsets_x
    enemy.shadow_widths = config.shadow_widths
    enemy.shadow_heights = config.shadow_heights
    enemy.muzzle_flash_offsets = config.muzzle_flash_offsets
    enemy.muzzle_flash_colors = config.muzzle_flash_colors

    -- 4. Dynamic/Behavior initialization
    if enemy.sprite_index_offsets then
        enemy.sprite_index = enemy.sprite_index_offsets.down
    end

    if enemy.is_shooter then
        -- Properties for generic shooter system
        enemy.shoot_cooldown = 0
        enemy.shoot_cooldown_duration = enemy.shoot_delay or 60
        enemy.projectile_type = "EnemyBullet"
        enemy.health_as_ammo = false -- Enemies have unlimited ammo

        -- Note: shooter and timers tags should be added in constants.lua enemy config
    end

    -- 5. Apply instance overrides
    for k, v in pairs(instance_data) do
        enemy[k] = v
    end

    -- 6. Create entity with tags from config
    return EntityUtils.spawn_entity(world, config.tags, enemy)
end

return Enemy

:: src/entities/explosion.lua
-- Explosion entity factory
-- Reusable explosion effect for bombs, enemy attacks, environmental hazards, etc.

local GameConstants = require("src/game/game_config")
local EntityUtils = require("src/utils/entity_utils")

local Explosion = {}

-- Spawn a single explosion at the given position
-- @param world - ECS world
-- @param x, y - Position in pixels
-- @param center_x, center_y - Optional center for knockback direction (defaults to x, y)
-- @return The spawned explosion entity
function Explosion.spawn(world, x, y, center_x, center_y)
   local config = GameConstants.Explosion

   local entity = {
      type = config.entity_type,
      x = x,
      y = y,
      width = config.width,
      height = config.height,
      sprite_index = config.sprite_index,
      lifespan = config.lifespan,
      hitbox_width = config.hitbox_width,
      hitbox_height = config.hitbox_height,
      hitbox_offset_x = config.hitbox_offset_x,
      hitbox_offset_y = config.hitbox_offset_y,
      -- Store explosion center for radial knockback
      explosion_center_x = center_x or x,
      explosion_center_y = center_y or y,
      explosion_damage = config.damage or 20,
   }

   return EntityUtils.spawn_entity(world, config.tags, entity)
end

-- Spawn explosions in a 3x3 grid around a center position
-- @param world - ECS world
-- @param center_x, center_y - Center position in pixels (typically bomb position)
-- @param radius - Radius in tiles (1 = 3x3, 2 = 5x5, etc.)
function Explosion.spawn_grid(world, center_x, center_y, radius)
   radius = radius or 1

   for dy = -radius, radius do
      for dx = -radius, radius do
         local ex = center_x + dx * GRID_SIZE
         local ey = center_y + dy * GRID_SIZE
         -- Pass the bomb center so all explosions knockback from center
         Explosion.spawn(world, ex, ey, center_x, center_y)
      end
   end
end

return Explosion

:: src/entities/init.lua
-- Main entities module: aggregates all entity factories
local Player = require("src/entities/player")
local Projectile = require("src/entities/projectile")
local Enemy = require("src/entities/enemy")
local Pickup = require("src/entities/pickup")
local Obstacle = require("src/entities/obstacle")
local Bomb = require("src/entities/bomb")
local Explosion = require("src/entities/explosion")
local Minion = require("src/entities/minion")

local Entities = {}

Entities.spawn_player = Player.spawn
Entities.spawn_enemy = Enemy.spawn
Entities.spawn_obstacle = Obstacle.spawn

-- Bomb spawners
Entities.spawn_bomb = Bomb.spawn
Entities.spawn_explosion = Explosion.spawn
Entities.spawn_explosion_grid = Explosion.spawn_grid

-- Projectile spawners (convenience wrappers for Type Object pattern)
Entities.spawn_player_projectile = function(world, x, y, dx, dy, instance_data)
    return Projectile.spawn(world, x, y, dx, dy, "Egg", instance_data)
end
Entities.spawn_enemy_projectile = function(world, x, y, dx, dy)
    return Projectile.spawn(world, x, y, dx, dy, "EnemyBullet")
end
Entities.spawn_projectile_from_origin = Projectile.spawn_from_origin

-- Pickup spawners (convenience wrappers for Type Object pattern)
Entities.spawn_health_pickup = Pickup.spawn_health

-- Random pickup spawn (for destructibles, etc.)
Entities.spawn_pickup = function(world, x, y, pickup_type, instance_data)
    if pickup_type then
        return Pickup.spawn(world, x, y, pickup_type, instance_data)
    else
        -- Random from available types (only HealthPickup for now)
        return Pickup.spawn_health(world, x, y)
    end
end

-- Minion spawners
Entities.spawn_chick = function(world, x, y, instance_data)
    return Minion.spawn(world, x, y, "Chick", instance_data)
end

Entities.spawn_minion = function(world, x, y, minion_type, instance_data)
    return Minion.spawn(world, x, y, minion_type, instance_data)
end

Entities.spawn_egg = function(world, x, y, instance_data)
    return Minion.spawn(world, x, y, "Egg", instance_data)
end

Entities.spawn_yolk_splat = function(world, x, y, instance_data)
    return Minion.spawn(world, x, y, "YolkSplat", instance_data)
end

return Entities

:: src/entities/minion.lua
-- Minion entity factory (for player-summoned entities)
-- Uses Type Object pattern like Enemy/Projectile factories
local GameConstants = require("src/game/game_config")
local EntityUtils = require("src/utils/entity_utils")

local Minion = {}

-- Spawn a minion at position
-- @param world - ECS world
-- @param x, y - spawn position
-- @param minion_type - type key in GameConstants.Minion (default: "Chick")
-- @param instance_data - optional table with instance-specific overrides
function Minion.spawn(world, x, y, minion_type, instance_data)
   minion_type = minion_type or "Chick"
   instance_data = instance_data or {}

   local config = GameConstants.Minion[minion_type]
   if not config then
      Log.error("Attempted to spawn unknown minion type: "..tostring(minion_type))
      return nil
   end

   -- 1. Base identity and physics state
   local minion = {
      type = config.entity_type or "Minion",
      minion_type = minion_type,
      tags = config.tags, -- Store tags for systems that check entity.tags
      x = x,
      y = y,
      vel_x = 0,
      vel_y = 0,
      sub_x = 0,
      sub_y = 0,
      dir_x = 1,
      dir_y = 0,
      hp = config.hp or 1,
      max_hp = config.hp or 1,
   }

   -- 2. Bulk copy all non-table values from config
   for k, v in pairs(config) do
      if type(v) ~= "table" then
         minion[k] = v
      end
   end

   -- 3. Static table references
   minion.sprite_index_offsets = config.sprite_index_offsets
   minion.shadow_offsets_y = config.shadow_offsets_y
   minion.shadow_offsets_x = config.shadow_offsets_x
   minion.shadow_widths = config.shadow_widths
   minion.shadow_heights = config.shadow_heights
   minion.animations = config.animations

   -- 4. Dynamic initialization
   minion.current_direction = "right" -- Default direction for animations
   minion.anim_state = "idle"         -- Default animation state
   if minion.sprite_index_offsets then
      minion.sprite_index = minion.sprite_index_offsets.right
   end

   -- 5. Apply instance overrides
   for k, v in pairs(instance_data) do
      minion[k] = v
   end

   -- 6. Create entity with tags from config
   return EntityUtils.spawn_entity(world, config.tags, minion)
end

return Minion

:: src/entities/obstacle.lua
local GameConstants = require("src/game/game_config")
local Utils = require("src/utils/entity_utils")

local Obstacle = {}

-- Spawn generic obstacle (Rock, Destructible)
function Obstacle.spawn(world, x, y, obstacle_type, sprite_override)
   local config = GameConstants.Obstacle[obstacle_type]
   if not config then
      Log.error("Unknown obstacle type: "..tostring(obstacle_type))
      return nil
   end

   -- Create entity data by merging config + instance data
   local entity_data = {}
   -- Copy config first
   for k, v in pairs(config) do entity_data[k] = v end
   -- Apply overrides
   if sprite_override then
      entity_data.sprite_index = sprite_override
   end

   -- Use standard spawn_entity utility to handle tagging and shadows
   local entity = Utils.spawn_entity(world, config.tags, entity_data)

   entity.type = config.entity_type

   -- Set position directly
   entity.x = x
   entity.y = y

   return entity
end

return Obstacle

:: src/entities/pickup.lua
-- Pickup entity factory (Type Object pattern)
-- All pickup types are defined as pure data in GameConstants.Pickup
-- This factory simply instantiates entities from their type config
local GameConstants = require("src/game/game_config")
local EntityUtils = require("src/utils/entity_utils")

local Pickup = {}

--- Unified spawn function using Type Object pattern
--- @param world ECSWorld
--- @param x number
--- @param y number
--- @param pickup_type string- type key in GameConstants.Pickup (e.g., "HealthPickup", "Coin")
--- @param instance_data optional table with instance-specific overrides
--- @return table|nil
function Pickup.spawn(world, x, y, pickup_type, instance_data)
    instance_data = instance_data or {}

    local config = GameConstants.Pickup[pickup_type]
    if not config then
        Log.error("Attempted to spawn unknown pickup type: "..tostring(pickup_type))
        return nil
    end

    local direction = instance_data.direction

    -- 1. Base identity and physics state
    local pickup = {
        type = config.entity_type or "Pickup",
        pickup_type = pickup_type,
        x = x,
        y = y,
        vel_x = 0,
        vel_y = 0,
        sub_x = 0,
        sub_y = 0,
    }

    -- 2. Bulk copy all non-table values from config (stats, bounds, offsets)
    for k, v in pairs(config) do
        if type(v) ~= "table" then
            pickup[k] = v
        end
    end

    -- 3. Sprite: use instance override, or direction-based lookup, or static sprite
    if instance_data.sprite_index then
        pickup.sprite_index = instance_data.sprite_index
    elseif config.sprite_index_offsets and direction then
        pickup.sprite_index = config.sprite_index_offsets[direction]
    else
        pickup.sprite_index = config.sprite_index or 0
    end

    -- 5. Apply instance-specific overrides
    for k, v in pairs(instance_data) do
        pickup[k] = v
    end

    -- 6. Create entity with tags from config
    return EntityUtils.spawn_entity(world, config.tags, pickup)
end

-- Convenience: Spawn simple health pickup (from enemy deaths)
function Pickup.spawn_health(world, x, y, amount)
    return Pickup.spawn(world, x, y, "HealthPickup", {
        recovery_amount = amount,
    })
end

return Pickup

:: src/entities/player.lua
-- Player entity factory
local GameConstants = require("src/game/game_config")
local EntityUtils = require("src/utils/entity_utils")

local Player = {}

function Player.spawn(world, x, y)
    local player = {
        type = "Player",
        x = x,
        y = y,
        width = 16,
        height = 16,
        -- Per-direction hitboxes (uses entity.hitboxes[direction] lookup in HitboxUtils)
        hitboxes = GameConstants.Player.hitboxes,
        shadow_offset_y = GameConstants.Player.shadow_offset_y or 0,
        shadow_offset_x = GameConstants.Player.shadow_offset_x or 0,
        shadow_offsets_y = GameConstants.Player.shadow_offsets_y,
        shadow_offsets_x = GameConstants.Player.shadow_offsets_x,
        shadow_width = GameConstants.Player.shadow_width,
        shadow_height = GameConstants.Player.shadow_height,
        shadow_widths = GameConstants.Player.shadow_widths,
        shadow_heights = GameConstants.Player.shadow_heights,
        -- Movement properties (BoI-style: instant response, almost no slide)
        accel = 1.2,
        max_speed = GameConstants.Player.max_speed,
        friction = 0.5,
        vel_x = 0,
        vel_y = 0,
        sub_x = 0,
        sub_y = 0,
        dir_x = 0,
        dir_y = 1, -- Default facing down
        sprite_index = GameConstants.Player.sprite_index_offsets.down,
        -- Health components
        hp = GameConstants.Player.max_health,
        max_hp = GameConstants.Player.max_health,
        max_hp_to_shot_cost_ratio = GameConstants.Player.max_hp_to_shot_cost_ratio,

        -- Calculated properties (removed to ensure dynamic calculation)
        -- shot_cost is calculated by systems based on max_hp * ratio
        recovery_percent = GameConstants.Player.recovery_percent,
        regen_rate = GameConstants.Player.regen_rate,
        regen_delay = GameConstants.Player.regen_delay,
        time_since_shot = 0,
        overflow_hp = 0,
        shoot_cooldown = 0,
        -- Combat Stats
        shot_speed = GameConstants.Player.shot_speed,
        max_hp_to_damage_ratio = GameConstants.Player.max_hp_to_damage_ratio,
        knockback = GameConstants.Player.base_knockback,
        range = GameConstants.Player.range,
        fire_rate = GameConstants.Player.fire_rate,
        -- Egg outcome stats (single roll with 3 equal outcomes)
        impact_damage = GameConstants.Player.impact_damage,
        drain_damage = GameConstants.Player.drain_damage,
        drain_heal = GameConstants.Player.drain_heal,
        hatch_time = GameConstants.Player.hatch_time,
        vampiric_heal = GameConstants.Player.vampiric_heal,

        melee_cooldown = 0,
        melee_cost = GameConstants.Player.melee_cost,
        melee_bonus_damage = 0,         -- Bonus flat damage for melee
        invuln_timer = 0,               -- Frames of invulnerability remaining after taking damage
        invulnerability_duration = 120, -- Default duration (can be upgraded)

        -- Inventory
        coins = GameConstants.Player.coins,
        keys = GameConstants.Player.keys,
        bombs = GameConstants.Player.bombs,
        -- XP/Leveling
        xp = GameConstants.Player.starting_xp,
        level = GameConstants.Player.starting_level,
        xp_to_next_level = GameConstants.Player.base_xp_to_level,
        -- Shooter system properties
        health_as_ammo = true, -- Shooting costs HP
        projectile_type = "Egg",
        projectile_origin_x = GameConstants.Player.projectile_origin_x or 0,
        projectile_origin_y = GameConstants.Player.projectile_origin_y or 0,
        projectile_origin_z = GameConstants.Player.projectile_origin_z or 0,
        muzzle_flash_offsets = GameConstants.Player.muzzle_flash_offsets,
        muzzle_flash_colors = GameConstants.Player.muzzle_flash_colors,
        shoot_cooldown_duration = GameConstants.Player.fire_rate,
        -- Health regen properties
        regen_trigger_field = "time_since_shot", -- Trigger for regen
        overflow_banking = true,                 -- Bank overflow HP
        -- Visual properties
        outline_color = GameConstants.Player.outline_color,
        sort_offset_y = GameConstants.Player.sort_offset_y,
        mutations = GameConstants.Player.mutations
    }

    -- Create entity with shadow tag (shadow auto-spawned)
    return EntityUtils.spawn_entity(
        world,
        "player,controllable,map_collidable,collidable,velocity,acceleration,health,shooter,health_regen,timers,drawable,animatable,spotlight,sprite,shadow,middleground",
        player)
end

return Player

:: src/entities/projectile.lua
-- Projectile entity factory (Type Object pattern)
-- All projectile types are defined as pure data in GameConstants.Projectile
-- This factory simply instantiates entities from their type config
local GameConstants = require("src/game/game_config")
local EntityUtils = require("src/utils/entity_utils")
local HitboxUtils = require("src/utils/hitbox_utils")
local Particles = require("src/systems/particles")
local Projectile = {}

-- Unified spawn function using Type Object pattern
-- @param world - ECS world
-- @param x, y - spawn position
-- @param dx, dy - direction vector (normalized)
-- @param projectile_type - type key in GameConstants.Projectile (default: "Egg")
-- @param instance_data - optional table with instance-specific overrides
function Projectile.spawn(world, x, y, dx, dy, projectile_type, instance_data)
    projectile_type = projectile_type or "Egg"
    instance_data = instance_data or {}

    local config = GameConstants.Projectile[projectile_type]
    if not config then
        Log.error("Attempted to spawn unknown projectile type: "..tostring(projectile_type))
        return nil
    end

    local direction = EntityUtils.get_direction_name(dx, dy)

    -- 1. Base identity and physics state
    local projectile = {
        type = config.entity_type or "Projectile",
        projectile_type = projectile_type,
        x = x,
        y = y,
        direction = direction,
        dir_x = dx,
        dir_y = dy,
        sub_x = 0,
        sub_y = 0,
    }
    -- 2. Bulk copy all non-table values from config (stats, bounds, offsets)
    for k, v in pairs(config) do
        if type(v) ~= "table" then
            projectile[k] = v
        end
    end

    -- 2b. Apply instance-specific overrides EARLY to ensure derived stats (velocity) use correct values
    for k, v in pairs(instance_data) do
        projectile[k] = v
    end

    -- 2c. Recalculate velocity with final speed
    if projectile.speed then
        projectile.vel_x = dx * projectile.speed
        projectile.vel_y = dy * projectile.speed
    end

    -- 2d. Initialize Z-axis data (simulated height)
    projectile.z = instance_data.z or projectile.z or 8 -- Default start height
    projectile.age = 0
    projectile.max_age = instance_data.lifetime or 60
    projectile.vel_z = 0 -- Start with no vertical velocity (horizontal flight)

    -- Calculate gravity to drop from z to 0 in the last 25% of lifetime
    -- T_drop = max_age * 0.25
    -- 0 = z0 + 0*t + 0.5*g*t^2  => g = -2*z0 / t^2
    local drop_duration = projectile.max_age * 0.25
    if drop_duration < 1 then drop_duration = 1 end -- Prevent division by zero
    projectile.gravity_z = (-2 * projectile.z) / (drop_duration * drop_duration)

    -- 3. Static table references
    projectile.hitboxes = config.hitboxes
    projectile.animations = config.animations
    projectile.palette_swaps = config.palette_swaps
    projectile.sprite_index_offsets = config.sprite_index_offsets
    projectile.shadow_offsets_y = config.shadow_offsets_y
    projectile.shadow_offsets_x = config.shadow_offsets_x
    projectile.shadow_widths = config.shadow_widths
    projectile.shadow_heights = config.shadow_heights

    -- 4. Contextual initialization
    if projectile.sprite_index_offsets and direction then
        projectile.sprite_index = projectile.sprite_index_offsets[direction]
    end

    -- 5. Apply instance-specific overrides
    for k, v in pairs(instance_data) do
        projectile[k] = v
    end

    -- 6.Create entity with tags from config
    return EntityUtils.spawn_entity(world, config.tags, projectile)
end

-- Spawn projectile from shooter's configured origin point
-- shooter.projectile_origin_x/y are offsets from entity position
-- shooter.projectile_origin_z is the elevation for visual height
function Projectile.spawn_from_origin(world, shooter, dx, dy, projectile_type, instance_data)
    local projectile_config = GameConstants.Projectile[projectile_type or "Egg"]

    local origin_x, origin_y
    if shooter.projectile_origin_x then
        origin_x = shooter.x + shooter.projectile_origin_x
        origin_y = shooter.y + (shooter.projectile_origin_y or 0)
    else
        -- Default to hitbox center (Ground-relative)
        local hb = HitboxUtils.get_hitbox(shooter)
        local z = shooter.z or 0
        origin_x = hb.x + hb.w / 2
        origin_y = (hb.y + hb.h / 2) + z -- Convert visual Y back to ground Y
    end

    -- Offset by half projectile size to center it on origin
    local spawn_x = origin_x - (projectile_config.width / 2)
    local spawn_y = origin_y - (projectile_config.height / 2)

    -- Z elevation for all shots (visual height)
    -- Default to shooter defined z, or shooter's own z, or 0
    local projectile_z = shooter.projectile_origin_z or shooter.z or 0

    instance_data = instance_data or {}
    instance_data.z = projectile_z

    -- Flag vertical shots (up/down) for different landing behavior
    -- Vertical: shadow moves toward sprite; Horizontal: sprite moves toward shadow
    -- Use threshold check in case dx/dy are floats
    local is_vertical = (abs(dy) > 0.1) and (abs(dx) < 0.1)
    instance_data.vertical_shot = is_vertical

    -- Muzzle flash particles at directional offset
    local direction = EntityUtils.get_direction_name(dx, dy)
    local flash_x, flash_y = origin_x, origin_y - projectile_z

    -- Use directional muzzle flash offsets if available
    if shooter.muzzle_flash_offsets and direction then
        local offset = shooter.muzzle_flash_offsets[direction]
        if offset then
            flash_x = shooter.x + offset.x
            flash_y = shooter.y + offset.y - projectile_z
        end
    end
    Particles.spawn_burst(flash_x, flash_y, "muzzle_flash", nil, shooter.muzzle_flash_colors)

    return Projectile.spawn(world, spawn_x, spawn_y, dx, dy, projectile_type, instance_data)
end

return Projectile

:: src/entities/shadow.lua
-- Shadow entity factory
local Shadow = {}

function Shadow.spawn(world, parent)
    local shadow = {
        type = "Shadow",
        parent = parent,
        x = parent.x,
        y = parent.y,
        w = parent.width or 16,
        h = parent.height or 8,
        -- Initial properties copied from parent
        shadow_offset_y = parent.shadow_offset_y or 0,
        shadow_offset_x = parent.shadow_offset_x or 0,
        shadow_offsets_y = parent.shadow_offsets_y,
        shadow_offsets_x = parent.shadow_offsets_x,
        shadow_width = parent.shadow_width,
        shadow_height = parent.shadow_height,
        shadow_widths = parent.shadow_widths,
        shadow_heights = parent.shadow_heights,
    }

    local tags = "shadow_sync,drawable_shadow,background"
    local ent = world.ent(tags, shadow)
    parent.shadow_entity = ent
    return ent
end

return Shadow

:: src/game/config/collision.lua
-- Collision configuration: layers, masks, entity mappings

local CollisionLayers = {
   PLAYER = 1,            -- 0b000001
   ENEMY = 2,             -- 0b000010
   PLAYER_PROJECTILE = 4, -- 0b000100
   ENEMY_PROJECTILE = 8,  -- 0b001000
   PICKUP = 16,           -- 0b010000
   WORLD = 32,            -- 0b100000
   OBSTACLE = 64,         -- 0b1000000
   EXPLOSION = 128,       -- 0b10000000
   MINION = 256,          -- 0b100000000 (friendly minions - don't collide with enemies)
}

-- Shorthand aliases for readability
local L = CollisionLayers

-- What each layer can collide with (bitmask)
local CollisionMasks = {
   [L.PLAYER]            = L.ENEMY + L.ENEMY_PROJECTILE + L.PICKUP + L.WORLD + L.OBSTACLE + L.EXPLOSION,
   [L.ENEMY]             = L.PLAYER + L.PLAYER_PROJECTILE + L.WORLD + L.OBSTACLE + L.EXPLOSION + L.MINION,
   [L.PLAYER_PROJECTILE] = L.ENEMY + L.WORLD + L.OBSTACLE,
   [L.ENEMY_PROJECTILE]  = L.PLAYER + L.WORLD + L.OBSTACLE,
   [L.PICKUP]            = L.PLAYER + L.PICKUP,
   [L.WORLD]             = L.PLAYER + L.ENEMY + L.PLAYER_PROJECTILE + L.ENEMY_PROJECTILE + L.OBSTACLE + L.MINION,
   [L.OBSTACLE]          = L.PLAYER + L.ENEMY + L.PLAYER_PROJECTILE + L.ENEMY_PROJECTILE + L.WORLD + L.EXPLOSION,
   [L.EXPLOSION]         = L.PLAYER + L.ENEMY + L.OBSTACLE,
   [L.MINION]            = L.ENEMY + L.WORLD + L.OBSTACLE,
}

-- Entity type to collision layer mapping
local EntityCollisionLayer = {
   Player = CollisionLayers.PLAYER,
   Enemy = CollisionLayers.ENEMY,
   Projectile = CollisionLayers.PLAYER_PROJECTILE,
   MeleeHitbox = CollisionLayers.PLAYER_PROJECTILE,
   EnemyProjectile = CollisionLayers.ENEMY_PROJECTILE,

   HealthPickup = CollisionLayers.PICKUP,
   Coin = CollisionLayers.PICKUP,
   Key = CollisionLayers.PICKUP,
   Bomb = CollisionLayers.PICKUP,
   Rock = CollisionLayers.OBSTACLE,
   Destructible = CollisionLayers.OBSTACLE,
   Chest = CollisionLayers.OBSTACLE,
   LockedChest = CollisionLayers.OBSTACLE,
   ShopItem = CollisionLayers.OBSTACLE,
   Explosion = CollisionLayers.EXPLOSION,
   Chick = CollisionLayers.MINION,
   Egg = CollisionLayers.MINION,
}

return {
   CollisionLayers = CollisionLayers,
   CollisionMasks = CollisionMasks,
   EntityCollisionLayer = EntityCollisionLayer,
}

:: src/game/config/controls.lua
-- Controls and input configuration

local buttons = {
   -- first stick
   left = 0,
   right = 1,
   up = 2,
   down = 3,
   o = 4,
   x = 5,
   menu = 6,
   reserved = 7,
   -- second stick
   left2 = 8,
   right2 = 9,
   up2 = 10,
   down2 = 11,
   o2 = 12,
   x2 = 13,
   sl2 = 14,
   sr2 = 15,
}

local controls = {
   attack = buttons.o,
   place_bomb = buttons.x,
   aim_up = buttons.up,
   aim_down = buttons.down,
   aim_left = buttons.left,
   aim_right = buttons.right,
   move_up = buttons.up2,
   move_down = buttons.down2,
   move_left = buttons.left2,
   move_right = buttons.right2,
}

return {
   buttons = buttons,
   controls = controls,
}

:: src/game/config/entities.lua
-- Entity configurations: Enemy, Minion, Projectile, Pickup, Obstacle

return {
   Projectile = {
      Egg = {
         entity_type = "Projectile",
         tags = "projectile,velocity,map_collidable,collidable,drawable,animatable,shadow,middleground",
         owner = "player",
         speed = 0,
         knockback = 0,
         width = 16,
         height = 16,
         hitboxes = {
            down  = {w = 6, h = 12, ox = 4, oy = 4},
            up    = {w = 6, h = 12, ox = 4, oy = 2},
            right = {w = 10, h = 6, ox = 3, oy = 5},
            left  = {w = 10, h = 6, ox = 3, oy = 5},
         },
         sprite_index_offsets = {
            down = 26,
            right = 25,
            left = 25,
            up = 26,
         },
         animations = {
            down = {
               indices = {26, 26},
               durations = {8, 8},
               flips = {{x = false, y = false}, {x = true, y = false}}
            },
            up = {
               indices = {26, 26},
               durations = {8, 8},
               flips = {{x = false, y = false}, {x = true, y = false}}
            },
            right = {
               indices = {25, 25},
               durations = {8, 8},
               flips = {{x = false, y = false}, {x = false, y = true}}
            },
            left = {
               indices = {25, 25},
               durations = {8, 8},
               flips = {{x = false, y = false}, {x = false, y = true}}
            },
         },
         shadow_offset_y = 4,
         shadow_height = 4,
         shadow_width = 4,
      },
      EnemyBullet = {
         entity_type = "EnemyProjectile",
         tags = "projectile,velocity,map_collidable,collidable,drawable,animatable,shadow,middleground",
         owner = "enemy",
         speed = 1.5,
         damage = 10,
         width = 16,
         height = 16,
         hitbox_width = 8,
         hitbox_height = 8,
         hitbox_offset_x = 4,
         hitbox_offset_y = 4,
         sprite_index_offsets = {
            down = 54,
            right = 54,
            left = 54,
            up = 54,
         },
         animations = {
            idle = {indices = {54, 55}, durations = {8, 8}}
         },
         sprite_offset_y = 5,
         shadow_offset_y = 3,
         shadow_width = 4,
         z = 6,
      },
   },
   Enemy = {
      Skulker = {
         entity_type = "Enemy",
         tags = "enemy,timers,velocity,map_collidable,collidable,health,drawable,animatable,sprite,shadow,middleground",
         hp = 20,
         xp_value = 10,
         max_speed = 0.5,
         contact_damage = 10,
         vision_range = 120,
         wander_radius = 40,
         wander_speed_mult = 0.6,
         wander_pause_min = 20,
         wander_pause_max = 60,
         sprite_index_offsets = {
            down = 48,
            right = 48,
            left = 48,
            up = 48,
         },
         animations = {
            death = {indices = {48}, durations = {30}}
         },
         width = 16,
         height = 16,
         hitbox_width = 12,
         hitbox_height = 10,
         hitbox_offset_x = 2,
         hitbox_offset_y = 3,
         shadow_offset_y = 2,
         shadow_width = 15,
         shadow_height = 6,
         outline_color = 1,
      },
      Shooter = {
         entity_type = "Enemy",
         tags =
         "enemy,shooter,timers,velocity,map_collidable,collidable,health,drawable,animatable,sprite,shadow,middleground",
         hp = 30,
         xp_value = 15,
         max_speed = 0.3,
         shot_speed = 1.5,
         damage = 10,
         range = 200,
         contact_damage = 10,
         shoot_delay = 120,
         vision_range = 200,
         is_shooter = true,
         wander_radius = 48,
         wander_speed_mult = 0.5,
         wander_pause_min = 30,
         wander_pause_max = 90,
         sprite_index_offsets = {
            down = 46,
            right = 46,
            left = 46,
            up = 46,
         },
         width = 16,
         height = 16,
         hitbox_width = 12,
         hitbox_height = 10,
         hitbox_offset_x = 2,
         hitbox_offset_y = 3,
         animations = {
            idle = {indices = {46, 47}, durations = {30, 30}},
            death = {indices = {46}, durations = {30}}
         },
         shadow_offset_y = 2,
         shadow_width = 17,
         shadow_height = 6,
         outline_color = 1,
         -- Muzzle flash (green magic)
         muzzle_flash_offsets = {
            down  = {x = 8, y = 14},
            up    = {x = 8, y = 2},
            right = {x = 14, y = 8},
            left  = {x = 2, y = 8},
         },
         muzzle_flash_colors = {11, 3, 26}, -- green, dark green, purple
      },
      Skull = {
         entity_type = "Enemy",
         tags = "skull,enemy,timers,velocity,collidable,health,drawable,animatable,shadow,middleground,flying",
         hp = 100,
         xp_value = 50,
         max_speed = 1,
         contact_damage = 100,
         drop_chance = 0.5,
         loot_rolls = 2,
         use_diverse_loot = true,
         sprite_index_offsets = {
            down = 53,
            right = 53,
            left = 53,
            up = 53,
         },
         animations = {
            down = {
               idle = {indices = {53}, durations = {30}},
               death = {indices = {53}, durations = {30}}
            },
            up = {
               idle = {indices = {53}, durations = {30}},
               death = {indices = {53}, durations = {30}}
            },
            left = {
               idle = {indices = {53}, durations = {30}},
               death = {indices = {53}, durations = {30}}
            },
            right = {
               idle = {indices = {53}, durations = {30}, flip = true},
               death = {indices = {53}, durations = {30}, flip = true}
            }
         },
         width = 16,
         height = 16,
         hitbox_width = 16,
         hitbox_height = 16,
         hitbox_offset_x = 0,
         hitbox_offset_y = 0,
         shadow_offset_y = 5,
         shadow_width = 13,
         outline_color = 1,
      },
      Dasher = {
         entity_type = "Enemy",
         tags = "enemy,timers,velocity,map_collidable,collidable,health,drawable,animatable,sprite,shadow,middleground",
         hp = 60,
         xp_value = 25,
         max_speed = 0.2,
         contact_damage = 15,
         vision_range = 150,
         windup_duration = 60,
         stun_duration = 120,
         dash_speed_multiplier = 10,
         sprite_index_offsets = {
            down = 51,
            right = 51,
            left = 51,
            up = 51,
         },
         sprite_shell = 50,
         width = 16,
         height = 16,
         hitbox_width = 12,
         hitbox_height = 10,
         hitbox_offset_x = 2,
         hitbox_offset_y = 3,
         animations = {
            down = {
               idle      = {indices = {51}, durations = {30}},
               walking   = {indices = {51, 52}, durations = {8, 8}},
               attacking = {indices = {50}, durations = {10}, loop = true},
               death     = {indices = {50}, durations = {30}}
            },
            up = {
               idle      = {indices = {51}, durations = {30}},
               walking   = {indices = {51, 52}, durations = {8, 8}},
               attacking = {indices = {50}, durations = {10}, loop = true},
               death     = {indices = {50}, durations = {30}}
            },
            right = {
               idle      = {indices = {51}, durations = {30}, flip = true},
               walking   = {indices = {51, 52}, durations = {8, 8}, flip = true},
               attacking = {indices = {50}, durations = {10}, loop = true, flip = true},
               death     = {indices = {50}, durations = {30}, flip = true}
            },
            left = {
               idle      = {indices = {51}, durations = {30}, flip = true},
               walking   = {indices = {51, 52}, durations = {8, 8}, flip = true},
               attacking = {indices = {50}, durations = {10}, loop = true, flip = true},
               death     = {indices = {50}, durations = {30}, flip = true}
            }
         },
         shadow_offset_y = 3,
         shadow_width = 17,
         outline_color = 1,
      },
      GreenWitch = {
         entity_type = "Enemy",
         tags =
         "enemy,boss,shooter,timers,velocity,map_collidable,collidable,health,drawable,animatable,sprite,shadow,middleground",
         hp = 600,
         xp_value = 100,
         max_speed = 2,
         contact_damage = 20,
         -- Phase thresholds (fraction of max HP)
         phase2_threshold = 0.66, -- Switch at 66% HP
         phase3_threshold = 0.33, -- Switch at 33% HP
         -- Combat stats (reuses EnemyBullet projectile)
         is_shooter = true,       -- Required for EnemyBullet projectile type
         shoot_delay = 60,
         shot_speed = 3,          -- Projectile speed
         vision_range = 300,
         dash_speed_multiplier = 4,
         stun_duration = 60,
         -- Minion summoning
         summon_cooldown = 180,
         summon_type = "Skulker",
         summon_count = 2,
         -- Visuals
         width = 24,
         height = 32,
         hitbox_width = 18,
         hitbox_height = 20,
         hitbox_offset_x = 3,
         hitbox_offset_y = 2,
         sprite_index_offsets = {
            down = 208,
            right = 208,
            left = 208,
            up = 208,
         },
         animations = {
            down = {
               idle      = {indices = {208}, durations = {30}},
               walking   = {indices = {208}, durations = {8}},
               attacking = {indices = {209}, durations = {30}},
               death     = {indices = {208}, durations = {30}}
            },
            up = {
               idle      = {indices = {208}, durations = {30}},
               walking   = {indices = {208}, durations = {8}},
               attacking = {indices = {209}, durations = {30}},
               death     = {indices = {208}, durations = {30}}
            },
            right = {
               idle      = {indices = {208}, durations = {30}, flip = true},
               walking   = {indices = {208}, durations = {8}, flip = true},
               attacking = {indices = {209}, durations = {30}, flip = true},
               death     = {indices = {208}, durations = {30}, flip = true}
            },
            left = {
               idle      = {indices = {208}, durations = {30}},
               walking   = {indices = {208}, durations = {8}},
               attacking = {indices = {209}, durations = {30}},
               death     = {indices = {208}, durations = {30}}
            }
         },
         shadow_offset_y = 6,
         shadow_width = 22,
         outline_color = 1,
         -- Muzzle flash (dark magic)
         muzzle_flash_offsets = {
            down  = {x = 12, y = 28},
            up    = {x = 12, y = 4},
            right = {x = 22, y = 16},
            left  = {x = 2, y = 16},
         },
         muzzle_flash_colors = {26, 27, 8}, -- purple, dark purple, red
      },
   },
   -- Player-summoned minions
   Minion = {
      Chick = {
         entity_type = "Chick",
         tags = "minion,timers,health,velocity,map_collidable,collidable,drawable,animatable,sprite,shadow,middleground",
         hp = 20,
         hp_drain_rate = 60,    -- Frames between each 1 HP loss (60 = 1 HP/second)
         food_seek_range = 120, -- Range to detect yolk splats
         food_heal_amount = 5,  -- HP restored per yolk splat eaten
         vision_range = 160,    -- Range to detect and chase enemies (160 = ~10 tiles)
         chase_speed_mult = 2,  -- Speed multiplier when chasing (1.2 = 120%)
         attack_damage = 3,     -- Damage per attack
         attack_cooldown = 30,  -- Frames between attacks (60 = 1 attack/second)
         attack_knockback = 3,  -- Knockback applied to chick after attack
         attack_range = 16,     -- Distance to trigger attack
         max_speed = 1,
         wander_radius = 32,
         wander_speed_mult = 0.8,
         wander_pause_min = 30,
         wander_pause_max = 90,
         follow_trigger_dist = 100, -- Distance to start following player
         follow_stop_dist = 50,     -- Distance to stop following
         follow_speed_mult = 3,     -- Speed multiplier when following (catch up)
         sprite_index_offsets = {
            down = 31,
            right = 31,
            left = 31,
            up = 31,
         },
         width = 16,
         height = 16,
         hitbox_width = 10,
         hitbox_height = 10,
         hitbox_offset_x = 3,
         hitbox_offset_y = 3,
         shadow_offset_x = -2,
         shadow_offset_y = -2,
         shadow_width = 8,
         animations = {
            down = {
               idle    = {indices = {33}, durations = {30}},
               walking = {indices = {31, 32}, durations = {8, 8}},
               death   = {indices = {33}, durations = {30}}
            },
            up = {
               idle    = {indices = {33}, durations = {30}},
               walking = {indices = {31, 32}, durations = {8, 8}},
               death   = {indices = {33}, durations = {30}}
            },
            right = {
               idle    = {indices = {33}, durations = {30}},
               walking = {indices = {31, 32}, durations = {8, 8}},
               death   = {indices = {33}, durations = {30}}
            },
            left = {
               idle    = {indices = {33}, durations = {30}, flip = true},
               walking = {indices = {31, 32}, durations = {8, 8}, flip = true},
               death   = {indices = {33}, durations = {30}, flip = true}
            }
         },
      },
      YolkSplat = {
         entity_type = "YolkSplat",
         tags = "yolk_splat,drawable,sprite,shadow,middleground,timers,map_collidable",
         -- map_collidable needed so it doesn't fall through floor if we use gravity, though usually splats are flat.
         -- Actually, simple splats might not need map_collidable if they are static.
         -- But minion/chick needs to find it.
         width = 16,
         height = 16,
         sprite_index = 36, -- Placeholder sprite index for Splat (needs to be set correctly)
         -- Let's use a "blob" sprite if available, or just a placeholder. 230 is arbitrary, will need to be checked.
         -- Actually, let's look for a suitable sprite index or use a generic one.
         -- Using 28 (Egg) as placeholder for now if unsure, but user said "Visual: A gross, yellow/orange puddle".
         -- I'll use 28 for now and comment it needs update.
         -- WAIT, I should check if there's a convention.
         -- Let's just define it, sprite_index can be fixed later.
         hitbox_width = 12,
         hitbox_height = 12,
         hitbox_offset_x = 2,
         hitbox_offset_y = 2,
         shadow_offset_y = 4,
         shadow_width = 10,
         outline_color = nil,
      },
      Egg = {
         entity_type = "Egg",
         tags = "minion,drawable,sprite,shadow,middleground,timers",
         width = 16,
         height = 16,
         sprite_index = 28, -- Initial egg sprite
         hitbox_width = 8,
         hitbox_height = 8,
         hitbox_offset_x = 4,
         hitbox_offset_y = 4,
         shadow_offset_y = 4,
         shadow_width = 6,
         -- Hatching animation frames (AI-driven based on hatch_timer progress)
         hatch_frames = {28, 29, 30},
      },
   },
}

:: src/game/config/level_up.lua
-- Level Up Bonus Definitions
-- Each bonus has: category, name, description, and an apply function
local GameConstants = require("src/game/game_config")

local LevelUpConfig = {}

-- Helper to create bonus entries
local function bonus(category, name, description, apply_fn)
   return {category = category, name = name, description = description, apply = apply_fn}
end

-- Player stat bonuses
LevelUpConfig.Player = {
   bonus("Player Stats", "Vitality", "Max HP +20 & Heal", function(p)
      p.max_hp = p.max_hp + 20
      p.hp = math.min(p.hp + 20, p.max_hp)
   end),
   bonus("Player Stats", "Swiftness", "Speed +0.2", function(p)
      p.max_speed = p.max_speed + 0.2
   end),
   bonus("Player Stats", "Hardened Shell", "Damage -10%", function(p)
      p.damage_reduction = (p.damage_reduction or 1.0) * 0.9
   end),
   bonus("Player Stats", "Vampirism", "Lifesteal +10%", function(p)
      p.vampiric_heal = (p.vampiric_heal or 0.3) + 0.1
   end),
   bonus("Player Stats", "Iron Skin", "Invuln +15 fr", function(p)
      p.invulnerability_duration = (p.invulnerability_duration or 120) + 15
   end),
   bonus("Player Stats", "Brawler", "Melee Dmg +5", function(p)
      p.melee_bonus_damage = (p.melee_bonus_damage or 0) + 5
   end),
}

-- Egg projectile bonuses
LevelUpConfig.Egg = {
   bonus("Egg Stats", "Heavy Shell", "Impact Dmg +2", function(p)
      p.impact_damage = (p.impact_damage or GameConstants.Player.dud_damage) + 2
      p.drain_damage = (p.drain_damage or GameConstants.Player.leech_damage) + 2
   end),
   bonus("Egg Stats", "Rapid Fire", "Fire Rate +25%", function(p)
      p.fire_rate = math.max(5, p.fire_rate - 3)
      p.shoot_cooldown_duration = p.fire_rate
   end),
   bonus("Egg Stats", "Long Shot", "Range +40", function(p)
      p.range = p.range + 40
   end),
   bonus("Egg Stats", "Efficiency", "Cost -1%", function(p)
      p.max_hp_to_shot_cost_ratio = math.max(0.01, p.max_hp_to_shot_cost_ratio - 0.01)
   end),
   bonus("Egg Stats", "Sticky Gloop", "Slow +0.5s", function(p)
      p.egg_slow_duration = (p.egg_slow_duration or 60) + 30
      p.egg_slow_factor = math.max(0.1, (p.egg_slow_factor or 0.5) - 0.1)
   end),
}

-- Chick minion bonuses (modifiers stored on player, read by chick AI)
LevelUpConfig.Chick = {
   bonus("Chick Stats", "Alpha Chick", "Chick Dmg +1", function(p)
      p.minion_damage_bonus = (p.minion_damage_bonus or 0) + 1
   end),
   bonus("Chick Stats", "Hyperactive", "Chick Atk Spd +", function(p)
      p.minion_cooldown_reduction = (p.minion_cooldown_reduction or 0) + 5
   end),
   bonus("Chick Stats", "Hunter Sight", "Vision +32", function(p)
      p.minion_vision_bonus = (p.minion_vision_bonus or 0) + 32
   end),
   bonus("Chick Stats", "Durable", "Chick HP +10", function(p)
      p.minion_hp_bonus = (p.minion_hp_bonus or 0) + 10
   end),
}

return LevelUpConfig

:: src/game/config/mutations.lua
-- Mutations configuration

return {
   Mutation = {
      Eggsaggerated = {
         entity_type = "Mutation",
         tags = "mutation,velocity,collidable,drawable,sprite,middleground,shadow",
         width = 32,
         height = 32,
         hitbox_width = 32,
         hitbox_height = 32,
         hitbox_offset_x = 0,
         hitbox_offset_y = 0,
         sprite_index_offsets = {
            down = 58,
            right = 58,
            left = 58,
            up = 58,
         },
         sprite_offset_y = 6,
         shadow_offset_y = 4,
         shadow_width = 6,
         mutation = "Eggsaggerated",
      },
      Broodmother = {
         entity_type = "Mutation",
         tags = "mutation,velocity,collidable,drawable,sprite,middleground,shadow",
         width = 32,
         height = 32,
         hitbox_width = 32,
         hitbox_height = 32,
         hitbox_offset_x = 0,
         hitbox_offset_y = 0,
         sprite_index_offsets = {
            down = 59,
            right = 59,
            left = 59,
            up = 59,
         },
         sprite_offset_y = 6,
         shadow_offset_y = 4,
         shadow_width = 6,
         mutation = "Broodmother",
      },
      Pureblood = {
         entity_type = "Mutation",
         tags = "mutation,velocity,collidable,drawable,sprite,middleground,shadow",
         width = 32,
         height = 32,
         hitbox_width = 32,
         hitbox_height = 32,
         hitbox_offset_x = 0,
         hitbox_offset_y = 0,
         sprite_index_offsets = {
            down = 60,
            right = 60,
            left = 60,
            up = 60,
         },
         sprite_offset_y = 6,
         shadow_offset_y = 4,
         shadow_width = 6,
         mutation = "Pureblood",
      },
   }
}

:: src/game/config/obstacles.lua
-- Obstacles configurations: Rock, Destructible, Chest, LockedChest, ShopItem

return {
   Obstacle = {
      Rock = {
         entity_type = "Rock",
         obstacle = true,
         tags = "obstacle,collidable,drawable,sprite,world_obj,middleground,static",
         width = 16,
         height = 16,
         hitbox_width = 16,
         hitbox_height = 16,
         hitbox_offset_x = 4,
         hitbox_offset_y = 4,
         outline_color = nil,
      },
      Destructible = {
         entity_type = "Destructible",
         obstacle = true,
         destructible = true,
         tags = "obstacle,collidable,drawable,sprite,world_obj,destructible,middleground,static",
         hp = 1,
         width = 16,
         height = 16,
         hitbox_width = 16,
         hitbox_height = 16,
         hitbox_offset_x = 4,
         hitbox_offset_y = 4,
         outline_color = nil,
      },
      Chest = {
         entity_type = "Chest",
         obstacle = true,
         is_chest = true,
         tags = "obstacle,collidable,drawable,sprite,world_obj,chest,middleground,static",
         hp = 1,
         width = 16,
         height = 16,
         hitbox_width = 16,
         hitbox_height = 16,
         hitbox_offset_x = 0,
         hitbox_offset_y = 0,
         outline_color = nil,
         sprite_index = 166, -- Normal chest sprite
         loot_min = 1,       -- Minimum pickup drops
         loot_max = 3,       -- Maximum pickup drops
      },
      LockedChest = {
         entity_type = "LockedChest",
         obstacle = true,
         is_chest = true,
         is_locked = true,
         tags = "obstacle,collidable,drawable,sprite,world_obj,chest,locked,middleground,static",
         hp = 1,
         width = 16,
         height = 16,
         hitbox_width = 16,
         hitbox_height = 16,
         hitbox_offset_x = 0,
         hitbox_offset_y = 0,
         outline_color = nil,
         sprite_index = 167, -- Locked chest sprite
         loot_min = 2,       -- Minimum pickup drops
         loot_max = 6,       -- Maximum pickup drops
         key_cost = 1,       -- Keys required to open
      },
      TreasureChest = {
         entity_type = "TreasureChest",
         obstacle = true,
         is_chest = true,
         tags = "obstacle,collidable,drawable,sprite,world_obj,chest,middleground,static",
         hp = 1,
         width = 32,
         height = 16,
         hitbox_width = 32,
         hitbox_height = 16,
         hitbox_offset_x = 0,
         hitbox_offset_y = 0,
         outline_color = nil,
         sprite_index = 174,      -- Normal chest sprite
         sprite_index_open = 175, -- Open chest sprite
      },
      ShopItem = {
         entity_type = "ShopItem",
         obstacle = true,
         is_shop_item = true,
         tags = "obstacle,collidable,drawable,sprite,world_obj,shop_item,middleground,static",
         width = 16,
         height = 16,
         hitbox_width = 12,
         hitbox_height = 10,
         hitbox_offset_x = 2,
         hitbox_offset_y = 6,
         sprite_index = 58, -- Pedestal sprite (item sprite set at spawn)
         outline_color = nil,
         -- Item properties set at spawn time: item_id, price, apply_fn, item_name, item_sprite
      },
   },
}

:: src/game/config/pickups.lua
-- Pickups configurations: HealthPickup, Coin, Key, Bomb, DNAStrand

return {
   Pickup = {
      HealthPickup = {
         entity_type = "HealthPickup",
         tags = "pickup,collidable,drawable,sprite,background,shadow",
         pickup_effect = "health",
         width = 16,
         height = 16,
         sprite_index = 37,
         hitbox = {w = 12, h = 12, ox = 2, oy = 2},
         shadow_width = 11,
         recovery_amount = 5,
      },
      Coin = {
         entity_type = "Coin",
         tags = "pickup,collidable,drawable,sprite,background,shadow",
         pickup_effect = "coin",
         width = 16,
         height = 16,
         sprite_index = 40,
         hitbox_width = 12,
         hitbox_height = 12,
         hitbox_offset_x = 2,
         hitbox_offset_y = 2,
         shadow_offset_y = 3,
         shadow_width = 11,
         amount = 1,
      },
      Key = {
         entity_type = "Key",
         tags = "pickup,collidable,drawable,sprite,background,shadow",
         pickup_effect = "key",
         width = 16,
         height = 16,
         sprite_index = 39,
         hitbox_width = 12,
         hitbox_height = 12,
         hitbox_offset_x = 2,
         hitbox_offset_y = 2,
         shadow_offset_y = 3,
         shadow_width = 11,
         amount = 1,
      },
      Bomb = {
         entity_type = "Bomb",
         tags = "pickup,collidable,drawable,sprite,background,shadow",
         pickup_effect = "bomb",
         width = 16,
         height = 16,
         sprite_index = 38,
         hitbox_width = 12,
         hitbox_height = 12,
         hitbox_offset_x = 2,
         hitbox_offset_y = 2,
         shadow_offset_y = 3,
         shadow_width = 11,
         amount = 1,
      },
      DNAStrand = {
         entity_type = "DNAStrand",
         tags = "pickup,collidable,drawable,sprite,background,shadow",
         pickup_effect = "xp",
         width = 16,
         height = 16,
         sprite_index = 41, -- DNA helix icon
         hitbox_width = 8,
         hitbox_height = 16,
         hitbox_offset_x = 4,
         hitbox_offset_y = 0,
         shadow_offset_y = 3,
         shadow_width = 11,
         -- xp_amount set at spawn time via instance_data
      },
      Mutation = {
         entity_type = "Mutation",
         tags = "pickup,collidable,drawable,sprite,background,shadow",
         pickup_effect = "mutation", -- Matches logic in pickup_handlers.lua
         width = 32,
         height = 32,
         sprite_index = 58, -- Placeholder, will be overridden by mutation_sprite
         hitbox_width = 32,
         hitbox_height = 32,
         hitbox_offset_x = 0,
         hitbox_offset_y = 0,
         shadow_offset_y = 2,
         shadow_width = 24,
         -- mutation field set via instance_data
      },
   }
}

:: src/game/config/player.lua
-- Player configuration
return {
   invulnerable_time = 120, -- frames
   width = 24,
   height = 32,
   max_health = 100,
   max_hp_to_shot_cost_ratio = 0.05, -- 5 hp per shot
   recovery_percent = 0.8,           -- I don't think we need this anymore
   regen_rate = 0,
   regen_delay = 1.5,
   -- XP System
   starting_level = 1,
   starting_xp = 0,
   base_xp_to_level = 50,         -- XP to reach level 2
   xp_per_level_linear = 25,      -- Linear growth for levels 1-10
   -- Stats
   max_speed = 2,                 -- Movement speed
   shot_speed = 4,
   max_hp_to_damage_ratio = 0.05, -- Damage = max_hp * ratio
   range = 100,                   -- Max distance in pixels
   fire_rate = 15,                -- Frames between shots
   base_knockback = 4,            -- Base knockback applied to all player attacks
   vampiric_heal = 0.3,           -- Heal player for 30% of damage dealt, is this used?
   -- Egg outcome probabilities (single roll, 3 outcomes)
   -- 50% The Dud: 3 Dmg, splats harmlessly
   -- 35% The Hatching: 0 Dmg, spawns Chick
   -- 15% The Leech: 5 Dmg, drops 5 HP glob
   roll_dud_chance = 0.50,
   roll_hatch_chance = 0.35,
   roll_leech_chance = 0.15,

   dud_damage = 3,   -- Damage dealt by "The Dud" (and splat visual)
   leech_damage = 5, -- Damage dealt by "The Leech"
   leech_heal = 5,   -- HP pickup dropped by "The Leech"
   hatch_time = 120, -- Frames for egg to hatch into chick

   -- Sticky Yolk Effect (applied on egg impacts with enemies)
   egg_stun_duration = 12, -- Frames of micro-stun (~0.2s)
   egg_slow_duration = 60, -- Frames of 50% slow (~1s)
   egg_slow_factor = 0.5,  -- Speed multiplier during slow

   -- Face-Hugger (chick attachment on direct hit)
   chick_attach_duration = 60, -- Frames chick stays attached (~1s)

   -- Yolk Splat Settings (Wall/Rock impacts)
   yolk_splat_duration = 300, -- 5 seconds
   yolk_slow_factor = 0.7,    -- Enemies move at 70% speed
   projectile_origin_x = 12,  -- X offset from sprite left edge
   projectile_origin_y = 24,  -- Y offset from sprite top edge
   projectile_origin_z = 16,  -- Z elevation for horizontal shots
   -- Muzzle flash offsets per direction (from sprite top-left)
   muzzle_flash_offsets = {
      down  = {x = 12, y = 30},
      up    = {x = 12, y = 18},
      right = {x = 24, y = 24},
      left  = {x = 4, y = 24},
   },
   muzzle_flash_colors = {7, 6, 12}, -- white, light gray, light blue
   -- Inventory
   coins = 0,
   keys = 1,
   bombs = 2,
   animations = {
      down = {
         idle      = {indices = {1, 10, 1, 2}, durations = {20, 20, 20, 20}},
         walking   = {indices = {3, 4}, durations = {15, 15}},
         attacking = {indices = {1, 5}, durations = {4, 15}},
         hurt      = {indices = {8}, durations = {30}},
         death     = {indices = {9}, durations = {8}}
      },
      right = {
         idle      = {indices = {13, 11, 12, 11}, durations = {20, 20, 20, 20}},
         walking   = {indices = {14, 15}, durations = {8, 8}},
         attacking = {indices = {11, 16}, durations = {4, 15}},
         hurt      = {indices = {19}, durations = {30}},
         death     = {indices = {9}, durations = {8}}
      },
      up = {
         idle      = {indices = {20, 20, 21, 20}, durations = {20, 20, 20, 20}},
         walking   = {indices = {22, 23}, durations = {8, 8}},
         attacking = {indices = {20, 24}, durations = {8, 15}},
         hurt      = {indices = {8}, durations = {30}},
         death     = {indices = {9}, durations = {8}}
      },
      left = {
         idle      = {indices = {13, 11, 12, 11}, durations = {20, 20, 20, 20}, flip = true},
         walking   = {indices = {14, 15}, durations = {8, 8}, flip = true},
         attacking = {indices = {11, 16}, durations = {4, 15}, flip = true},
         hurt      = {indices = {19}, durations = {30}, flip = true},
         death     = {indices = {9}, durations = {8}, flip = true}
      }
   },
   sprite_index_offsets = {
      down = 1,
      right = 10,
      left = 10,
      up = 18,
   },
   shadow_offset_x = 0,
   shadow_offset_y = 3,
   shadow_width = 15,
   shadow_height = 6,
   outline_color = 1,
   sort_offset_y = 38,
   height_z = 25, -- Vertical collision height (human body, projectiles above this miss)
   -- Per-direction hitboxes (use 'hitbox = {w, h, ox, oy}' for same hitbox all directions)
   hitboxes = {
      down  = {w = 10, h = 12, ox = 7, oy = 18},
      up    = {w = 10, h = 12, ox = 7, oy = 18},
      right = {w = 10, h = 12, ox = 7, oy = 18},
      left  = {w = 10, h = 12, ox = 7, oy = 18},
   },
   melee_cost = 2,
   melee_cooldown = 60,
   melee_sprite = 57,
   melee_range = 14,
   melee_hitboxes = {
      down  = {w = 14, h = 16, ox = 3, oy = 16},
      up    = {w = 12, h = 12, ox = 4, oy = 10},
      right = {w = 16, h = 12, ox = 5, oy = 20},
      left  = {w = 16, h = 12, ox = 4, oy = 18},
   },
   melee_width = 9,
   melee_height = 16,
   melee_duration = 15,
   melee_knockback = 6,
   mutations = {
      Eggsaggerated = 0,
      Broodmother = 0,
      Pureblood = 0,
   },
}

:: src/game/config/shop_items.lua
-- Shop Item Pool Configuration
-- Defines purchasable items available in shop rooms

local ShopItems = {}

-- All purchasable items
ShopItems.pool = {
   {
      id = "heart_container",
      name = "Heart Container",
      description = "+20 Max HP",
      price = 15,
      sprite = 56,
      apply = function(player)
         player.max_hp = player.max_hp + 20
         player.hp = math.min(player.hp + 20, player.max_hp)
      end
   },
   {
      id = "bomb_pack",
      name = "Bomb Pack",
      description = "+3 Bombs",
      price = 5,
      sprite = 38,
      apply = function(player)
         player.bombs = (player.bombs or 0) + 3
      end
   },
   {
      id = "key_ring",
      name = "Key Ring",
      description = "+2 Keys",
      price = 8,
      sprite = 39,
      apply = function(player)
         player.keys = (player.keys or 0) + 2
      end
   },
}

-- Pick N unique random items from pool
function ShopItems.pick_random_items(count)
   local available = {}
   for _, item in ipairs(ShopItems.pool) do
      add(available, item)
   end

   local selected = {}
   for i = 1, count do
      if #available == 0 then break end
      local idx = flr(rnd(#available)) + 1
      add(selected, available[idx])
      deli(available, idx)
   end

   return selected
end

return ShopItems

:: src/game/config/tiles.lua
-- Tile and world constants
-- Global tile IDs, autotiling, room features

SCREEN_WIDTH = 480
SCREEN_HEIGHT = 270
GRID_SIZE = 16
EMPTY_TILE = 0
DOOR_OPEN_TILE = 86
DOOR_BLOCKED_TILE = 71
WALL_TILE = 140

-- Lighting and Shadow constants
LIGHTING_SPOTLIGHT_COLOR = 33
LIGHTING_SHADOW_COLOR = 32

-- Autotiling constants
WALL_TILE_CORNER_TL = 64                             -- A: top-left corner
WALL_TILE_CORNER_TR = 68                             -- B: top-right corner
WALL_TILE_CORNER_BL = 96                             -- C: bottom-left corner
WALL_TILE_CORNER_BR = 100                            -- D: bottom-right corner
WALL_TILE_HORIZONTAL = {65, 66, 67, 97, 98, 99, 121} -- H: horizontal wall variants
WALL_TILE_VERTICAL = {72, 80, 88, 76, 84, 92}        -- V: vertical wall variants
-- Inner corner tiles (for walls between adjacent rooms with 2 diagonal floors)
WALL_TILE_INNER_TOP = 137                            -- 2 diagonals on top (TL + TR): inner corner pointing down
WALL_TILE_INNER_BOTTOM = 145                         -- 2 diagonals on bottom (BL + BR): inner corner pointing up
WALL_TILE_INNER_RIGHT = 116                          -- 2 diagonals on right (TR + BR): inner corner pointing left
WALL_TILE_INNER_LEFT = 115                           -- 2 diagonals on left (TL + BL): inner corner pointing right
-- TODO: readd floor tiles when floor autotiling is implemented
FLOOR_TILES = {73}                                   -- , 74, 75, 81, 82, 83, 89, 90, 91}   -- F: floor variants

-- Door frame tiles
DOOR_FRAME_H_TOP = {77, 93, 123, 124, 148, 153} -- Horizontal door top frame
DOOR_FRAME_H_BOTTOM = {107, 108, 129, 132}      -- Horizontal door bottom frame
DOOR_FRAME_V_LEFT = {117, 122, 138, 141, 146}   -- Vertical door left frame
DOOR_FRAME_V_RIGHT = {114, 120, 136, 139, 144}  -- Vertical door right frame

-- Room feature tiles (for layout carving)
ROCK_TILES = {134, 135, 142, 143}         -- R: solid rock obstacles
PIT_TILE = 85                             -- P: pit (blocks walking, not projectiles)
DESTRUCTIBLE_TILES = {150, 151, 158, 159} -- D: breakable obstacles
CHEST_TILE = 166                          -- C: normal chest
LOCKED_CHEST_TILE = 167                   -- L: locked chest
TREASURE_CHEST_TILE = 174                 -- T: treasure chest
NO_SPAWN_FEATURE = 87

-- Feature type flags (for collision logic)
SOLID_FLAG = 0
FEATURE_FLAG_PIT = 1 -- allows projectiles to pass
NO_SPAWN_FLAG = 2

-- Collision system constants
TILE_EDGE_TOLERANCE = 0.001    -- Small buffer to prevent floating-point edge cases
DOOR_GUIDANCE_MULTIPLIER = 1.5 -- Speed multiplier for nudging player toward doors
SPATIAL_GRID_CELL_SIZE = 64    -- Spatial partitioning cell size in pixels

-- Skull spawn timers
SKULL_SPAWN_TIMER = 420
SKULL_SPAWN_LOCKED_TIMER = 1800

-- Spawner indicator sprite
SPAWNER_INDICATOR_SPRITE = 45

-- Broken egg sprite constant
BROKEN_EGG_SPRITE = 27
-- Note: These are globals, no return needed

:: src/game/config/ui.lua
-- UI configurations: Hud, Minimap

local MutationsConfig = require("src/game/config/mutations")

return {
   Hud = {
      inventory = {
         x = 26,             -- Base X position from left
         y = 249,            -- Base Y position from top (lowered to make room for hearts)
         spacing_x = 30,     -- Horizontal spacing between items
         icon_size = 11,     -- Size of icons
         text_offset_x = 14, -- Text centered below icon
         text_offset_y = 2,  -- Text below icon (icon_size + 1px gap)
         text_color = 1,     -- White text
         shadow_color = 0,   -- Black shadow/outline
         sprites = {
            coins = 197,
            bombs = 196,
            keys = 198,
         }
      },
      mutations = {
         x = 234,            -- Base X position from left
         y = 249,            -- Base Y position from top (lowered to make room for hearts)
         spacing_x = 50,     -- Horizontal spacing between items
         icon_size = 11,     -- Size of icons
         text_offset_x = 20, -- Text centered below icon
         text_offset_y = 2,  -- Text below icon (icon_size + 1px gap)
         text_color = 1,     -- White text
         shadow_color = 0,   -- Black shadow/outline
         sprites = {
            Eggsaggerated = 28,
            Broodmother = 31,
            Pureblood = 57,
         }
      },
      combat_timer = {
         x = 10,
         y = 80,    -- Moved down
         color = 8, -- Red
      },
      health_bar = {
         x = 30,                  -- Centered in left half (240px wide): (240 - 10*18)/2 = 30
         y = 7,
         heart_sprite = 42,       -- Full Heart
         half_heart_sprite = 43,  -- Half Heart
         empty_heart_sprite = 56, -- Empty Heart
         heart_size = 16,         -- 16x16 sprite
         heart_spacing = 18,      -- 16 + 2px gap
         max_per_row = 10,        -- Max 10 hearts per row (~180px width)
         -- Heart sprite base colors (in luminance order): 7, 8, 24, 2
         -- Each palette maps: {color_for_7, color_for_8, color_for_24, color_for_2}
         colors = {
            normal = nil,               -- No swap needed (use original red)
            empty = nil,                -- Empty sprite (56) has its own colors
            overheal = {7, 28, 12, 16}, -- Blue hue equivalent
         }
      },
      xp_bar = {
         x = 254,          -- Horizontal position from left screen edge
         y = 10,           -- At screen bottom (overlap with wall)
         width = 200,      -- Bar width
         height = 9,       -- Bar height
         bg_color = 1,     -- Black background
         fill_color = 11,  -- Yellow fill
         border_color = 5, -- Dark gray border
         text_color = 7,   -- White level text
      },
   },
   Minimap = {
      cell_size = 11,        -- Size of each room cell in pixels (10x10 sprite + padding)
      padding = 1,           -- Padding between cells
      margin_x = 26,         -- Distance from right screen edge
      margin_y = 24,         -- Distance from top screen edge (default position)
      margin_y_bottom = 24,  -- Distance from bottom screen edge (alternate position)
      viewport_w = 5,        -- Max visible rooms horizontally
      viewport_h = 5,        -- Max visible rooms vertically
      border_color = 5,      -- Dark gray for borders
      background_color = 21,
      visited_color = 6,     -- Light gray for visited rooms
      current_color = 7,     -- White for current room
      unexplored_color = 1,  -- Dark blue for unexplored but discovered
      icon_size = 10,        -- Special room icon sprite size
      overlap_margin_x = 32, -- Check x buffer
      overlap_margin_y = 16, -- Check y margin
      tween_duration = 15,   -- Frames to tween between positions
      icons = {              -- Special room sprites (10x10)
         start = 192,
         shop = 193,
         treasure = 194,
         boss = 195,
      },
   },
}

:: src/game/events.lua
-- Events module - Pub/Sub wrapper around beholder.lua
local beholder = require("lib/beholder.lua/beholder")

local Events = {}

-- Event Constants (use these instead of strings)
Events.ROOM_CLEAR = "room:clear"
Events.ROOM_TRANSITION = "room:transition"
Events.GAME_OVER = "game:over"
Events.MINIMAP_ZONE_ENTER = "minimap:zone_enter"
Events.MINIMAP_ZONE_EXIT = "minimap:zone_exit"
Events.LEVEL_UP = "level_up"

--- Subscribe to an event
-- @param event The event constant (e.g., Events.ROOM_CLEAR)
-- @param callback Function to call when event fires
-- @return Subscription ID (use with Events.off to unsubscribe)
function Events.on(event, callback)
   return beholder.observe(event, callback)
end

--- Unsubscribe from an event
-- @param id The subscription ID returned by Events.on
function Events.off(id)
   beholder.stopObserving(id)
end

--- Emit an event to all subscribers
-- @param event The event constant (e.g., Events.ROOM_CLEAR)
-- @param ... Arguments to pass to subscribers
function Events.emit(event, ...)
   beholder.trigger(event, ...)
end

--- Reset all subscriptions (call on scene exit)
function Events.reset()
   beholder.reset()
end

return Events

:: src/game/game_config.lua
-- Game Configuration Aggregator
-- Imports and merges all config sub-modules into a single GameConstants table

-- Load global tile constants (sets global variables)
require("src/game/config/tiles")

-- Load modular configs
local player = require("src/game/config/player")
local entities = require("src/game/config/entities")
local obstacles = require("src/game/config/obstacles")
local effects = require("src/game/config/effects")
local pickups = require("src/game/config/pickups")
local mutations = require("src/game/config/mutations")
local ui = require("src/game/config/ui")
local controls_config = require("src/game/config/controls")
local collision = require("src/game/config/collision")

-- Build unified GameConstants table
local GameConstants = {
   -- Core
   title = "Pizak",

   -- Player
   Player = player,

   -- Entities (from entities.lua)
   Projectile = entities.Projectile,
   Enemy = entities.Enemy,
   Minion = entities.Minion,

   -- Pickups (from pickups.lua)
   Pickup = pickups.Pickup,

   -- Obstacles (from obstacles.lua)
   Obstacle = obstacles.Obstacle,

   -- Mutations (from mutations.lua)
   Mutations = mutations,

   -- Effects (from effects.lua)
   PlacedBomb = effects.PlacedBomb,
   Explosion = effects.Explosion,
   Emotions = effects.Emotions,
   FloatingText = effects.FloatingText,

   -- UI (from ui.lua)
   Hud = ui.Hud,
   Minimap = ui.Minimap,
   XpBar = ui.XpBar,

   -- Controls (from controls.lua)
   buttons = controls_config.buttons,
   controls = controls_config.controls,

   -- Collision (from collision.lua)
   CollisionLayers = collision.CollisionLayers,
   CollisionMasks = collision.CollisionMasks,
   EntityCollisionLayer = collision.EntityCollisionLayer,
}

return GameConstants

:: src/game/game_state.lua
-- Game State: Mutable runtime values (cheats, debug flags)
-- These values change during gameplay and should not be in config

local GameState = {
   debug = {
      show_hitboxes = false,
      show_grid = false,         -- Debug: show tile grid overlay
      show_pathfinding = false,  -- Debug: show chick AI paths and targets
      show_combat_timer = false, -- Debug: show time since combat started
   },
   cheats = {
      noclip = false,
      godmode = false,
      free_attacks = false,     -- Removes shot/melee costs and activation conditions
      infinite_inventory = false,
      unlock_all_rooms = false, -- All doors stay open, no enemies required
   },
   -- Level seed for reproducible dungeon generation (nil = random)
   level_seed = 83,
   -- The actual seed used for the current level (set at generation time)
   current_seed = nil,
}

return GameState

:: src/game/init.lua
-- Game module aggregator
-- Provides Config (immutable), State (mutable runtime values), and Events

local Game = {
   Config = require("src/game/game_config"),
   State = require("src/game/game_state"),
   Events = require("src/game/events"),
}

return Game

:: src/game/mutations.lua
-- Mutations module
-- Handles mutation selection and management
local MutationsConfig = require("src/game/config/mutations")

local Mutations = {}

--- Pick N distinct random mutations
--- @param count Number of mutations to pick
--- @return table List of mutation definition objects
function Mutations.pick_random_items(count)
   local candidates = {}
   for _, m in pairs(MutationsConfig.Mutation) do
      add(candidates, m)
   end

   local selected = {}
   for i = 1, count do
      if #candidates == 0 then break end
      local idx = flr(rnd(#candidates)) + 1
      add(selected, candidates[idx])
      del(candidates, candidates[idx]) -- Remove to ensure uniqueness
   end

   return selected
end

return Mutations

:: src/input.lua
-- Input module: consolidates all input handling
-- This is a top-level module (not an ECS system) that maps hardware input to entity properties
local GameConstants = require("src/game/game_config")

local Input = {}

-- Main input handler: reads movement and action buttons
-- @param entity - Entity with controllable tag
function Input.read_input(entity)
   -- Movement Input
   local left = btn(GameConstants.controls.move_left)
   local right = btn(GameConstants.controls.move_right)
   local up = btn(GameConstants.controls.move_up)
   local down = btn(GameConstants.controls.move_down)

   local dx = 0
   local dy = 0
   if left then dx -= 1 end
   if right then dx += 1 end
   if up then dy -= 1 end
   if down then dy += 1 end

   entity.dir_x = dx
   entity.dir_y = dy

   -- Action/Link Input (Shooting)
   local shoot_dir_x = 0
   local shoot_dir_y = 0
   if btn(GameConstants.controls.aim_left) then shoot_dir_x = -1 end
   if btn(GameConstants.controls.aim_right) then shoot_dir_x = 1 end
   if btn(GameConstants.controls.aim_up) then shoot_dir_y = -1 end
   if btn(GameConstants.controls.aim_down) then shoot_dir_y = 1 end

   entity.shoot_dir_x = shoot_dir_x
   entity.shoot_dir_y = shoot_dir_y
end

return Input

:: src/lifecycle.lua
return require("src/lifecycle/init")

:: src/lifecycle/death_handlers.lua
-- Entity death behavior registry
local Entities = require("src/entities")
local Events = require("src/game/events")
local DungeonManager = require("src/world/dungeon_manager")
local Effects = require("src/systems/effects")

local DeathHandlers = {}

-- Loot table for enemies (weights must sum to 1.0)
local ENEMY_LOOT = {
   {type = "HealthPickup", weight = 0.50},
   {type = "Coin",         weight = 0.30},
   {type = "Bomb",         weight = 0.15},
   {type = "Key",          weight = 0.05},
}

-- Helper: Pick a random loot type from weighted table
local function pick_loot(loot_table)
   local roll = rnd()
   local cumulative = 0
   for _, entry in ipairs(loot_table) do
      cumulative = cumulative + entry.weight
      if roll < cumulative then
         return entry.type
      end
   end
   return loot_table[#loot_table].type
end

DeathHandlers.Player = function(world, entity)
   Log.trace("Player died!")
   Events.emit(Events.GAME_OVER)
end

DeathHandlers.Chick = function(world, entity)
   local cx = entity.x + (entity.width or 16) / 2
   local cy = entity.y + (entity.height or 16) / 2
   Effects.spawn_particles(cx, cy, "blood", 8)
   world.del(entity)
end

DeathHandlers.Enemy = function(world, entity)
   local drop_chance = entity.drop_chance or 1.0
   local loot_rolls = entity.loot_rolls or 1
   local cx = entity.x + (entity.width or 16) / 2
   local cy = entity.y + (entity.height or 16) / 2

   for i = 1, loot_rolls do
      if rnd() < drop_chance then
         local loot_type
         if entity.use_diverse_loot then
            loot_type = pick_loot(ENEMY_LOOT)
         else
            loot_type = "HealthPickup"
         end
         -- Offset each item slightly to reduce overlap
         local offset_x = (i - 1) * 8 - (loot_rolls - 1) * 4
         local offset_y = (rnd() - 0.5) * 4
         local spawn_x, spawn_y = cx + offset_x, cy + offset_y

         -- Snap to floor to avoid pits
         local sx, sy = DungeonManager.snap_to_nearest_floor(spawn_x, spawn_y, DungeonManager.current_room)
         if sx then spawn_x, spawn_y = sx, sy end

         Entities.spawn_pickup(world, spawn_x, spawn_y, loot_type)
      end
   end

   -- XP Drop (always drops)
   local xp_value = entity.xp_value or 10
   local xp_x, xp_y = cx, cy + 8

   -- Snap to floor to avoid pits
   local sx, sy = DungeonManager.snap_to_nearest_floor(xp_x, xp_y, DungeonManager.current_room)
   if sx then xp_x, xp_y = sx, sy end

   Entities.spawn_pickup(world, xp_x, xp_y, "DNAStrand", {xp_amount = xp_value})

   world.del(entity)
end

DeathHandlers.default = function(world, entity)
   Log.trace("Entity died: "..(entity.type or "Unknown"))
   world.del(entity)
end

return DeathHandlers

:: src/lifecycle/init.lua
-- Lifecycle module aggregator
local lifecycle = require("src/lifecycle/lifecycle")
local death_handlers = require("src/lifecycle/death_handlers")

local Lifecycle = {}

-- Self-iterating update function
function Lifecycle.update(world)
   world.sys("animatable", function(e) lifecycle.update_fsm(e, world) end)()
end

Lifecycle.init = lifecycle.init_fsm
Lifecycle.DeathHandlers = death_handlers

return Lifecycle

:: src/lifecycle/lifecycle.lua
-- Entity lifecycle management: FSM initialization and state transitions
local machine = require("lib/lua-state-machine/statemachine")
local DeathHandlers = require("src/lifecycle/death_handlers")

local Lifecycle = {}

-- Initialize FSM for an entity
function Lifecycle.init_fsm(entity)
    local function reset_timer()
        entity.anim_timer = 0
    end

    entity.fsm = machine.create({
        initial = "idle",
        events = {
            {name = "walk",    from = "idle",                           to = "walking"},
            {name = "stop",    from = "walking",                        to = "idle"},
            {name = "attack",  from = {"idle", "walking"},              to = "attacking"},
            {name = "hit",     from = {"idle", "walking", "attacking"}, to = "hurt"},
            {name = "die",     from = "*",                              to = "death"},
            {name = "recover", from = "hurt",                           to = "idle"},
            {name = "finish",  from = "attacking",                      to = "idle"}
        },
        callbacks = {
            onenteridle = reset_timer,
            onenterwalking = reset_timer,
            onenterattacking = reset_timer,
            onenterhurt = reset_timer,
            onenterdeath = function()
                reset_timer()
                -- Deactivate active processing tags on death
                local tags_to_remove = "controllable,collidable,shooter,player,enemy,acceleration,velocity,health"
                world.unt(entity, tags_to_remove)

                -- Stop remaining movement
                entity.vel_x = 0
                entity.vel_y = 0
            end
        }
    })
    entity.anim_timer = 0
    entity.current_direction = entity.direction or entity.current_direction or "down"
end

-- Update entity FSM based on game state
function Lifecycle.update_fsm(entity, world)
    if not entity.fsm then
        Lifecycle.init_fsm(entity)
    end

    local fsm = entity.fsm

    -- Handle completed animations (Death / Attack finish)
    if entity.anim_complete_state then
        if entity.anim_complete_state == "death" then
            local handler = DeathHandlers[entity.type] or DeathHandlers.default
            if not entity.death_cleanup_called then
                entity.death_cleanup_called = true
                -- Pass world if available, checking for both local arg and global fallback
                handler(world or _G.world, entity)
            end
        elseif entity.anim_complete_state == "attacking" then
            if not entity.anim_looping and fsm.finish then
                fsm:finish()
            end
        end
    end

    -- Can't transition out of death
    if fsm:is("death") then return end

    -- Handle movement transitions
    local is_moving = (abs(entity.vel_x or 0) > 0.1 or abs(entity.vel_y or 0) > 0.1)

    if is_moving then
        if fsm.walk then fsm:walk() end
    else
        if fsm.stop then fsm:stop() end
    end

    -- Hit transition (invuln timer indicates recent damage)
    if entity.invuln_timer and entity.invuln_timer > 0 then
        if fsm.hit then fsm:hit() end
    elseif fsm:is("hurt") then
        if fsm.recover then fsm:recover() end
    end

    -- Death check
    if entity.hp and entity.hp <= 0 then
        if not fsm:is("death") then
            fsm:die()
        end
    end
end

return Lifecycle

:: src/main.lua
include("lib/require.lua")
include("lib/debugui.lua")
include("lib/eggs.p8/eggs.lua")

Class = require("lib/middleclass")
Stateful = require("lib/stateful")

Log = require("lib/log")
Log.init("trace")
Log.trace("Log.init: current_level = "..Log.current_level)

local Scenes = require("src/scenes")

local starting_scene = "Play"
local scene_manager = Scenes.Manager:new()

function _init()
   scene_manager:gotoState(starting_scene)
end

function _update()
   scene_manager:update()
end

function _draw()
   scene_manager:draw()
   debugui.run()
end

include("lib/error_explorer.lua")

:: src/physics.lua
return require("src/physics/init")

:: src/physics/collision.lua
local Collision = {}

local SpatialGrid = require("src/physics/spatial_grid")
local CollisionFilter = require("src/physics/collision_filter")
local HitboxUtils = require("src/utils/hitbox_utils")
Collision.CollisionHandlers = require("src/physics/handlers")
local CollisionUtils = require("src/utils/collision_utils")
local MathUtils = require("src/utils/math_utils")

local collision_filter = CollisionFilter:new()

local get_hitbox = HitboxUtils.get_hitbox
local current_grid = nil

-- Map Utils functions to Collision (API compatibility)
Collision.find_solid_tile = CollisionUtils.find_solid_tile
Collision.is_solid = CollisionUtils.is_solid
local find_solid_tile = CollisionUtils.find_solid_tile -- for local usage inside this file if any

--- Apply door guidance to nudge player toward nearby unlocked doors
---
--- This helps players "slide" into doorways when moving along walls
---
--- @param entity Entity
--- @param tx number
--- @param ty number
--- @param room Room
local function apply_door_guidance(entity, tx, ty, room)
    if not room or not room.doors then return end

    for dir, door in pairs(room.doors) do
        -- Only guide toward open doors
        if door.sprite == DOOR_OPEN_TILE then
            local dpos = room:get_door_tile(dir)
            if dpos then
                -- Door is in same column?
                if tx == dpos.tx then
                    -- Door is adjacent on Y axis?
                    if abs(ty - dpos.ty) == 1 then
                        entity.vel_y = (dpos.ty > ty and 1 or -1) * DOOR_GUIDANCE_MULTIPLIER
                        return -- Stop after first match
                    end
                end
                -- Door is in same row?
                if ty == dpos.ty then
                    -- Door is adjacent on X axis?
                    if abs(tx - dpos.tx) == 1 then
                        entity.vel_x = (dpos.tx > tx and 1 or -1) * DOOR_GUIDANCE_MULTIPLIER
                        return -- Stop after first match
                    end
                end
            end
        end
    end
end

--- Check if player has exited room bounds and trigger transition
---
--- @param entity Entity
--- @param camera_manager CameraManager
--- @return nil|[number, number]
function Collision.check_trigger(entity, camera_manager)
    local room = camera_manager.current_room
    if not room then return nil end

    local rpx = room.pixels

    -- Use hitbox center for accurate boundary detection
    -- This prevents false triggers when tall sprites (like player with hitbox offset)
    -- have their entity.y above room boundary while hitbox is still inside
    local hb = get_hitbox(entity)
    local cx = hb.x + hb.w / 2
    local cy = hb.y + hb.h / 2

    -- Check if hitbox center is outside room bounds
    if cx < rpx.x or cx >= rpx.x + rpx.w or
       cy < rpx.y or cy >= rpx.y + rpx.h then
        -- Directly trigger transition (no need for handler indirection)
        return camera_manager:on_trigger(cx, cy)
    end

    return nil
end

--- Update the spatial grid once per frame
---
--- @param world The ECS world instance
function Collision.update_spatial_grid(world)
    current_grid = SpatialGrid:new(SPATIAL_GRID_CELL_SIZE)
    world.sys("collidable", function(e)
        current_grid:add(e, get_hitbox)
    end)()
end

--- Resolve collisions between entities
---
--- @param entity1 Entity
function Collision.resolve_entities(entity1)
    if not current_grid then
        -- Fallback if update_spatial_grid wasn't called, but better to call it explicitly
        current_grid = SpatialGrid:new(SPATIAL_GRID_CELL_SIZE)
        world.sys("collidable", function(e)
            current_grid:add(e, get_hitbox)
        end)()
    end

    -- Query nearby entities (spatial partitioning optimization)
    local nearby = current_grid:get_nearby(entity1, get_hitbox)

    -- Pre-calculate projectile segment if applicable (Continuous Collision Detection)
    local is_projectile = entity1.type == "Projectile" or entity1.type == "EnemyProjectile"
    local p_start_x, p_start_y, p_end_x, p_end_y
    if is_projectile and (abs(entity1.vel_x or 0) > 4 or abs(entity1.vel_y or 0) > 4) then
        -- Only strictly needed for fast moving objects, but let's be safe
        -- "Previous" position is roughly current - velocity
        -- (Assuming this runs AFTER velocity application, which it does in play.lua)
        local hb = get_hitbox(entity1)
        p_end_x = hb.x + hb.w / 2
        p_end_y = hb.y + hb.h / 2
        p_start_x = p_end_x - (entity1.vel_x or 0)
        p_start_y = p_end_y - (entity1.vel_y or 0)
    end

    for _, entity2 in ipairs(nearby) do
        -- Check collision layers (bitmasking - very fast)
        if collision_filter:can_collide(entity1, entity2) then
            local hit = false

            -- 1. Standard AABB Overlap
            if Collision.check_overlap(entity1, entity2) then
                hit = true
                -- 2. Continuous Collision Detection (Raycast) for fast projectiles
            elseif is_projectile and p_start_x then
                local hb2 = get_hitbox(entity2)
                if MathUtils.segment_intersects_aabb(p_start_x, p_start_y, p_end_x, p_end_y, hb2.x, hb2.y, hb2.w, hb2.h) then
                    hit = true
                end
            end

            if hit then
                -- Z-elevation filtering: Enemy projectiles above player's height miss
                if entity1.type == "EnemyProjectile" and entity2.type == "Player" then
                    local proj_z = entity1.z or 0
                    local target_height_z = entity2.height_z or 16
                    if proj_z > target_height_z then
                        hit = false -- Projectile is above player's vertical collision range
                    end
                end
            end

            if hit then
                local type1 = entity1.type or ""
                local type2 = entity2.type or ""
                local key = type1..","..type2
                local handler = Collision.CollisionHandlers.entity[key]

                if handler then
                    handler(entity1, entity2)
                end
            end
        end
    end
end

--- Resolve collisions between entity and map
---
--- @param entity Entity
--- @param room Room
--- @param camera_manager CameraManager
function Collision.resolve_map(entity, room, camera_manager)
    if entity.ignore_map_collision then
        return
    end

    local hb = get_hitbox(entity)
    local x = hb.x
    local y = hb.y
    local w = hb.w
    local h = hb.h

    local handler = Collision.CollisionHandlers.map[entity.type or ""]

    local function check(axis, vox, voy)
        local sub = entity["sub_"..axis]
        local vel = entity["vel_"..axis]
        local move = flr(sub + vel)
        if sub + vel < 0 and sub + vel ~= move then
            move = ceil(sub + vel) - 1
        end

        local cx = x + vox + (axis == "x" and move or 0)
        local cy = y + voy + (axis == "y" and move or 0)

        local stx, sty, stile = find_solid_tile(cx, cy, w, h, entity, room)
        if stx then
            if handler then handler(entity, cx, cy, stx, sty, stile, room) end

            -- Apply door guidance for player only
            if entity.type == "Player" then
                apply_door_guidance(entity, stx, sty, room)
            end

            entity["vel_"..axis] = 0
            entity["sub_"..axis] = 0
            return 0
        end
        return move
    end

    local mx = check("x", 0, 0)
    check("y", (entity.sub_x or 0) == 0 and 0 or mx, 0)

    -- Trigger check integrated into map resolution
    if entity.type == "Player" and camera_manager then
        Collision.check_trigger(entity, camera_manager)
    end
end

--- Check if two entities overlap
---
--- @param entity1 Entity
--- @param entity2 Entity
--- @return boolean
function Collision.check_overlap(entity1, entity2)
    local hb1 = get_hitbox(entity1)
    local hb2 = get_hitbox(entity2)
    return hb1.x < hb2.x + hb2.w and
       hb1.x + hb1.w > hb2.x and
       hb1.y < hb2.y + hb2.h and
       hb1.y + hb1.h > hb2.y
end

return Collision

:: src/physics/collision_filter.lua
local GameConstants = require("src/game/game_config")

local CollisionFilter = Class("CollisionFilter")

function CollisionFilter:initialize()
    self.layer_map = GameConstants.EntityCollisionLayer
    self.masks = GameConstants.CollisionMasks
end

function CollisionFilter:can_collide(entity1, entity2)
    local type1 = entity1.type or ""
    local type2 = entity2.type or ""

    local layer1 = self.layer_map[type1]
    local layer2 = self.layer_map[type2]

    -- Backward compatibility: allow collision if either entity has no layer
    if not layer1 or not layer2 then return true end

    local mask1 = self.masks[layer1]
    if not mask1 then return true end

    -- Bitwise AND check
    return (mask1 & layer2) ~= 0
end

return CollisionFilter

:: src/physics/handlers.lua
-- Collision Handlers Aggregator
-- Imports and merges all handler sub-modules into a unified Handlers table

local PickupHandlers = require("src/physics/handlers/pickup_handlers")
local CombatHandlers = require("src/physics/handlers/combat_handlers")
local ObstacleHandlers = require("src/physics/handlers/obstacle_handlers")
local MapHandlers = require("src/physics/handlers/map_handlers")

local Handlers = {
    entity = {},
    map = {}
}

-- Register all handlers from sub-modules
PickupHandlers.register(Handlers)
CombatHandlers.register(Handlers)
ObstacleHandlers.register(Handlers)
MapHandlers.register(Handlers)

return Handlers

:: src/physics/handlers/combat_handlers.lua
-- Combat collision handlers
-- Handles damage dealing between Player, Enemies, Projectiles, and Melee

local GameConstants = require("src/game/game_config")
local GameState = require("src/game/game_state")
local Effects = require("src/systems/effects")
local FloatingText = require("src/systems/floating_text")
local Entities = require("src/entities")
local HitboxUtils = require("src/utils/hitbox_utils")
local DungeonManager = require("src/world/dungeon_manager")
local AI = require("src/ai")

local CombatHandlers = {}

--- Helper: Apply damage, consuming overheal first before base HP
--- @param entity Entity to damage (must have hp, overflow_hp properties)
--- @param damage integer - Amount of damage to apply
--- @return integer actual_damage - Damage applied to base HP (after overheal absorption)
local function apply_damage_with_overheal(entity, damage)
   local overheal = entity.overflow_hp or 0

   if overheal > 0 then
      if overheal >= damage then
         -- Overheal absorbs all damage
         entity.overflow_hp = overheal - damage
         return 0
      else
         -- Overheal absorbs partial damage
         local remaining = damage - overheal
         entity.overflow_hp = 0
         entity.hp = entity.hp - remaining
         return remaining
      end
   else
      -- No overheal, damage goes directly to HP
      entity.hp = entity.hp - damage
      return damage
   end
end

--- Handler for MeleeHitbox hitting Enemy
--- @param hitbox MeleeHitbox entity
--- @param enemy Enemy entity
local function melee_vs_enemy(hitbox, enemy)
   -- Skip if enemy is invulnerable
   if enemy.invuln_timer and enemy.invuln_timer > 0 then
      return
   end

   -- Deal damage to enemy
   local damage = hitbox.melee_damage or 10
   enemy.hp = enemy.hp - damage
   enemy.invuln_timer = 10 -- Brief invulnerability after hit
   FloatingText.spawn_at_entity(enemy, -damage, "damage")
   Effects.hit_impact(hitbox, enemy)

   -- Composite knockback: base player knockback + melee knockback
   local knockback = GameConstants.Player.base_knockback + GameConstants.Player.melee_knockback
   Effects.apply_knockback(hitbox, enemy, knockback)

   -- Vampiric healing: Heal player for % of damage dealt
   local owner = hitbox.owner_entity
   if owner and owner.type == "Player" then
      local heal_percent = owner.vampiric_heal or GameConstants.Player.vampiric_heal or 0.3
      local vampiric_heal = damage * heal_percent
      owner.hp = math.min(owner.hp + vampiric_heal, owner.max_hp)
      FloatingText.spawn_at_entity(owner, vampiric_heal, "heal")
   end
end

-- Handler for Projectile hitting Enemy
local function projectile_vs_enemy(projectile, enemy)
   -- Prevent double processing if already handled
   if projectile.hit_obstacle then return end
   projectile.hit_obstacle = true

   -- Trigger impact effect
   Effects.hit_impact(projectile, enemy)

   -- Apply knockback from projectile direction
   local knockback = GameConstants.Player.base_knockback or 4
   Effects.apply_knockback(projectile, enemy, knockback)

   -- Target painting: Mark this enemy as priority target for all chicks
   AI.ChickAI.paint_target(enemy)

   -- Get outcome values from projectile (passed from player stats or config)
   -- Using config defaults if not on projectile, though Shooter system usually copies them
   local dud_damage = projectile.dud_damage or GameConstants.Player.dud_damage or 3
   local leech_damage = projectile.leech_damage or GameConstants.Player.leech_damage or 5
   local leech_heal = projectile.leech_heal or GameConstants.Player.leech_heal or 5
   local hatch_time = projectile.hatch_time or GameConstants.Player.hatch_time or 120

   -- Sticky Yolk effect config (stun + slow instead of knockback)
   -- Read from projectile (passed from player stats) or fall back to constants
   local stun_dur = GameConstants.Player.egg_stun_duration or 12
   local slow_dur = projectile.egg_slow_duration or GameConstants.Player.egg_slow_duration or 60
   local slow_factor = projectile.egg_slow_factor or GameConstants.Player.egg_slow_factor or 0.5
   local attach_dur = GameConstants.Player.chick_attach_duration or 60

   local roll_dud = projectile.roll_dud_chance or GameConstants.Player.roll_dud_chance or 0.50
   local roll_hatch = projectile.roll_hatch_chance or GameConstants.Player.roll_hatch_chance or 0.35
   -- Remainder is Leech (approx 0.15)

   local hb = HitboxUtils.get_hitbox(projectile)
   local spawn_x = hb.x + hb.w / 2 - 8
   local spawn_y = hb.y + hb.h / 2 - 8
   local spawn_z = projectile.z or 0

   -- Single roll with 3 outcomes
   local roll = rnd()
   local threshold_dud = roll_dud
   local threshold_hatch = roll_dud + roll_hatch

   if roll < threshold_dud then
      -- The Dud : 3 Dmg, splats harmlessly + Sticky Yolk (stun/slow)
      if not (enemy.invuln_timer and enemy.invuln_timer > 0) then
         enemy.hp = enemy.hp - dud_damage
         enemy.invuln_timer = 10
         FloatingText.spawn_at_entity(enemy, -dud_damage, "damage")
         -- Sticky Yolk: stun + slow instead of knockback
         Effects.apply_sticky_yolk(enemy, stun_dur, slow_dur, slow_factor)
      end
      -- Visual splat effect for Dud
      Effects.spawn_visual_effect(world, spawn_x, spawn_y, BROKEN_EGG_SPRITE, 15)
   elseif roll < threshold_hatch then
      -- The Hatching (35%): No damage, spawn chick attached to enemy (Face-Hugger)
      -- Apply Sticky Yolk so enemy can't escape during chick hatch
      Effects.apply_sticky_yolk(enemy, stun_dur, slow_dur, slow_factor)

      -- Spawn egg at enemy position with attachment
      Entities.spawn_egg(world, enemy.x, enemy.y, {
         hatch_timer = hatch_time,
         z = spawn_z,
         attachment_target = enemy,
         attachment_timer = attach_dur,
         broodmother_active = projectile.broodmother_active,
      })
   else
      -- Parasitic Drain (approx 15%): Partial damage + spawn health pickup + Sticky Yolk
      if not (enemy.invuln_timer and enemy.invuln_timer > 0) then
         enemy.hp = enemy.hp - leech_damage
         enemy.invuln_timer = 10
         FloatingText.spawn_at_entity(enemy, -leech_damage, "damage")
         -- Sticky Yolk: stun + slow instead of knockback
         Effects.apply_sticky_yolk(enemy, stun_dur, slow_dur, slow_factor)
      end
      -- Spawn health pickup (blood glob)
      local sx, sy = DungeonManager.snap_to_nearest_floor(spawn_x, spawn_y + spawn_z, DungeonManager.current_room)
      if not sx then sx, sy = spawn_x, spawn_y + spawn_z end -- Fall back to original position
      Entities.spawn_health_pickup(world, sx, sy, leech_heal)
   end
   world.del(projectile)
end

--- Handler for Player touching Enemy (contact damage)
--- @param player Player entity
--- @param enemy Enemy entity
local function player_vs_enemy(player, enemy)
   if enemy.enemy_type == "Dasher" and enemy.dasher_fsm and enemy.dasher_fsm:is("dash") then
      enemy.dasher_collision = true
   end
   if player.invuln_timer and player.invuln_timer > 0 then
      return
   end
   local damage = enemy.contact_damage or 10
   -- Apply damage reduction if player has upgrade
   damage = math.floor(damage * (player.damage_reduction or 1.0))
   if not GameState.cheats.godmode then
      apply_damage_with_overheal(player, damage)
      FloatingText.spawn_at_entity(player, -damage, "damage")
   end
   Effects.hit_impact(enemy, player, "heavy_shake")
   Effects.apply_knockback(enemy, player, 16)
   player.invuln_timer = player.invulnerability_duration or 120
   player.time_since_shot = 0
end

-- Handler for EnemyProjectile hitting Player
local function enemy_projectile_vs_player(projectile, player)
   if player.invuln_timer and player.invuln_timer > 0 then
      return
   end
   local damage = projectile.damage or 10
   if not GameState.cheats.godmode then
      apply_damage_with_overheal(player, damage)
      FloatingText.spawn_at_entity(player, -damage, "damage")
   end
   Effects.hit_impact(projectile, player, "heavy_shake")
   Effects.apply_knockback(projectile, player, 8)
   player.invuln_timer = player.invulnerability_duration or 120
   player.time_since_shot = 0
   world.del(projectile)
end

-- Helper: Apply radial knockback from explosion center
local function apply_explosion_knockback(explosion, target, strength)
   -- Use stored explosion center for consistent radial knockback
   local src_cx = explosion.explosion_center_x or (explosion.x + (explosion.width or 0) / 2)
   local src_cy = explosion.explosion_center_y or (explosion.y + (explosion.height or 0) / 2)
   local tgt_cx = target.x + (target.width or 0) / 2
   local tgt_cy = target.y + (target.height or 0) / 2

   local dx = tgt_cx - src_cx
   local dy = tgt_cy - src_cy

   -- Normalize direction
   local len = sqrt(dx * dx + dy * dy)
   if len > 0 then
      dx = dx / len
      dy = dy / len
   else
      dx, dy = 0, -1 -- Default push up if overlapping
   end

   target.knockback_vel_x = dx * strength
   target.knockback_vel_y = dy * strength
end

-- Handler for Explosion hitting Player
local function explosion_vs_player(explosion, player)
   if player.invuln_timer and player.invuln_timer > 0 then
      return
   end

   local damage = explosion.explosion_damage or 20
   if not GameState.cheats.godmode then
      apply_damage_with_overheal(player, damage)
      FloatingText.spawn_at_entity(player, -damage, "damage")
   end
   Effects.hit_impact(explosion, player, "heavy_shake")
   apply_explosion_knockback(explosion, player, 16)
   player.invuln_timer = player.invulnerability_duration or 120
end

-- Handler for Explosion hitting Enemy
local function explosion_vs_enemy(explosion, enemy)
   if enemy.invuln_timer and enemy.invuln_timer > 0 then
      return
   end

   local damage = explosion.explosion_damage or 20
   enemy.hp = enemy.hp - damage
   enemy.invuln_timer = 10
   FloatingText.spawn_at_entity(enemy, -damage, "damage")
   Effects.hit_impact(explosion, enemy)
   apply_explosion_knockback(explosion, enemy, 12)
end

-- Register all combat handlers
function CombatHandlers.register(handlers)
   handlers.entity["MeleeHitbox,Enemy"] = melee_vs_enemy
   handlers.entity["Projectile,Enemy"] = projectile_vs_enemy
   handlers.entity["Player,Enemy"] = player_vs_enemy
   handlers.entity["EnemyProjectile,Player"] = enemy_projectile_vs_player
   handlers.entity["Explosion,Player"] = explosion_vs_player
   handlers.entity["Explosion,Enemy"] = explosion_vs_enemy
   handlers.entity["Player,Explosion"] = function(player, explosion)
      explosion_vs_player(explosion, player)
   end
   handlers.entity["Enemy,Explosion"] = function(enemy, explosion)
      explosion_vs_enemy(explosion, enemy)
   end
end

return CombatHandlers

:: src/physics/handlers/map_handlers.lua
-- Map collision handlers
-- Handles entity collisions with the tile map (walls)

local Entities = require("src/entities")
local HitboxUtils = require("src/utils/hitbox_utils")
local GameConstants = require("src/game/game_config")
local Particles = require("src/systems/particles")

local MapHandlers = {}

-- Register all map handlers
function MapHandlers.register(handlers)
   handlers.map["Projectile"] = function(projectile)
      -- Prevent double processing if already handled by entity collision
      if projectile.hit_obstacle then return end
      projectile.hit_obstacle = true

      -- Use hitbox center to check what we hit
      local hb = HitboxUtils.get_hitbox(projectile)
      local cx = hb.x + hb.w / 2
      local cy = hb.y + hb.h / 2

      -- Helper to get tile under center
      local tx = flr(cx / GRID_SIZE)
      local ty = flr(cy / GRID_SIZE)
      local tile = mget(tx, ty) or 0

      -- Check for Pit (Silent sink)
      if fget(tile, FEATURE_FLAG_PIT) then
         world.del(projectile)
         return
      end

      -- Spawn Yolk Splat at wall base (visual + slow + edible)
      local spawn_x = cx - GRID_SIZE / 2
      local spawn_y = cy - GRID_SIZE / 2

      -- Yolk particles on wall impact
      Particles.spawn_burst(cx, cy, "yolk", 8)

      -- Using Entities convenience helper for YolkSplat
      Entities.spawn_yolk_splat(world, spawn_x, spawn_y, {
         creation_time = t(),
         lifespan = GameConstants.Player.yolk_splat_duration,
         yolk_slow_factor = GameConstants.Player.yolk_slow_factor,
      })

      world.del(projectile)
   end

   handlers.map["EnemyProjectile"] = function(projectile)
      world.del(projectile)
   end

   handlers.map["Enemy"] = function(enemy)
      enemy.hit_wall = true
      if enemy.enemy_type == "Dasher" and enemy.dasher_fsm and enemy.dasher_fsm:is("dash") then
         enemy.dasher_collision = true
      end
   end

   handlers.map["Chick"] = function(minion)
      minion.hit_wall = true
   end
end

return MapHandlers

:: src/physics/handlers/obstacle_handlers.lua
-- Obstacle collision handlers
-- Handles collisions with Rocks and Destructibles

local GameState = require("src/game/game_state")
local Entities = require("src/entities")
local GameConstants = require("src/game/game_config")
local HitboxUtils = require("src/utils/hitbox_utils")
local Effects = require("src/systems/effects")
local DungeonManager = require("src/world/dungeon_manager")
local FloatingText = require("src/systems/floating_text")
local qsort = require("lib/qsort")

local ObstacleHandlers = {}

-- Loot table for destructibles (weights must sum to 1.0)
local DESTRUCTIBLE_LOOT = {
   {type = "Coin", weight = 0.55},
   {type = "Bomb", weight = 0.30},
   {type = "Key",  weight = 0.15},
}

-- Helper: Pick a random loot type from weighted table
local function pick_loot(loot_table)
   local roll = rnd()
   local cumulative = 0
   for _, entry in ipairs(loot_table) do
      cumulative = cumulative + entry.weight
      if roll < cumulative then
         return entry.type
      end
   end
   return loot_table[#loot_table].type -- Fallback to last entry
end

-- Helper: Destroy a destructible entity
local function destroy_destructible(destructible, attacker)
   if destructible.dead then return end

   destructible.dead = true
   world.del(destructible)

   -- 30% chance to spawn loot
   if rnd() < 0.3 then
      local cx = destructible.x + destructible.width / 2
      local cy = destructible.y + destructible.height / 2
      local loot_type = pick_loot(DESTRUCTIBLE_LOOT)

      -- Snap to floor to avoid pits
      local sx, sy = DungeonManager.snap_to_nearest_floor(cx, cy, DungeonManager.current_room)
      if sx then cx, cy = sx, sy end

      Entities.spawn_pickup(world, cx, cy, loot_type)
   end
end

-- Helper: Destroy a rock entity (normally indestructible, but explosions can break them)
local function destroy_rock(rock)
   if rock.dead then return end

   rock.dead = true
   world.del(rock)
end

-- Loot table for chests (weights must sum to 1.0)
local CHEST_LOOT = {
   {type = "Coin",         weight = 0.40},
   {type = "Bomb",         weight = 0.25},
   {type = "Key",          weight = 0.15},
   {type = "HealthPickup", weight = 0.20},
}

--- Helper: Open a chest entity and spawn loot
--- @param chest The chest entity
--- @param player The player entity (for key checking on locked chests)
--- @return true if chest was opened, false if locked and no key
local function open_chest(chest, player)
   if chest.dead or chest.opened then return false end

   -- Check if locked and player has keys
   if chest.is_locked and not GameState.cheats.infinite_inventory then
      local key_cost = chest.key_cost or 1
      if not player.keys or player.keys < key_cost then
         -- Not enough keys - cannot open
         return false
      end
      -- Consume key(s)
      player.keys = player.keys - key_cost
   end

   chest.opened = true

   -- Special handling for Treasure Chest (mutations)
   if chest.is_chest and chest.mutation then
      local cx = chest.x + chest.width / 2
      local cy = chest.y + chest.height / 2

      -- Get mutation config to use correct dimensions
      -- Fix: Lookup in valid sub-table Config -> Mutations -> Mutation -> [Name]
      local mut_config = (GameConstants.Mutations and GameConstants.Mutations.Mutation and GameConstants.Mutations.Mutation[chest.mutation]) or
         {}
      local width = mut_config.width or 32 -- Default to 32 since user confirmed 32x32
      local height = mut_config.height or 32

      local spawn_x = cx - width / 2
      local spawn_y = cy - height / 2 -- Center the item

      -- Zelda-style item rise animation
      Effects.spawn_item_rise(world, spawn_x, spawn_y, chest.mutation_sprite, chest.mutation, function(anim_ent)
         Entities.spawn_pickup(world, anim_ent.x, chest.y - 32, "Mutation", {
            mutation = chest.mutation,
            sprite_index = chest.mutation_sprite,
            width = width,
            height = height,
            hitbox_width = mut_config.hitbox_width,
            hitbox_height = mut_config.hitbox_height,
            hitbox_offset_x = mut_config.hitbox_offset_x,
            hitbox_offset_y = mut_config.hitbox_offset_y,
         })
      end)
   else
      -- Normal loot logic for regular chests
      -- Get loot parameters from config
      local loot_min = chest.loot_min or 1
      local loot_max = chest.loot_max or 3
      local loot_count = loot_min + flr(rnd(loot_max - loot_min + 1))

      -- Calculate spawn position (center of chest)
      local cx = chest.x + chest.width / 2
      local cy = chest.y + chest.height / 2

      -- Track spawned positions to avoid overlap
      local spawned_positions = {}
      local MIN_SEPARATION = 14 -- Minimum distance between spawned items

      for i = 1, loot_count do
         local loot_type = pick_loot(CHEST_LOOT)

         -- Spread pickups in a circle pattern with consistent angles
         local angle = (i / loot_count) * 6.28
         local base_dist = 16 + (i - 1) * 4 -- Stagger distances: 16, 20, 24, etc.
         local spawn_x = cx + cos(angle) * base_dist - 8
         local spawn_y = cy + sin(angle) * base_dist - 8

         -- Snap to floor to avoid pits
         local sx, sy = DungeonManager.snap_to_nearest_floor(spawn_x, spawn_y, DungeonManager.current_room)
         if sx then
            spawn_x, spawn_y = sx, sy
         else
            -- Fallback to chest center if no valid floor found
            spawn_x, spawn_y = cx - 8, cy - 8
         end

         -- Check for overlap with previously spawned items and nudge if needed
         for _, pos in ipairs(spawned_positions) do
            local dx, dy = spawn_x - pos.x, spawn_y - pos.y
            local dist = sqrt(dx * dx + dy * dy)
            if dist < MIN_SEPARATION and dist > 0 then
               -- Nudge away from existing item
               local nudge = (MIN_SEPARATION - dist) / dist
               spawn_x = spawn_x + dx * nudge
               spawn_y = spawn_y + dy * nudge
            elseif dist == 0 then
               -- Exactly same position, offset randomly
               spawn_x = spawn_x + rnd(MIN_SEPARATION) - MIN_SEPARATION / 2
               spawn_y = spawn_y + rnd(MIN_SEPARATION) - MIN_SEPARATION / 2
            end
         end

         table.insert(spawned_positions, {x = spawn_x, y = spawn_y})
         Entities.spawn_pickup(world, spawn_x, spawn_y, loot_type)
      end
   end

   -- Change sprite to open chest (if configured)
   if chest.sprite_open then
      chest.sprite_index = chest.sprite_open
   end

   -- Mark as dead and delete
   chest.dead = true
   world.del(chest)

   return true
end


--- Push entity out of obstacle (AABB minimum penetration resolution)
---
--- Respects solid tiles - won't push entity into walls
---
--- @param entity The entity to push out of the obstacle
--- @param obstacle The obstacle to push the entity out of
local function push_out(entity, obstacle)
   local e_hb = HitboxUtils.get_hitbox(entity)
   local o_hb = HitboxUtils.get_hitbox(obstacle)

   -- Calculate overlap on each axis
   local overlap_left = (e_hb.x + e_hb.w) - o_hb.x
   local overlap_right = (o_hb.x + o_hb.w) - e_hb.x
   local overlap_top = (e_hb.y + e_hb.h) - o_hb.y
   local overlap_bottom = (o_hb.y + o_hb.h) - e_hb.y

   -- Build sorted list of push options by penetration depth (smallest first)
   local push_options = {
      {overlap = overlap_left,   px = -overlap_left, py = 0},
      {overlap = overlap_right,  px = overlap_right, py = 0},
      {overlap = overlap_top,    px = 0,             py = -overlap_top},
      {overlap = overlap_bottom, px = 0,             py = overlap_bottom},
   }
   qsort(push_options, function(a, b) return a.overlap < b.overlap end)

   -- Find first push option that doesn't collide with solid tiles
   local Collision = require("src/physics/collision")
   for _, opt in ipairs(push_options) do
      local new_hb_x = e_hb.x + opt.px
      local new_hb_y = e_hb.y + opt.py
      if not Collision.is_solid(new_hb_x, new_hb_y, e_hb.w, e_hb.h, entity) then
         -- Apply push to entity position
         entity.x = entity.x + opt.px
         entity.y = entity.y + opt.py

         -- Zero velocity in push direction to prevent jittering
         if opt.px ~= 0 then entity.vel_x = 0 end
         if opt.py ~= 0 then entity.vel_y = 0 end
         return
      end
   end

   -- All directions blocked - entity is trapped, don't push
   -- This prevents phasing through walls
end

--- Push enemy out of obstacle and handle Dasher stun
---
--- @param enemy The enemy to push out of the obstacle
--- @param obstacle The obstacle to push the enemy out of
local function push_out_enemy(enemy, obstacle)
   if world.msk(enemy).flying then return end
   push_out(enemy, obstacle)

   -- Special case: Dasher behavior on obstacle collision
   if enemy.enemy_type == "Dasher" and enemy.dasher_fsm then
      if enemy.dasher_fsm:is("dash") then
         -- Stun when dashing into obstacle
         enemy.dasher_collision = true
      elseif enemy.dasher_fsm:is("patrol") then
         -- Treat obstacle like a wall during patrol so Dasher can change direction
         -- This prevents Dashers from getting stuck against obstacles
         enemy.hit_wall = true
      end
   end
end

--- Helper: handle egg break on obstacle collision
--- Guards against being called multiple times for the same projectile
---
--- @param projectile The projectile to handle
--- @param obstacle_type The type of obstacle the projectile hit
local function projectile_hit_obstacle(projectile, obstacle_type)
   -- Prevent double processing if projectile hits multiple obstacles in same frame
   if projectile.hit_obstacle then return end
   projectile.hit_obstacle = true

   -- Use hitbox center for spawn position
   local hb = HitboxUtils.get_hitbox(projectile)
   local spawn_x = hb.x + hb.w / 2 - 8
   local spawn_y = hb.y + hb.h / 2 - 8
   local cx = hb.x + hb.w / 2
   local cy = hb.y + hb.h / 2

   -- Yolk particles on obstacle impact
   Effects.spawn_particles(cx, cy, "yolk", 8)

   if obstacle_type == "Rock" then
      -- Hard Obstacle: Spawns Yolk Splat (same as wall)
      Entities.spawn_minion(world, spawn_x, spawn_y, "YolkSplat", {
         creation_time = t(),
         lifespan = GameConstants.Player.yolk_splat_duration or 300,
         yolk_slow_factor = GameConstants.Player.yolk_slow_factor or 0.7,
      })
   elseif obstacle_type == "Destructible" then
      -- Soft Destructible: Break immediate. egg destroyed.
      -- No hatch, no splat. Just deletion.
      Effects.spawn_visual_effect(world, spawn_x, spawn_y, 29, 15) -- Broken egg visual
   end

   world.del(projectile)
end

--- Register all obstacle handlers
---
--- @param handlers The handlers table to register the obstacle handlers to
function ObstacleHandlers.register(handlers)
   -- Player/Enemy push-out
   handlers.entity["Player,Rock"] = function(player, rock) push_out(player, rock) end
   handlers.entity["Player,Destructible"] = function(player, dest) push_out(player, dest) end
   handlers.entity["Enemy,Rock"] = push_out_enemy
   handlers.entity["Enemy,Destructible"] = push_out_enemy

   -- Chick (Minions) vs Obstacles
   handlers.entity["Chick,Rock"] = function(chick, rock) push_out(chick, rock) end
   handlers.entity["Chick,Destructible"] = function(chick, dest) push_out(chick, dest) end

   -- Chick vs Enemy (one-sided push: only move chick, not enemy)
   handlers.entity["Chick,Enemy"] = function(chick, enemy) push_out(chick, enemy) end
   handlers.entity["Enemy,Chick"] = function(enemy, chick) push_out(chick, enemy) end

   -- Player vs Chests (touching opens them)
   handlers.entity["Player,Chest"] = function(player, chest)
      push_out(player, chest)
      open_chest(chest, player)
   end
   handlers.entity["Player,LockedChest"] = function(player, chest)
      push_out(player, chest)
      open_chest(chest, player)
   end
   handlers.entity["Player,TreasureChest"] = function(player, chest)
      push_out(player, chest)
      open_chest(chest, player)
   end

   -- Chick vs Chests (push out only, can't open)
   handlers.entity["Chick,Chest"] = function(chick, chest) push_out(chick, chest) end
   handlers.entity["Chick,LockedChest"] = function(chick, chest) push_out(chick, chest) end
   handlers.entity["Chick,TreasureChest"] = function(chick, chest) push_out(chick, chest) end

   -- Enemy vs Chests (push out only)
   handlers.entity["Enemy,Chest"] = push_out_enemy
   handlers.entity["Enemy,LockedChest"] = push_out_enemy
   handlers.entity["Enemy,TreasureChest"] = push_out_enemy

   -- Melee vs Chest (opens chest)
   handlers.entity["MeleeHitbox,Chest"] = function(hitbox, chest)
      -- Find player to access keys for locked chests
      local player = nil
      world.sys("player", function(p) player = p end)()
      if player then
         open_chest(chest, player)
      end
   end

   -- Melee vs Destructible
   handlers.entity["MeleeHitbox,Destructible"] = function(hitbox, destructible)
      destroy_destructible(destructible, hitbox.owner_entity)
   end

   -- Projectile vs Rock
   handlers.entity["Projectile,Rock"] = function(projectile, rock)
      projectile_hit_obstacle(projectile, "Rock")
   end

   -- Projectile vs Destructible
   handlers.entity["Projectile,Destructible"] = function(projectile, destructible)
      destroy_destructible(destructible, projectile)
      projectile_hit_obstacle(projectile, "Destructible")
   end

   -- Projectile vs Chest (player egg hits chest - spawns yolk splat)
   handlers.entity["Projectile,Chest"] = function(projectile, chest)
      projectile_hit_obstacle(projectile, "Rock") -- Treat like rock (hard obstacle)
   end
   handlers.entity["Projectile,LockedChest"] = function(projectile, chest)
      projectile_hit_obstacle(projectile, "Rock")
   end
   handlers.entity["Projectile,TreasureChest"] = function(projectile, chest)
      projectile_hit_obstacle(projectile, "Rock")
   end

   -- EnemyProjectile vs Rock (no pickup)
   handlers.entity["EnemyProjectile,Rock"] = function(projectile, rock)
      world.del(projectile)
   end

   -- EnemyProjectile vs Destructible
   handlers.entity["EnemyProjectile,Destructible"] = function(projectile, destructible)
      destroy_destructible(destructible, projectile)
      world.del(projectile)
   end

   -- EnemyProjectile vs Chest (just deletes projectile, doesn't open)
   handlers.entity["EnemyProjectile,Chest"] = function(projectile, chest)
      world.del(projectile)
   end
   handlers.entity["EnemyProjectile,LockedChest"] = function(projectile, chest)
      world.del(projectile)
   end

   -- Explosion vs Destructible (bombs destroy destructibles)
   handlers.entity["Explosion,Destructible"] = function(explosion, destructible)
      destroy_destructible(destructible, explosion)
   end

   -- Explosion vs Chest: Do nothing (bombs should not destroy chests)
   handlers.entity["Explosion,Chest"] = function(explosion, chest)
      -- Intentionally empty: bombs don't affect chests
   end
   handlers.entity["Explosion,LockedChest"] = function(explosion, chest)
      -- Intentionally empty: bombs don't affect locked chests
   end

   -- Explosion vs Rock (bombs are the only way to destroy rocks)
   handlers.entity["Explosion,Rock"] = function(explosion, rock)
      destroy_rock(rock)
   end

   -- Shop Item purchase handlers
   handlers.entity["Player,ShopItem"] = function(player, shop_item)
      -- Guard: Already purchased
      if shop_item.purchased then return end

      -- Push player out first
      push_out(player, shop_item)

      local price = shop_item.price or 10

      -- Check if infinite inventory cheat is active (free purchases)
      local free_purchase = GameState.cheats.infinite_inventory

      if not free_purchase and (player.coins or 0) < price then
         -- Not enough coins - silently reject
         return
      end

      -- Deduct coins (unless using infinite inventory cheat)
      if not free_purchase then
         player.coins = (player.coins or 0) - price
      end
      shop_item.purchased = true

      -- Apply item effect
      if shop_item.apply_fn then
         shop_item.apply_fn(player)
      end

      -- Visual feedback
      FloatingText.spawn_at_entity(player, shop_item.item_name or "Purchased!", "pickup")

      -- Remove from world
      world.del(shop_item)
   end

   -- Other entities vs ShopItem (push out only)
   handlers.entity["Enemy,ShopItem"] = push_out_enemy
   handlers.entity["Chick,ShopItem"] = function(chick, shop_item) push_out(chick, shop_item) end
   handlers.entity["Projectile,ShopItem"] = function(projectile, shop_item)
      projectile_hit_obstacle(projectile, "Rock")
   end
   handlers.entity["EnemyProjectile,ShopItem"] = function(projectile, shop_item)
      world.del(projectile)
   end

   -- Pickup vs Pickup -> push apart to prevent stacking
   local pickup_types = {"Coin", "Key", "Bomb", "HealthPickup"}
   for _, type1 in ipairs(pickup_types) do
      for _, type2 in ipairs(pickup_types) do
         handlers.entity[type1..","..type2] = function(p1, p2)
            -- Push pickups apart to prevent stacking
            local dx = p1.x - p2.x
            local dy = p1.y - p2.y
            local dist = sqrt(dx * dx + dy * dy)
            if dist < 1 then
               dx, dy = rnd() - 0.5, rnd() - 0.5
               dist = 1
            end
            local push_dist = 4 -- Increased from 2 for faster separation
            p1.x = p1.x + (dx / dist) * push_dist
            p1.y = p1.y + (dy / dist) * push_dist
         end
      end
   end
end

return ObstacleHandlers

:: src/physics/handlers/pickup_handlers.lua
-- Pickup collision handlers
-- Handles Player collecting pickups (coins, keys, bombs, health)

local Effects = require("src/systems/effects")
local FloatingText = require("src/systems/floating_text")
local GameConstants = require("src/game/game_config")

local PickupHandlers = {}

-- Mutation application logic
local function apply_mutation(player, mutation_name)
   if mutation_name == "Eggsaggerated" then
      -- Chances: = 0.75, 0.125, 0.125
      player.roll_dud_chance = 0.75
      player.roll_hatch_chance = 0.125
      -- Remainder is Leech (0.125)

      -- Double dud damage
      local base_dud = GameConstants.Player.dud_damage
      player.dud_damage = (player.dud_damage or base_dud) * 2
   elseif mutation_name == "Broodmother" then
      -- Chances: = 0.125, 0.75, 0.125
      player.roll_dud_chance = 0.125
      player.roll_hatch_chance = 0.75
      -- Remainder is Leech (0.125)

      -- Double base chick minions stats (via flag)
      player.broodmother_active = true
   elseif mutation_name == "Pureblood" then
      -- Chances: = 0.125, 0.125, 0.75
      player.roll_dud_chance = 0.125
      player.roll_hatch_chance = 0.125
      -- Remainder is Leech (0.75)

      -- Increase regen_rate = 3
      player.regen_rate = 3

      -- Damage reduction = 20% (multiplier 0.8)
      player.damage_reduction = (player.damage_reduction or 1.0) * 0.8

      -- Melee bonus damage = 10
      player.melee_bonus_damage = (player.melee_bonus_damage or 0) + 10

      -- Allow melee attacks at 1/2 max health
      player.melee_threshold_ratio = 0.5
   end

   player.mutations = player.mutations or GameConstants.Player.mutations
   player.mutations[mutation_name] += 1
end

-- Pickup effect registry (maps pickup_effect string -> handler function)
local PickupEffects = {}

PickupEffects.coin = function(player, pickup)
   local amount = pickup.amount or 1
   player.coins = (player.coins or 0) + amount
   FloatingText.spawn_at_entity(player, amount, "pickup", pickup.sprite_index)
end

PickupEffects.key = function(player, pickup)
   local amount = pickup.amount or 1
   player.keys = (player.keys or 0) + amount
   FloatingText.spawn_at_entity(player, amount, "pickup", pickup.sprite_index)
end

PickupEffects.bomb = function(player, pickup)
   local amount = pickup.amount or 1
   player.bombs = (player.bombs or 0) + amount
   FloatingText.spawn_at_entity(player, amount, "pickup", pickup.sprite_index)
end

PickupEffects.health = function(player, pickup)
   local heal_amount = pickup.recovery_amount or 16
   player.hp = player.hp + heal_amount

   if player.hp > player.max_hp then
      player.overflow_hp = (player.overflow_hp or 0) + (player.hp - player.max_hp)
      player.hp = player.max_hp
   end

   FloatingText.spawn_at_entity(player, heal_amount, "heal", pickup.sprite_index)
end

PickupEffects.xp = function(player, pickup)
   local amount = pickup.xp_amount or 10
   player.xp = (player.xp or 0) + amount
   -- Note: Floating text intentionally omitted per design
end

-- Unified pickup collection handler
local function handle_pickup_collection(player, pickup)
   -- Guard: Prevent double collection (pickup may be touched multiple frames)
   if pickup.collected then return end

   pickup.collected = true

   local effect_type = pickup.pickup_effect or "health"
   local effect_handler = PickupEffects[effect_type]
   assert(effect_handler, "Unknown pickup_effect '"..effect_type.."'")(player, pickup)

   Effects.pickup_collect(pickup)
   world.del(pickup)
end

-- Handler for Mutation pickup
local function handle_mutation_pickup(player, mutation)
   if mutation.collected then return end
   mutation.collected = true

   local name = mutation.mutation -- Defined in config
   if name then
      apply_mutation(player, name)
      FloatingText.spawn_at_entity(player, name.." Mutation +1", "pickup")
   end

   Effects.pickup_collect(mutation)
   world.del(mutation)
end

-- Register all pickup handlers
function PickupHandlers.register(handlers)
   handlers.entity["Player,HealthPickup"] = handle_pickup_collection
   handlers.entity["Player,Coin"] = handle_pickup_collection
   handlers.entity["Player,Key"] = handle_pickup_collection
   handlers.entity["Player,Bomb"] = handle_pickup_collection
   handlers.entity["Player,DNAStrand"] = handle_pickup_collection
   handlers.entity["Player,Mutation"] = handle_mutation_pickup
end

return PickupHandlers

:: src/physics/init.lua
-- Physics module aggregator
local Collision = require("src/physics/collision")
local SpatialGrid = require("src/physics/spatial_grid")
local CollisionFilter = require("src/physics/collision_filter")
local Handlers = require("src/physics/handlers")

local Physics = {}

Physics.collision = Collision
Physics.SpatialGrid = SpatialGrid
Physics.CollisionFilter = CollisionFilter
Physics.Handlers = Handlers

-- Re-export common functions for convenience
Physics.resolve_entities = Collision.resolve_entities
Physics.update_spatial_grid = Collision.update_spatial_grid
Physics.resolve_map = Collision.resolve_map

return Physics

:: src/physics/spatial_grid.lua
local SpatialGrid = Class("SpatialGrid")

function SpatialGrid:initialize(cell_size)
    self.cell_size = cell_size or SPATIAL_GRID_CELL_SIZE
    self.cells = {}
end

function SpatialGrid:add(entity, get_hitbox_fn)
    local hb = get_hitbox_fn(entity)
    local x1 = flr(hb.x / self.cell_size)
    local y1 = flr(hb.y / self.cell_size)
    local x2 = flr((hb.x + hb.w) / self.cell_size)
    local y2 = flr((hb.y + hb.h) / self.cell_size)

    for cx = x1, x2 do
        for cy = y1, y2 do
            -- Use integer key: (cx << 16) | cy
            -- Assuming coordinates fit in 16 bits (more than enough for 64x64/256x256 tiles)
            local key = (cx << 16) | (cy & 0xFFFF)
            if not self.cells[key] then
                self.cells[key] = {}
            end
            table.insert(self.cells[key], entity)
        end
    end
end

function SpatialGrid:get_nearby(entity, get_hitbox_fn)
    local hb = get_hitbox_fn(entity)
    local nearby = {}
    local seen = {}

    local x1 = flr(hb.x / self.cell_size)
    local y1 = flr(hb.y / self.cell_size)
    local x2 = flr((hb.x + hb.w) / self.cell_size)
    local y2 = flr((hb.y + hb.h) / self.cell_size)

    for cx = x1, x2 do
        for cy = y1, y2 do
            local key = (cx << 16) | (cy & 0xFFFF)
            local cell = self.cells[key]
            if cell then
                for i = 1, #cell do
                    local other = cell[i]
                    if not seen[other] and other ~= entity then
                        seen[other] = true
                        table.insert(nearby, other)
                    end
                end
            end
        end
    end

    return nearby
end

function SpatialGrid:get_nearby_hb(hb)
    local nearby = {}
    local seen = {}

    local x1 = flr(hb.x / self.cell_size)
    local y1 = flr(hb.y / self.cell_size)
    local x2 = flr((hb.x + hb.w) / self.cell_size)
    local y2 = flr((hb.y + hb.h) / self.cell_size)

    for cx = x1, x2 do
        for cy = y1, y2 do
            local key = (cx << 16) | (cy & 0xFFFF)
            local cell = self.cells[key]
            if cell then
                for i = 1, #cell do
                    local other = cell[i]
                    if not seen[other] then
                        seen[other] = true
                        table.insert(nearby, other)
                    end
                end
            end
        end
    end

    return nearby
end

return SpatialGrid

:: src/scenes.lua
return require("src/scenes/init")

:: src/scenes/game_over.lua
local pgui = require("lib/pgui")
local SceneManager = require("src/scenes/manager")
local GameOver = SceneManager:addState("GameOver")

local restart_clicked = false
local return_to_title_clicked = false

function GameOver:enteredState()
   Log.trace("Entered GameOver scene")
   -- Reset all GFX state to ensure clean visuals
   pal()           -- Reset color remaps
   palt()          -- Reset transparency (color 0 is transparent for spr/map)
   camera()        -- Reset camera to 0,0
   poke(0x550b, 0) -- Reset pen palette row to 0 (crucial for lighting fix)
end

function GameOver:exitedState()
   restart_clicked = false
   return_to_title_clicked = false
end

function GameOver:update()
   pgui:refresh()

   local restart_label = "Restart"
   local return_to_title_label = "Return to Title"
   local max_width = max(#restart_label, #return_to_title_label)
   local margin = 4
   local gap = 4

   -- Using safer standard colors: 5 (dark grey), 12 (cyan), 7 (white), 0 (black)
   local buttons = {
      {"button", {text = restart_label, margin = margin, stroke = true, color = {5, 12, 7, 0}}},
      {"button", {text = return_to_title_label, margin = margin, stroke = true, color = {5, 12, 7, 0}}}
   }

   local buttons_stack_pos = vec(
      SCREEN_WIDTH / 2 - (max_width * 5 + margin * 2) / 2,
      SCREEN_HEIGHT / 2 + 10 -- Positioned slightly below center
   )

   local stack = pgui:component("vstack", {
      pos = buttons_stack_pos,
      height = 0,
      box = false,
      stroke = false,
      margin = 0,
      gap = gap,
      contents = buttons,
      color = {0, 0, 0, 0}
   })

   restart_clicked = stack[1]
   return_to_title_clicked = stack[2]

   if return_to_title_clicked then self:gotoState("Title") end
   if restart_clicked then self:gotoState("Play") end
end

function GameOver:draw()
   -- Dark red/black background for game over
   cls(0)
   rectfill(0, SCREEN_HEIGHT / 2 - 40, SCREEN_WIDTH, SCREEN_HEIGHT / 2 + 60, 1) -- Dark blue/grey band

   local game_over = "GAME OVER"
   local text_x = SCREEN_WIDTH / 2 - (#game_over * 5) / 2
   local text_y = SCREEN_HEIGHT / 2 - 20

   -- Shadow/Outline for text
   print(game_over, text_x + 1, text_y + 1, 0)
   print(game_over, text_x, text_y, 8) -- Red text

   pgui:draw()
end

return GameOver

:: src/scenes/init.lua
-- Scenes module aggregator
-- Manager must be required first (scenes depend on it for addState)
local Manager = require("src/scenes/manager")
local Play = require("src/scenes/play")
local Title = require("src/scenes/title")
local GameOver = require("src/scenes/game_over")
local LevelUp = require("src/scenes/level_up")

local Scenes = {}
Scenes.Manager = Manager
Scenes.Play = Play
Scenes.Title = Title
Scenes.GameOver = GameOver
Scenes.LevelUp = LevelUp

return Scenes

:: src/scenes/level_up.lua
local SceneManager = require("src/scenes/manager")
local Pools = require("src/game/config/level_up")

local LevelUp = SceneManager:addState("LevelUp")

local player = nil
local bonuses = {}
local selected_index = 2 -- Middle card by default

function LevelUp:pushedState(player_entity)
   Log.trace("Entered LevelUp state")
   player = player_entity
   bonuses = {}

   -- Pick one random bonus from each pool
   add(bonuses, rnd(Pools.Player))
   add(bonuses, rnd(Pools.Egg))
   add(bonuses, rnd(Pools.Chick))

   selected_index = 2 -- Reset to center
end

function LevelUp:update()
   if btnp(0) then selected_index = math.max(1, selected_index - 1) end
   if btnp(1) then selected_index = math.min(3, selected_index + 1) end

   if btnp(4) or btnp(5) then -- O or X to select
      local bonus = bonuses[selected_index]
      if bonus then
         Log.info("Selected bonus: "..bonus.name)
         bonus.apply(player)
         self:popState()
      end
   end
end

function LevelUp:draw()
   -- Draw opaque background overlay (dithered or solid)
   -- Using solid dark color 5 (Dark Gray) for now as requested
   rectfill(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT, 5)

   -- Title
   local title = "LEVEL UP!"
   print(title, SCREEN_WIDTH / 2 - (#title * 4), 20, 7)

   -- Draw Cards
   local card_w, card_h = 120, 160
   local gap = 16
   local start_x = (SCREEN_WIDTH - (3 * card_w + 2 * gap)) / 2
   local start_y = 50

   for i = 1, 3 do
      local bonus = bonuses[i]
      local x = start_x + (i - 1) * (card_w + gap)
      local y = start_y

      -- Card Background
      local is_selected = (i == selected_index)
      local bg_color = 0                           -- Black card bg
      local border_color = is_selected and 12 or 1 -- Cyan if selected, Blue/White if not

      rectfill(x, y, x + card_w, y + card_h, bg_color)
      rect(x, y, x + card_w, y + card_h, border_color)

      -- Content
      local cx = x + card_w / 2

      -- Category
      local cat_color = 6 -- Grey
      print(bonus.category, cx - (#bonus.category * 4) / 2, y + 10, cat_color)

      -- Icon Placeholder (Circle)
      circ(cx, y + 50, 20, is_selected and 12 or 1)

      -- Name
      local name_color = is_selected and 7 or 6
      print(bonus.name, cx - (#bonus.name * 4) / 2, y + 90, name_color)

      -- Description (simple wrap)
      local desc_color = 6
      print(bonus.description, cx - (#bonus.description * 4) / 2, y + 110, desc_color)
   end

   -- Instruction
   local instr = "Select a Bonus"
   if (time() * 2) % 2 < 1 then
      print(instr, SCREEN_WIDTH / 2 - (#instr * 4) / 2, 240, 7)
   end
end

return LevelUp

:: src/scenes/manager.lua
local SceneManager = Class("SceneManager"):include(Stateful)

function SceneManager:initialize()
end

function SceneManager:update()
end

function SceneManager:draw()
end

return SceneManager

:: src/scenes/play.lua
local GameState = require("src/game/game_state")
local GameConstants = require("src/game/game_config")
local World = require("src/world")
local Entities = require("src/entities")
local Systems = require("src/systems")
local Emotions = require("src/systems/emotions")
local Events = require("src/game/events")
local UI = require("src/ui")
local Wander = require("src/ai/primitives/wander")
local AI = require("src/ai")
local Leveling = require("src/utils/leveling")
local Particles = require("src/systems/particles")

local DungeonManager = World.DungeonManager
local CameraManager = World.CameraManager
local RoomRenderer = World.RoomRenderer
local Minimap = UI.Minimap

local SceneManager = require("src/scenes/manager")

local Play = SceneManager:addState("Play")

world = eggs()
local player
local camera_manager
local current_room

function Play:enteredState()
   Log.trace("Entered Play scene")
   world = eggs() -- MUST re-initialize world on every entry for Restart to work
   Systems.init_extended_palette()
   Systems.init_spotlight()
   Particles.init()

   -- Initialize level seed for reproducible dungeon generation
   local seed = GameState.level_seed or flr(time() * 1000)
   srand(seed)
   GameState.current_seed = seed
   Log.info("Level seed: "..seed)

   DungeonManager.init()

   -- Spawn player at center of start room (World Pixels)
   local room = DungeonManager.current_room
   local px = room.pixels.x + room.pixels.w / 2
   local py = room.pixels.y + room.pixels.h / 2
   player = Entities.spawn_player(world, px, py)

   -- Initialize camera
   camera_manager = CameraManager:new(player)
   current_room = room
   camera_manager:set_room(current_room)

   -- Initialize minimap and mark starting room as visited
   Minimap.init()
   Minimap.visit(current_room)

   -- Subscribe to room transition events
   Events.on(Events.ROOM_TRANSITION, function(new_room)
      current_room = new_room
      DungeonManager.current_room = new_room
      camera_manager:set_room(current_room)
      DungeonManager.setup_room(current_room, player, world)
      Minimap.visit(current_room) -- Mark new room as visited
      world.sys("projectile", function(e) world.del(e) end)()
      world.sys("pickup", function(e) world.del(e) end)()
      world.sys("skull", function(e) world.del(e) end)()
      -- Clean up enemies when unlock_all_rooms cheat is active
      if GameState.cheats.unlock_all_rooms then
         world.sys("enemy", function(e) world.del(e) end)()
      end
      -- Teleport minions to player in new room
      world.sys("minion", function(e)
         e.x = player.x
         e.y = player.y
         if e.chick_fsm then
            -- Reset behavior
            Wander.reset(e)
         end
      end)()
      Systems.FloatingText.clear()
      AI.ChickAI.clear_target() -- Clear painted target from previous room
   end)

   -- Subscribe to Level Up event
   Events.on(Events.LEVEL_UP, function(player_entity, new_level)
      self:pushState("LevelUp", player_entity)
   end)

   -- Subscribe to Game Over event
   Events.on(Events.GAME_OVER, function()
      self:gotoState("GameOver")
   end)

   -- Subscribe to room clear events
   Events.on(Events.ROOM_CLEAR, function(room)
      -- No healing on room clear anymore (as per new design)
   end)

   -- Setup debugui cheats toggles (clickable)
   -- Helper to sync toggle visual state without triggering tap callback
   local function sync_toggle_visual(toggle, cheat_value)
      if toggle.on ~= cheat_value then
         toggle.on = cheat_value
         -- Swap colors to reflect state
         toggle.bg_col, toggle.text_col = toggle.text_col, toggle.bg_col
      end
   end

   -- Cheats Group
   add(debugui.elements, debugui.create_group(7, debugui.config._ACCENT1_color, true, function(self)
      self.vars = {"[== cheats ==]"}
   end))

   local godmode_toggle = debugui.create_toggle(7, debugui.config._ACCENT3_color, "godmode",
      function(self) sync_toggle_visual(self, GameState.cheats.godmode) end,
      nil,
      function(self) GameState.cheats.godmode = not GameState.cheats.godmode end)
   add(debugui.elements, godmode_toggle)

   local free_attacks_toggle = debugui.create_toggle(7, debugui.config._ACCENT3_color, "free_attacks",
      function(self) sync_toggle_visual(self, GameState.cheats.free_attacks) end,
      nil,
      function(self) GameState.cheats.free_attacks = not GameState.cheats.free_attacks end)
   add(debugui.elements, free_attacks_toggle)

   local infinite_inv_toggle = debugui.create_toggle(7, debugui.config._ACCENT3_color, "infinite_inventory",
      function(self) sync_toggle_visual(self, GameState.cheats.infinite_inventory) end,
      nil,
      function(self) GameState.cheats.infinite_inventory = not GameState.cheats.infinite_inventory end)
   add(debugui.elements, infinite_inv_toggle)

   local unlock_rooms_toggle = debugui.create_toggle(7, debugui.config._ACCENT3_color, "unlock_all_rooms",
      function(self) sync_toggle_visual(self, GameState.cheats.unlock_all_rooms) end,
      nil,
      function(self) GameState.cheats.unlock_all_rooms = not GameState.cheats.unlock_all_rooms end)
   add(debugui.elements, unlock_rooms_toggle)

   -- Debug Group
   add(debugui.elements, debugui.create_group(7, debugui.config._ACCENT1_color, true, function(self)
      self.vars = {"[== debug ==]"}
   end))

   local hitboxes_toggle = debugui.create_toggle(7, debugui.config._ACCENT3_color, "show_hitboxes",
      function(self) sync_toggle_visual(self, GameState.debug.show_hitboxes) end,
      nil,
      function(self) GameState.debug.show_hitboxes = not GameState.debug.show_hitboxes end)
   add(debugui.elements, hitboxes_toggle)

   local grid_toggle = debugui.create_toggle(7, debugui.config._ACCENT3_color, "show_grid",
      function(self) sync_toggle_visual(self, GameState.debug.show_grid) end,
      nil,
      function(self) GameState.debug.show_grid = not GameState.debug.show_grid end)
   add(debugui.elements, grid_toggle)

   local combat_timer_toggle = debugui.create_toggle(7, debugui.config._ACCENT3_color, "show_combat_timer",
      function(self) sync_toggle_visual(self, GameState.debug.show_combat_timer) end,
      nil,
      function(self) GameState.debug.show_combat_timer = not GameState.debug.show_combat_timer end)
   add(debugui.elements, combat_timer_toggle)

   local pathfinding_toggle = debugui.create_toggle(7, debugui.config._ACCENT3_color, "show_pathfinding",
      function(self) sync_toggle_visual(self, GameState.debug.show_pathfinding) end,
      nil,
      function(self) GameState.debug.show_pathfinding = not GameState.debug.show_pathfinding end)
   add(debugui.elements, pathfinding_toggle)

   -- Player Stats Group (Real-time monitoring)
   local stats_group = debugui.create_group(7, debugui.config._ACCENT2_color, true,
      function(self)
         if not player then return end
         self.vars = {
            "[== player stats ==]",
            "hp: "..tostring(player.hp).."/"..tostring(player.max_hp),
            "overheal: "..tostring(player.overflow_hp or 0),
            "shot_speed: "..tostring(player.shot_speed),
            "range: "..tostring(player.range),
            "fire_rate: "..tostring(player.fire_rate),
            "[== mutations ==]",
            "Broodmother: "..tostring(player.mutations.Broodmother),
            "Eggsaggerated: "..tostring(player.mutations.Eggsaggerated),
            "Pureblood: "..tostring(player.mutations.Pureblood),
            "[== xp ==]",
            "level: "..tostring(player.level),
            "xp: "..tostring(player.xp).."/"..tostring(player.xp_to_next_level),
            "[== level ==]",
            "seed: "..tostring(GameState.current_seed),
         }
      end)
   add(debugui.elements, stats_group)

   -- Setup initial room
   DungeonManager.setup_room(current_room, player, world)
end

function Play:update()
   -- Update camera
   camera_manager:update()

   -- If scrolling, skip all gameplay systems
   if camera_manager:is_scrolling() then
      return
   end

   -- Update minimap logic (trigger detection and tweening)
   Minimap.update_trigger(player, camera_manager)
   Minimap.update()

   -- Update spawner
   Systems.Spawner.update(world, current_room)

   -- Check room clear
   DungeonManager.check_room_clear(current_room, world)

   -- Input
   world.sys("controllable", Systems.read_input)()

   -- Melee (health-gated attack)
   Systems.melee(world)

   -- Bomber (bomb placement and fuse countdown)
   Systems.bomber(world)

   -- Physics (self-iterating)
   Systems.acceleration(world)
   Systems.z_axis(world)
   Systems.knockback_pre(world) -- Add knockback to velocity before collision
   world.sys("map_collidable,velocity", function(e)
      Systems.resolve_map(e, current_room, camera_manager)
   end)()
   Systems.velocity(world)
   Systems.knockback_post(world) -- Decay knockback after movement

   -- Animation & Lifecycle (self-iterating)
   Systems.update_lifecycle(world)
   Systems.animation(world)

   -- Combat & AI (self-iterating)
   Systems.shooter(world)
   Systems.ai(world, player)
   Emotions.update(world)

   -- Resolve Entity Collisions (Optimized with single grid build)
   Systems.update_spatial_grid(world)
   world.sys("collidable,velocity", Systems.resolve_entities)()
   world.sys("collidable,player", Systems.resolve_entities)()       -- Ensure player checks even if idle
   world.sys("collidable,melee_hitbox", Systems.resolve_entities)() -- Melee hitbox vs Enemy collision

   -- Timers & Health (self-iterating)
   Systems.health_regen(world)
   Systems.timers(world)

   -- Shadows (self-iterating)
   Systems.sync_shadows(world)

   -- Effects & Particles
   Systems.Effects.update_shake()
   Systems.Effects.update_animations(world)
   Systems.FloatingText.update()
   Particles.update()

   -- Leveling (check for level ups after XP collection)
   Leveling.check_level_up(player)

   if keyp("f2") then
      GameState.debug.show_hitboxes = not GameState.debug.show_hitboxes
      GameState.debug.show_grid = not GameState.debug.show_grid
      GameState.debug.show_combat_timer = not GameState.debug.show_combat_timer
   end
   if keyp("f3") then
      GameState.cheats.godmode = not GameState.cheats.godmode
   end
   if keyp("f4") then
      GameState.cheats.free_attacks = not GameState.cheats.free_attacks
   end
   if keyp("f5") then
      GameState.cheats.infinite_inventory = not GameState.cheats.infinite_inventory
   end
   if keyp("f6") then
      GameState.cheats.unlock_all_rooms = not GameState.cheats.unlock_all_rooms
   end
end

function Play:draw()
   cls(0)

   local sx, sy = camera_manager:get_offset()
   local shake = Systems.Effects.get_shake_offset()
   local cam_x = sx + shake.x
   local cam_y = sy + shake.y
   camera(cam_x, cam_y)

   local clip_square
   if camera_manager:is_scrolling() then
      local old_room = camera_manager.old_room
      local new_room = camera_manager.new_room

      -- Set both rooms as visible during transition
      Systems.set_active_rooms({
         old_room.grid_x..","..old_room.grid_y,
         new_room.grid_x..","..new_room.grid_y
      })

      clip_square = RoomRenderer.draw_scrolling(camera_manager, cam_x, cam_y)
      RoomRenderer.draw_room_features(old_room)
      RoomRenderer.draw_room_features(new_room)
   else
      -- Set only current room as visible
      Systems.set_active_rooms({current_room.grid_x..","..current_room.grid_y})

      clip_square = RoomRenderer.draw_exploring(current_room, cam_x, cam_y)
      RoomRenderer.draw_room_features(current_room)

      if GameState.debug.show_grid then
         RoomRenderer.draw_debug_grid(current_room)
      end
   end

   -- Lighting (self-iterating)
   Systems.lighting(world, clip_square)

   -- 1. Background Layer: Shadows, Pickups
   Systems.draw_shadows(world, clip_square)
   Systems.draw_layer(world, "background,drawable", false)

   -- Boss Telegraphs (drawn behind entities but above background)
   UI.Hud.draw_boss_telegraphs(world)

   -- 2. Middleground Layer: Characters (Y-Sorted)
   Systems.draw_layer(world, "middleground,drawable", true)
   Emotions.draw(world)

   -- Particles clipped to room inner bounds (excludes walls)
   local inner = current_room:get_inner_bounds()
   local particle_clip = {
      x = inner.x1 * 16 - cam_x,
      y = inner.y1 * 16 - cam_y,
      w = (inner.x2 - inner.x1 + 1) * 16,
      h = (inner.y2 - inner.y1 + 1) * 16
   }
   Particles.draw(particle_clip)
   Systems.FloatingText.draw()

   -- 3. Global Effects & Debug
   Systems.apply_palette_swaps(world)
   Systems.Spawner.draw(current_room)

   pal()

   -- 4. Foreground Layer: Entity UI (Health Bars, Hitboxes)
   Systems.draw_health_bars(world)
   Systems.draw_aim_lines(world)

   if GameState.debug.show_hitboxes then
      Systems.draw_hitboxes(world)
   end

   -- Pathfinding Debug: Show chick paths and targets
   if GameState.debug.show_pathfinding then
      local PathFollow = require("src/ai/primitives/path_follow")
      local HitboxUtils = require("src/utils/hitbox_utils")
      world.sys("minion", function(e)
         if e.minion_type == "Chick" then
            -- Draw current path (green if exists)
            PathFollow.debug_draw(e, 11) -- Green path

            -- Draw FSM state above chick
            local state_name = e.chick_fsm and e.chick_fsm.current or "none"
            print(state_name, e.x - 16, e.y - 32, 7) -- White state name (higher up)

            -- Draw attack range circle (light blue - melee range)
            local attack_range = e.attack_range or 20
            circ(e.x + 8, e.y + 8, attack_range, 12) -- Light blue attack range

            -- Draw line to chase target
            if e.chase_target then
               local hb = HitboxUtils.get_hitbox(e)
               local ex, ey = hb.x + hb.w / 2, hb.y + hb.h / 2
               local thb = HitboxUtils.get_hitbox(e.chase_target)
               local tx, ty = thb.x + thb.w / 2, thb.y + thb.h / 2

               -- Calculate distance
               local dx, dy = tx - ex, ty - ey
               local dist = sqrt(dx * dx + dy * dy)

               -- Check if using direct fallback (no valid path)
               local has_path = e.path_state and e.path_state.path and #e.path_state.path > 0
               if has_path then
                  line(ex, ey, tx, ty, 11)              -- Green = has path
                  circfill(tx, ty, 4, 11)               -- Target circle
               else
                  line(ex, ey, tx, ty, 8)               -- Red = NO PATH (direct fallback!)
                  circfill(tx, ty, 4, 8)                -- Red target
                  print("NO PATH", ex - 16, ey - 16, 8) -- Alert text
               end

               -- Show distance vs attack range
               local in_range = dist < attack_range
               local range_text = string.format("d:%.0f/%.0f", dist, attack_range)
               print(range_text, ex - 20, ey - 32, in_range and 11 or 8)
            end
         end
      end)()
   end

   -- Shop Item Price Tags (world-space UI)
   if current_room and current_room.room_type == "shop" then
      UI.Hud.draw_shop_prices(world)
   end

   -- Reset camera for global UI
   camera()

   -- Draw HUD (Health Bar)
   UI.HealthBar.draw(player)

   -- Draw HUD (Inventory)
   UI.Hud.draw_inventory(player)

   -- Draw mutations
   UI.Hud.draw_mutations(player)

   -- Draw Boss Health Bar (if boss is present)
   UI.Hud.draw_boss_health(world)

   -- Draw XP bar
   UI.XpBar.draw(player)

   -- Draw minimap
   Minimap.draw(current_room)

   -- draw combat timer (debug)
   if GameState.debug.show_combat_timer and current_room.combat_timer and current_room.combat_timer >= 0 then
      local config = GameConstants.Hud.combat_timer
      local timer = current_room.combat_timer
      local minutes = math.floor(timer / 60)
      local seconds = timer % 60
      local timer_str = string.format("%02d:%02d", minutes, seconds)
      print(timer_str, config.x, config.y, config.color)
   end
end

function Play:exitedState()
   Log.trace("Exited Play scene")
   Events.reset()  -- Clear all event subscriptions
   pal()           -- Reset GFX color remaps
   palt()          -- Reset transparency
   poke(0x550b, 0) -- Reset pen palette row to 0
end

return Play

:: src/scenes/title.lua
local pgui             = require("lib/pgui")
local SceneManager     = require("src/scenes/manager")
local Title            = SceneManager:addState("Title")

local new_game_clicked = false
local quit_clicked     = false

function Title:enteredState()
	Log.trace("Entered Title scene")
	pal()
	palt()
	camera()
	poke(0x550b, 0)
end

function Title:update()
	pgui:refresh()
	local new_game_label    = "New Game"
	local quit_label        = "Quit"
	local max_width         = max(#new_game_label, #quit_label)
	local margin            = 3
	local gap               = 3
	local contents          = {
		{"button", {text = new_game_label, margin = margin, stroke = true}},
		{"button", {text = quit_label, margin = margin, stroke = true}}
	}
	local buttons_stack_pos = vec(SCREEN_WIDTH / 2 - max_width * 5 / 2 - margin * 2,
		SCREEN_HEIGHT / 2 - #contents * 7 / 2 - margin * 2)
	local stack             = pgui:component("vstack", {
		pos      = buttons_stack_pos,
		height   = 0,
		box      = false,
		stroke   = false,
		margin   = 0,
		gap      = gap,
		contents = contents,
		color    = {16, 12, 7, 0}
	})

	new_game_clicked        = stack[1]
	quit_clicked            = stack[2]

	if new_game_clicked then self:gotoState("Play") end
	if quit_clicked then print("Clicked Quit", 0, 0, 7) end
end

function Title:exitedState()
	new_game_clicked = false
	quit_clicked = false
	Log.trace("Exited Title scene")
end

function Title:draw()
	cls(1)
	camera()
	local game_title_label = "Pizak"
	print(game_title_label, SCREEN_WIDTH / 2 - #game_title_label * 5 / 2, 10, 7)
	pgui:draw()
end

return Title

:: src/systems.lua
return require("src/systems/init")

:: src/systems/ai.lua
local AI = require("src/ai")
local PathFollow = require("src/ai/primitives/path_follow")
local AISystem = {}

-- AI system: orchestrates AI updates for enemies and minions
-- Each AI profile handles nil player gracefully (idle/wander behavior)
-- @param world - ECS world
-- @param player - Player entity (may be nil if player is dead)
function AISystem.update(world, player)
   -- OPTIMIZATION: Reset pathfinding frame budget at start of each update
   PathFollow.reset_frame_budget()

   -- Execute AI dispatch for all enemies
   world.sys("enemy", function(entity)
      AI.dispatch(entity, player)

      -- Boss minion summoning: if boss AI set summon_pending, spawn minions
      if entity.summon_pending then
         entity.summon_pending = false
         local Entities = require("src/entities")
         local summon_count = entity.summon_count or 2
         local max_skulkers = 6 -- Hard cap on skulkers in the room

         -- Count existing Skulkers
         local skulker_count = 0
         world.sys("enemy", function(e)
            if e.enemy_type == "Skulker" and not e.dead then
               skulker_count = skulker_count + 1
            end
         end)()

         -- Calculate how many we can spawn without exceeding cap
         local spawn_allowed = max(0, max_skulkers - skulker_count)
         local actual_spawn = min(summon_count, spawn_allowed)

         if actual_spawn > 0 then
            Log.info("Boss summoning: "..actual_spawn.." skulkers (cap: "..skulker_count.."/"..max_skulkers..")")

            -- Spawn Skulker enemies around the boss
            for i = 1, actual_spawn do
               local offset_x = (rnd(1) - 0.5) * 64
               local offset_y = (rnd(1) - 0.5) * 64
               Entities.spawn_enemy(world, entity.x + offset_x, entity.y + offset_y, "Skulker")
            end
         end
      end
   end)()

   -- Execute AI dispatch for all minions
   world.sys("minion", function(entity)
      AI.dispatch_minion(entity, world)
   end)()
end

return AISystem

:: src/systems/animation.lua
-- Pure animation system: sprite frame calculation and visual updates only
local EntityUtils = require("src/utils/entity_utils")

local Animation = {}

-- Default speed fallback (ticks per frame)
local DEFAULT_SPEED = 8

-- Calculate frame index from durations array or single speed
local function get_frame_from_durations(durations, speed, timer, frame_count)
   if durations and #durations > 0 then
      local total_duration = 0
      for _, d in ipairs(durations) do
         total_duration = total_duration + d
      end
      local cycle_time = timer % total_duration
      local accumulated = 0
      for i, d in ipairs(durations) do
         accumulated = accumulated + d
         if cycle_time < accumulated then
            return i - 1, total_duration -- 0-indexed frame
         end
      end
      return #durations - 1, total_duration
   else
      return flr(timer / speed) % frame_count, frame_count * speed
   end
end

-- Helper to find the best matching animation config
local function find_animation_config(config, state, direction)
   if not config or not config.animations then return nil end
   local animations = config.animations

   -- 1. Try directional state: animations.down.walking
   local dir_anims = animations[direction]
   if dir_anims and type(dir_anims) == "table" then
      local state_anim = dir_anims[state]
      if state_anim then return state_anim end

      -- 2. Try directional idle fallback
      state_anim = dir_anims["idle"]
      if state_anim then return state_anim end

      -- 3. Try using dir_anims directly if it's an animation object
      if dir_anims.indices or dir_anims.base or dir_anims.top_indices then
         return dir_anims
      end
   end

   -- 4. Try global state fallback
   if animations[state] then return animations[state] end

   -- 5. Try global idle fallback
   return animations["idle"]
end

-- Main animation update: calculates sprite indices and flip flags
function Animation.animate(world, entity)
   -- Increment animation timer
   entity.anim_timer = (entity.anim_timer or 0) + 1

   -- Get current state and direction
   local state = entity.fsm and entity.fsm.current or "idle"
   local direction = entity.current_direction or entity.direction or "down"

   -- Update direction based on movement (only when moving)
   local is_moving = (abs(entity.vel_x or 0) > 0.1 or abs(entity.vel_y or 0) > 0.1)
   if is_moving then
      entity.current_direction = EntityUtils.get_direction_name(
         entity.vel_x or 0,
         entity.vel_y or 0,
         entity.current_direction
      ) or direction
      direction = entity.current_direction
   end

   local config = EntityUtils.get_config(entity)
   local state_anim = find_animation_config(config, state, direction)

   local current_frame_idx = 0
   local total_duration = 0

   if state_anim then
      local speed = state_anim.speed or DEFAULT_SPEED
      local durations = state_anim.durations

      if state_anim.top_indices or state_anim.bottom_indices then
         -- Composite sprite (top/bottom halves)
         local top_indices = state_anim.top_indices or {0}
         local bottom_indices = state_anim.bottom_indices or {0}

         local frame_idx, duration = get_frame_from_durations(durations, speed, entity.anim_timer, #top_indices)
         local b_frame_idx = get_frame_from_durations(durations, speed, entity.anim_timer, #bottom_indices)

         current_frame_idx = frame_idx
         total_duration = duration
         entity.sprite_top = top_indices[(frame_idx % #top_indices) + 1] or 0
         entity.sprite_bottom = bottom_indices[(b_frame_idx % #bottom_indices) + 1] or 0
         entity.split_row = state_anim.split_row or flr((entity.height or 16) / 2)
         entity.sprite_index = nil
      elseif state_anim.indices then
         -- Explicit indices array
         local indices = state_anim.indices
         local frame_idx, duration = get_frame_from_durations(durations, speed, entity.anim_timer, #indices)

         current_frame_idx = frame_idx
         total_duration = duration
         entity.sprite_top = nil
         entity.sprite_bottom = nil
         entity.split_row = nil
         entity.sprite_index = indices[(frame_idx % #indices) + 1] or 0
      elseif state_anim.base then
         -- Base sprite + frame offset
         local frames = state_anim.frames or 2
         local frame_idx, duration = get_frame_from_durations(durations, speed, entity.anim_timer, frames)

         current_frame_idx = frame_idx
         total_duration = duration
         entity.sprite_top = nil
         entity.sprite_bottom = nil
         entity.split_row = nil
         entity.sprite_index = state_anim.base + frame_idx
      end

      -- Apply flip configuration
      local fx = state_anim.flip_x or state_anim.flip or false
      local fy = state_anim.flip_y or false

      -- Per-frame flip support
      if state_anim.flips and state_anim.flips[current_frame_idx + 1] then
         local f = state_anim.flips[current_frame_idx + 1]
         fx = f.x ~= nil and f.x or fx
         fy = f.y ~= nil and f.y or fy
      end

      entity.flip_x = fx
      entity.flip_y = fy
   else
      -- Fallback: simple 2-frame loop using sprite_index_offsets
      local base_sprite = 0
      if config and config.sprite_index_offsets then
         base_sprite = config.sprite_index_offsets[direction] or 0
      end
      current_frame_idx = flr(entity.anim_timer / DEFAULT_SPEED) % 2
      total_duration = DEFAULT_SPEED * 2

      entity.sprite_top = nil
      entity.sprite_bottom = nil
      entity.split_row = nil
      entity.sprite_index = base_sprite + current_frame_idx
      entity.flip_x = false
      entity.flip_y = false
   end

   -- Notify lifecycle system if animation completed
   if total_duration > 0 and entity.anim_timer >= total_duration then
      -- Set completion flags for usage by Lifecycle system
      entity.anim_complete_state = state
      entity.anim_looping = state_anim and state_anim.loop
   else
      entity.anim_complete_state = nil
   end
end

-- Simple direction-based sprite change (for non-FSM entities)
local function change_sprite(entity)
   if entity.fsm then return end -- FSM entities use animate()

   local dx = entity.dir_x or 0
   local dy = entity.dir_y or 0
   local neutral = (dx == 0 and dy == 0)
   local down = (dx == 0 and dy == 1)
   local down_right = (dx == 1 and dy == 1)
   local down_left = (dx == -1 and dy == 1)
   local right = (dx == 1 and dy == 0)
   local up_right = (dx == 1 and dy == -1)
   local up = (dx == 0 and dy == -1)
   local up_left = (dx == -1 and dy == -1)
   local left = (dx == -1 and dy == 0)
   local sprite_index
   local flip = false

   local config = EntityUtils.get_config(entity)
   if not config then return end

   -- Skip if entity doesn't have directional sprites (uses static sprite_index)
   if not config.sprite_index_offsets then return end

   if neutral or down then sprite_index = config.sprite_index_offsets.down end
   if right or down_right or up_right then sprite_index = config.sprite_index_offsets.right end
   if up or up_left or down_left then sprite_index = config.sprite_index_offsets.up end
   if left or up_left or down_left then
      sprite_index = config.sprite_index_offsets.right
      flip = true
   end

   entity.base_sprite_index = sprite_index
   entity.sprite_index = sprite_index
   entity.flip_x = flip
   entity.flip_y = false
end

-- Update all animations
-- @param world - ECS world
function Animation.update(world)
   -- Update direction-based sprites for simple entities
   world.sys("sprite", change_sprite)()

   -- Update FSM-based animations
   world.sys("animatable", function(e) Animation.animate(world, e) end)()
end

return Animation

:: src/systems/bomber.lua
-- Bomber system
-- Handles bomb placement on X button press and fuse countdown/explosion

local GameState = require("src/game/game_state")
local GameConstants = require("src/game/game_config")
local Entities = require("src/entities")
local HitboxUtils = require("src/utils/hitbox_utils")
local Particles = require("src/systems/particles")
local Effects = require("src/systems/effects")

local Bomber = {}

-- Bomb placement cooldown (prevent spam)
local BOMB_COOLDOWN = 30 -- Half second

function Bomber.update(world)
   -- Handle player bomb placement
   world.sys("player,controllable", function(player)
      -- Check cooldown
      if player.bomb_cooldown and player.bomb_cooldown > 0 then
         player.bomb_cooldown -= 1
         return
      end

      -- Check if X button pressed and player has bombs (or infinite inventory)
      local input_pressed = btnp(GameConstants.controls.place_bomb)
      local has_bombs = (player.bombs and player.bombs > 0) or GameState.cheats.infinite_inventory

      if input_pressed and has_bombs then
         -- Consume bomb from inventory if not infinite
         if not GameState.cheats.infinite_inventory then
            player.bombs -= 1
         end

         -- Spawn bomb at player's hitbox center
         local hb = HitboxUtils.get_hitbox(player)
         local cx = hb.x + hb.w / 2
         local cy = hb.y + hb.h / 2
         Entities.spawn_bomb(world, cx, cy)

         -- Set cooldown
         player.bomb_cooldown = BOMB_COOLDOWN
      end
   end)()

   -- Handle bomb fuse countdown and explosion
   world.sys("bomb", function(bomb)
      -- Decrement fuse timer
      if bomb.fuse_timer then
         bomb.fuse_timer -= 1

         -- Blinking red flash as bomb is about to explode
         local blink_interval
         if bomb.fuse_timer < 30 then
            blink_interval = 2 -- Fast blinking in last 0.5 seconds
         elseif bomb.fuse_timer < 60 then
            blink_interval = 4 -- Medium blinking
         elseif bomb.fuse_timer < 90 then
            blink_interval = 8 -- Slow blinking when starting to warn
         end

         if blink_interval then
            -- Toggle flash on/off based on frame modulo
            if bomb.fuse_timer % (blink_interval * 2) < blink_interval then
               bomb.flash_timer = 1
               bomb.flash_color = 8 -- Red
            else
               bomb.flash_timer = 0
            end
         end

         if bomb.fuse_timer <= 0 then
            -- Explode! Spawn 3x3 grid of explosions
            local radius = bomb.explosion_radius or 1
            Entities.spawn_explosion_grid(world, bomb.x, bomb.y, radius)

            -- Explosion particles at bomb center
            local cx = bomb.x + (bomb.width or 16) / 2
            local cy = bomb.y + (bomb.height or 16) / 2
            Particles.spawn_burst(cx, cy, "explosion") -- Uses preset count

            -- Strong screen shake
            Effects.screen_shake(6, 8)
            -- Destroy obstacles in explosion area
            Bomber.destroy_obstacles_in_radius(world, bomb.x, bomb.y, radius)

            -- Delete the bomb entity
            world.del(bomb)
         end
      end
   end)()
end

-- Helper: Destroy all obstacles within the explosion radius
-- NOTE: This explicitly excludes chests from destruction
function Bomber.destroy_obstacles_in_radius(world, center_x, center_y, radius)
   world.sys("obstacle", function(obstacle)
      -- Skip chests - bombs should not destroy them
      if obstacle.is_chest then
         return
      end

      -- Check if obstacle is within explosion radius
      local ox = obstacle.x + (obstacle.width or 16) / 2
      local oy = obstacle.y + (obstacle.height or 16) / 2

      local dx = abs(ox - center_x)
      local dy = abs(oy - center_y)

      -- Within grid radius (in pixels)
      local max_dist = (radius + 0.5) * GRID_SIZE

      if dx <= max_dist and dy <= max_dist then
         -- Destroy the obstacle
         if not obstacle.dead then
            obstacle.dead = true
            world.del(obstacle)
         end
      end
   end)()
end

return Bomber

:: src/systems/effects.lua
-- Effects system: reusable visual, audio, and physical feedback
local Particles = require("src/systems/particles")

local Effects = {}
-- Screen shake state
local shake_timer = 0
local shake_intensity = 0

-- Sprite flash state (per entity)
-- entity.flash_timer and entity.flash_color set dynamically

-- Screen shake effect
function Effects.screen_shake(intensity, duration)
   shake_intensity = max(shake_intensity, intensity or 2)
   shake_timer = max(shake_timer, duration or 3)
end

-- Update shake (call from main game loop)
function Effects.update_shake()
   if shake_timer > 0 then
      shake_timer -= 1
      if shake_timer <= 0 then
         shake_intensity = 0
      end
   end
end

-- Get shake offset (call from draw loop, add to camera scroll)
function Effects.get_shake_offset()
   if shake_timer > 0 and shake_intensity > 0 then
      return {
         x = (rnd(2) - 1) * shake_intensity,
         y = (rnd(2) - 1) * shake_intensity
      }
   end
   return {x = 0, y = 0}
end

-- Flash sprite effect
function Effects.flash_sprite(entity, frames, color)
   entity.flash_timer = frames or 3
   entity.flash_color = color or 7 -- white by default
end

-- Update sprite flash (call from drawable system)
function Effects.update_flash(entity)
   if entity.flash_timer and entity.flash_timer > 0 then
      entity.flash_timer -= 1

      -- Solid flash for entire duration
      -- Swap all sprite colors to flash color using DRAW palette (Picotron has 64 colors)
      for i = 1, 63 do -- Skip 0 (transparent)
         pal(i, entity.flash_color or 7, 0)
      end
   end
   -- Note: Palette reset happens after sprite draw in play.lua
end

-- Spawn particle effect using batch particle system
function Effects.spawn_particles(x, y, ptype, count)
   Particles.spawn_burst(x, y, ptype, count)
end

--- Spawn a temporary visual effect sprite at position
---
--- @param world - ECS world
--- @param x, y - spawn position
--- @param sprite_index - sprite to display
--- @param lifespan - frames before removal (default 15)
function Effects.spawn_visual_effect(world, x, y, sprite_index, lifespan)
   lifespan = lifespan or 15
   local effect = {
      type = "VisualEffect",
      x = x,
      y = y,
      width = 16,
      height = 16,
      sprite_index = sprite_index,
      lifespan = lifespan,
   }
   world.ent("drawable,sprite,timers,middleground", effect)
end

-- Apply knockback to target entity, pushing away from source
-- Uses separate knockback velocity that decays with friction
function Effects.apply_knockback(source, target, strength)
   strength = strength or 3

   -- Calculate direction from source center to target center
   local src_cx = source.x + (source.width or 0) / 2
   local src_cy = source.y + (source.height or 0) / 2
   local tgt_cx = target.x + (target.width or 0) / 2
   local tgt_cy = target.y + (target.height or 0) / 2

   local dx = tgt_cx - src_cx
   local dy = tgt_cy - src_cy

   -- Normalize direction
   local len = sqrt(dx * dx + dy * dy)
   if len > 0 then
      dx = dx / len
      dy = dy / len
   else
      -- Default push if overlapping exactly
      dx = 0
      dy = -1
   end

   -- Set knockback velocity (separate from movement velocity)
   -- This will be processed and decayed in the physics system
   target.knockback_vel_x = dx * strength
   target.knockback_vel_y = dy * strength
end

--- Apply stun and slow debuff to target entity ("Sticky Yolk" effect)
---
--- @param target Entity to debuff (must have velocity for movement)
--- @param stun_frames Frames of complete movement stop (~0.2s = 12)
--- @param slow_frames Frames of reduced speed (~1s = 60)
--- @param slow_factor Speed multiplier during slow (0.5 = 50% speed)
function Effects.apply_sticky_yolk(target, stun_frames, slow_frames, slow_factor)
   target.stun_timer = stun_frames or 12
   target.slow_timer = slow_frames or 60
   target.slow_factor = slow_factor or 0.5
end

-- Generic hit impact effect (reusable)
function Effects.hit_impact(source, target, intensity)
   intensity = intensity or "normal"

   -- Calculate impact point
   local px = (source.x + target.x) / 2
   local py = (source.y + target.y) / 2

   -- Visual effects
   Effects.spawn_particles(px, py, "hit_spark", 5)
   Effects.flash_sprite(target, 10, 7) -- 10 frames = ~166ms at 60fps

   -- Audio (context-based)
   if target.type == "Player" then
      -- sfx(2) -- pain sound (uncomment when SFX ready)
   elseif target.type == "Enemy" then
      -- sfx(5) -- hit sound (uncomment when SFX ready)
   end

   -- Screen shake (intensity-based)
   if intensity == "light_shake" then
      Effects.screen_shake(1, 2)
   elseif intensity == "normal_shake" then
      Effects.screen_shake(2, 3)
   elseif intensity == "heavy_shake" then
      Effects.screen_shake(4, 5)
   end
   -- "no_shake" or nil = no screen shake
end

-- Death explosion effect (reusable for enemy/player death)
function Effects.death_explosion(entity, ptype)
   ptype = ptype or "explosion"

   -- Bigger particle burst
   Effects.spawn_particles(entity.x + entity.width / 2, entity.y + entity.height / 2, ptype, 15)

   -- Flash before deletion
   Effects.flash_sprite(entity, 5, 7)

   -- Sound
   -- sfx(10) -- explosion sound (uncomment when SFX ready)
end

-- Pickup/collect effect
function Effects.pickup_collect(entity)
   Effects.spawn_particles(entity.x, entity.y, "sparkle", 8)
   -- sfx(6) -- pickup sound (uncomment when SFX ready)
end

-- Item Rise Animation (Zelda-style)
-- 1. Spawns item above origin
-- 2. Item rises slowly
-- 3. Floating text appears
-- 4. Item converts to normal pickup
function Effects.spawn_item_rise(world, x, y, sprite_index, item_name, on_finish_fn)
   local anim = {
      type = "ItemRiseAnim",
      x = x,
      y = y,
      y_start = y,
      width = 32,
      height = 32,
      sprite_index = sprite_index,
      rise_timer = 0,
      rise_duration = 60,
      item_name = item_name,
      on_finish = on_finish_fn,

      -- Drawing layer
      layer = "middleground",
   }
   world.ent("drawable,sprite,timers,middleground,item_rise_anim", anim)
end

-- Update item rise animations
function Effects.update_animations(world)
   world.sys("item_rise_anim", function(e)
      e.rise_timer += 1

      -- Slow rise (ease out?)
      -- Simple linear for now: 16 pixels up over 30 frames -> ~0.5 px/frame
      e.y -= 0.5

      if e.rise_timer >= e.rise_duration then
         if e.on_finish then
            e.on_finish(e)
         end

         -- Remove animation entity
         world.del(e)
      end
   end)()
end

return Effects

:: src/systems/emotions.lua
-- Emotions system: displays visual indicators above enemies based on AI state
local GameConstants = require("src/game/game_config")

local Emotions = {}

-- Set an emotion on an entity
-- @param entity: the entity to set the emotion on
-- @param emotion_type: "alert", "confused", or "idle"
function Emotions.set(entity, emotion_type)
    local config = GameConstants.Emotions[emotion_type]
    if not config then return end

    entity.emotion = emotion_type
    entity.emotion_timer = config.duration
    entity.emotion_phase = rnd(1) -- Random phase for bounce offset
end

-- Clear any active emotion on entity
function Emotions.clear(entity)
    entity.emotion = nil
    entity.emotion_timer = nil
    entity.emotion_phase = nil
end

-- Update emotion timers (call once per frame for all entities)
function Emotions.update(world)
    local function update_emotion(entity)
        if entity.emotion_timer then
            entity.emotion_timer = entity.emotion_timer - 1
            if entity.emotion_timer <= 0 then
                Emotions.clear(entity)
            end
        end
    end

    world.sys("enemy", update_emotion)()
    world.sys("minion", update_emotion)()
end

-- Draw emotion indicators above entities using print with p8scii controls
function Emotions.draw(world)
    local emotions_config = GameConstants.Emotions
    local offset_y = emotions_config.offset_y or -10
    local bounce_speed = emotions_config.bounce_speed or 0.15
    local bounce_height = emotions_config.bounce_height or 2
    local outline_col = emotions_config.outline_color or 0

    local function draw_emotion(entity)
        if not entity.emotion then return end

        local config = emotions_config[entity.emotion]
        if not config then return end

        -- Calculate position above entity center
        local cx = entity.x + (entity.width or 16) / 2 - 2
        local cy = entity.y + offset_y
        -- Add bounce animation
        local phase = entity.emotion_phase or 0
        local bounce = sin((t() * bounce_speed + phase) * 2 * 3.14159) * bounce_height

        -- Draw the emotion text with outline
        local TextUtils = require("src/utils/text_utils")
        local final_cy = cy + bounce
        TextUtils.print_outlined(config.text, cx, final_cy, config.color, outline_col)
    end

    world.sys("enemy", draw_emotion)()
    world.sys("minion", draw_emotion)()
end

return Emotions

:: src/systems/floating_text.lua
-- Floating Text System: displays damage/heal numbers above entities
local GameConstants = require("src/game/game_config")
local TextUtils = require("src/utils/text_utils")

local FloatingText = {}

-- Active floating text entries
local active_texts = {}

-- Configuration defaults
-- See src/game/config/effects.lua for the actual configuration.
local function get_config()
   return GameConstants.FloatingText
end

--- Spawn a floating text at an entity's position
---
--- @param x, y: world position (center of entity recommended)
--- @param amount: number or string to display
--- @param text_type: "damage", "heal", or "pickup" (optional, auto-detected from amount if omitted)
--- @param sprite_index: optional sprite index to display before the text
function FloatingText.spawn(x, y, amount, text_type, sprite_index)
   local config = get_config()

   -- Determine type from amount if not specified
   if not text_type then
      text_type = (type(amount) == "number" and amount < 0) and "damage" or "heal"
   end

   -- Determine color based on type
   local color = config[text_type.."_color"] or (text_type == "damage" and config.damage_color) or config.heal_color

   -- Format amount
   local text
   if type(amount) == "number" then
      local display_amount = flr(abs(amount))
      -- For pickups with sprites, show "+n" format
      if sprite_index then
         text = "+"..tostring(display_amount)
      else
         text = tostring(display_amount)
      end
   else
      text = tostring(amount)
   end

   -- Add slight random horizontal offset to prevent overlap
   local offset_x = (rnd(1) - 0.5) * config.spread

   -- Check for nearby active texts and stagger Y position to prevent overlap
   local base_y = y + config.offset_y
   local stagger_y = 0
   local stagger_amount = 10 -- Vertical spacing between stacked texts

   for _, existing in ipairs(active_texts) do
      -- Check if existing text is at similar position (within spread range)
      if abs(existing.x - (x + offset_x)) < 16 and abs(existing.y - base_y - stagger_y) < stagger_amount then
         stagger_y = stagger_y - stagger_amount
      end
   end

   local entry = {
      x = x + offset_x,
      y = base_y + stagger_y,
      text = text,
      color = color,
      timer = config.duration,
      rise_speed = config.rise_speed,
      outline_color = config.outline_color,
      fade_start = config.duration - config.fade_duration,
      sprite_index = sprite_index, -- optional sprite to draw
   }

   table.insert(active_texts, entry)
end

-- Convenience function to spawn damage text at an entity
function FloatingText.spawn_at_entity(entity, amount, text_type, sprite_index)
   local cx = entity.x + (entity.width or 16) / 2
   local cy = entity.y
   FloatingText.spawn(cx, cy, amount, text_type, sprite_index)
end

-- Update all active floating texts (call once per frame)
function FloatingText.update()
   local i = 1
   while i <= #active_texts do
      local entry = active_texts[i]
      entry.timer -= 1
      entry.y -= entry.rise_speed

      if entry.timer <= 0 then
         table.remove(active_texts, i)
      else
         i += 1
      end
   end
end

-- Draw all active floating texts (call during draw phase)
function FloatingText.draw()
   local config = get_config()

   for _, entry in ipairs(active_texts) do
      -- Calculate alpha based on remaining time (for fade effect)
      local alpha = 1
      if entry.timer < entry.fade_start then
         -- In fade phase
         alpha = entry.timer / entry.fade_start
      end

      -- Center the text horizontally
      local text_width = #entry.text * 4    -- Approximate character width
      local draw_x = entry.x - text_width / 2
      local draw_y = entry.y

      -- Draw with fade effect (Picotron supports fillp patterns for transparency)
      -- For simplicity, use color blinking during fade

      if alpha < 0.5 and (t() * 30) % 2 < 1 then
         -- Skip drawing every other frame during fade for blink effect
      else
         -- If we have a sprite, draw it first (8x8 scaled to fit)
         local sprite_width = 0
         if entry.sprite_index then
            sprite_width = config.icon_size + 2    -- sprite + small gap

            local ix = draw_x + (config.icon_offset_x or -4)
            local iy = draw_y + (config.icon_offset_y or -1)
            local isize = config.icon_size or 8

            -- Use sspr to scale 16x16 sprite down to target size
            -- sspr(s, sx, sy, sw, sh, dx, dy, dw, dh)
            sspr(entry.sprite_index, 0, 0, 16, 16, ix, iy, isize, isize)
         end

         TextUtils.print_outlined(entry.text, draw_x + sprite_width - 4, draw_y, entry.color, entry.outline_color)
      end
   end
end

-- Clear all active floating texts (e.g., on room transition)
function FloatingText.clear()
   active_texts = {}
end

-- Get count of active texts (for debugging)
function FloatingText.count()
   return #active_texts
end

return FloatingText

:: src/systems/health_regen.lua
-- Generic health regeneration system
local HealthRegen = {}

-- Regen system: works for ANY entity with "health_regen" tag
function HealthRegen.update(world)
   world.sys("health_regen", function(entity)
      if not entity.regen_rate or entity.regen_rate <= 0 then return end

      -- Track time since trigger (shooting, damage, etc.)
      entity.time_since_regen_trigger = (entity.time_since_regen_trigger or 0) + (1 / 60)

      -- Check trigger field (default: always regen)
      local trigger_field = entity.regen_trigger_field or "time_since_shot"
      local trigger_value = entity[trigger_field] or entity.time_since_regen_trigger
      local delay = entity.regen_delay or 3.0

      if trigger_value >= delay then
         entity.hp = entity.hp + (entity.regen_rate / 60)

         -- Handle overflow (banking for player, cap for enemies)
         if entity.hp > entity.max_hp then
            if entity.overflow_banking then
               entity.overflow_hp = (entity.overflow_hp or 0) + (entity.hp - entity.max_hp)
            end
            entity.hp = entity.max_hp
         end
      end
   end)()
end

return HealthRegen

:: src/systems/init.lua
-- Main systems module: aggregates all system modules
local PhysicsCore = require("src/physics")        -- Aggregator for collision, etc.
local PhysicsSys = require("src/systems/physics") -- Acceleration, Velocity
local Shooter = require("src/systems/shooter")
local Timers = require("src/systems/timers")
local Melee = require("src/systems/melee")
local Bomber = require("src/systems/bomber")
local HealthRegen = require("src/systems/health_regen")
local AISys = require("src/systems/ai")
local Rendering = require("src/systems/rendering")
local Lighting = require("src/systems/lighting")
local Shadows = require("src/systems/shadows")
local UI = require("src/systems/ui")
local Effects = require("src/systems/effects")
local Animation = require("src/systems/animation")
local Input = require("src/input")
local Spawner = require("src/systems/spawner")
local Lifecycle = require("src/lifecycle")
local FloatingText = require("src/systems/floating_text")

-- Merge all modules into a single Systems table for backward compatibility
local Systems = {}

-- Collision systems (from PhysicsCore aggregator)
Systems.CollisionHandlers = PhysicsCore.Handlers
Systems.resolve_entities = PhysicsCore.resolve_entities
Systems.update_spatial_grid = PhysicsCore.update_spatial_grid
Systems.resolve_map = PhysicsCore.resolve_map

-- Input (from top-level module)
Systems.read_input = Input.read_input

-- Physics systems (self-iterating)
Systems.acceleration = PhysicsSys.acceleration
Systems.velocity = PhysicsSys.velocity
Systems.knockback_pre = PhysicsSys.knockback_pre
Systems.knockback_post = PhysicsSys.knockback_post
Systems.z_axis = PhysicsSys.z_axis

-- Shooting & Health systems (self-iterating)
Systems.shooter = Shooter.update
Systems.health_regen = HealthRegen.update
Systems.timers = Timers.update
Systems.melee = Melee.update
Systems.bomber = Bomber.update

-- AI systems (self-iterating)
Systems.ai = AISys.update

-- Lighting systems (self-iterating)
Systems.init_extended_palette = Lighting.init_extended_palette
Systems.init_spotlight = Lighting.init_spotlight
Systems.lighting = Lighting.update

-- Shadow systems (self-iterating)
Systems.sync_shadows = Shadows.sync
Systems.draw_shadows = Shadows.draw

-- Rendering systems
Systems.draw_layer = Rendering.draw_layer
Systems.apply_palette_swaps = Rendering.apply_palette_swaps
Systems.set_active_rooms = Rendering.set_active_rooms

-- UI systems (self-iterating)
Systems.draw_health_bars = UI.draw_health_bars
Systems.draw_hitboxes = UI.draw_hitboxes
Systems.draw_aim_lines = UI.draw_aim_lines

-- Animation systems (self-iterating)
Systems.animation = Animation.update

-- Lifecycle systems
Systems.init_lifecycle = Lifecycle.init
Systems.update_lifecycle = Lifecycle.update

-- Effects systems
Systems.Effects = Effects

-- Spawner system
Systems.Spawner = Spawner

-- Floating Text system
Systems.FloatingText = FloatingText

return Systems

:: src/systems/lighting.lua
local Palette = require("src/utils/palette")

local Lighting = {}

local spotlight_initialized = false

-- Initialize extended palette via utility
function Lighting.init_extended_palette()
   Palette.init_extended_palette()
end

-- Initialize spotlight color table
function Lighting.init_spotlight()
   if spotlight_initialized then return end
   Lighting.reset_spotlight()
   spotlight_initialized = true
end

-- Reset spotlight color mappings
function Lighting.reset_spotlight()
   local spotlight_row_address = 0x8000 + LIGHTING_SPOTLIGHT_COLOR * 64
   local shadow_row_address = 0x8000 + LIGHTING_SHADOW_COLOR * 64

   for target_col = 0, 63 do
      local bright_col, dark_col

      bright_col = target_col
      dark_col = target_col

      if target_col <= 15 then
         bright_col = 32 + target_col
         dark_col = 48 + target_col
      elseif target_col >= 32 and target_col <= 47 then
         local base = target_col - 32
         dark_col = 48 + base
      elseif target_col >= 48 and target_col <= 63 then
         local base = target_col - 48
         bright_col = base
      end

      poke(spotlight_row_address + target_col, bright_col)
      poke(shadow_row_address + target_col, dark_col)
   end

   poke(0x550b, 0x3f)
end

-- Draw spotlight circle for an entity
-- @param entity - Entity with spotlight tag
-- @param clip_square - Clipping rectangle {x, y, w, h}
local function draw_spotlight_entity(entity, clip_square)
   local center_x = entity.x + (entity.width or 16) / 2
   local center_y = entity.y + (entity.height or 16) / 2
   local radius = entity.spotlight_radius or 48

   clip(clip_square.x, clip_square.y, clip_square.w, clip_square.h)
   circfill(center_x, center_y, radius, LIGHTING_SPOTLIGHT_COLOR)
   clip()
end

-- Update lighting for all spotlight entities
-- @param world - ECS world
-- @param clip_square - Clipping rectangle
function Lighting.update(world, clip_square)
   Lighting.reset_spotlight()
   world.sys("spotlight", function(entity)
      draw_spotlight_entity(entity, clip_square)
   end)()
end

return Lighting

:: src/systems/melee.lua
-- Melee attack system
local GameConstants = require("src/game/game_config")
local GameState = require("src/game/game_state")
local Render = require("src/systems/rendering")
local EntityUtils = require("src/utils/entity_utils")

local Melee = {}

function Melee.update(world)
   -- Only players can melee for now
   world.sys("player,controllable", function(player)
      -- Check cooldown (free_attacks cheat bypasses cooldown)
      if not world.msk(player).aiming then return end
      if not GameState.cheats.free_attacks and player.melee_cooldown and player.melee_cooldown > 0 then return end

      local input_pressed = btn(GameConstants.controls.attack)

      -- Health gating: Only allowed if HP < max_hp * ratio
      -- free_attacks cheat bypasses this check
      local ratio = player.melee_threshold_ratio or (1 / 5)
      local health_threshold = player.max_hp * ratio
      local low_health = player.hp < health_threshold or GameState.cheats.free_attacks

      if input_pressed and low_health then
         -- Trigger attack animation
         if player.fsm then player.fsm:attack() end

         -- Pay health cost (skip if free_attacks cheat active)
         if not GameState.cheats.free_attacks then
            local cost = player.melee_cost or 10
            player.hp = math.max(1, player.hp - cost)
         end

         -- Set cooldown
         player.melee_cooldown = GameConstants.Player.melee_cooldown

         -- Calculate spawn position and rotation
         local range = GameConstants.Player.melee_range

         -- Use facing direction (persistent) per user request
         local dir = player.current_direction or "down"
         local dx, dy = EntityUtils.get_direction_vector(dir)
         local hb_config = GameConstants.Player.melee_hitboxes[dir]
         local spawn_x = player.x + dx * range + hb_config.ox
         local spawn_y = player.y + dy * range + hb_config.oy

         -- Determine rotation angle (0=Up, 90=Right, 180=Down, 270=Left)
         local angle = 0
         if math.abs(dx) > math.abs(dy) then
            if dx > 0 then angle = 90 else angle = 270 end
         else
            if dy > 0 then angle = 180 else angle = 0 end
         end

         -- Calculate damage based on missing health + bonus
         local damage = math.floor((player.max_hp - player.hp) / 4)
         damage = math.max(1, damage) + (player.melee_bonus_damage or 0)

         -- Spawn MeleeHitbox
         local hitbox = {
            type = "MeleeHitbox",
            -- Initial position
            x = spawn_x,
            y = spawn_y,
            -- Store relative offset for position syncing
            offset_x = dx * range + hb_config.ox,
            offset_y = dy * range + hb_config.oy,

            width = GameConstants.Player.melee_width,
            height = GameConstants.Player.melee_height,
            -- Visual properties
            sprite_index = GameConstants.Player.melee_sprite,
            rotation_angle = angle,
            outline_color = 1,
            -- System tags (added 'melee_hitbox' tag for syncing)
            lifespan = GameConstants.Player.melee_duration,
            owner_entity = player,
            melee_damage = damage,
            -- Adjust hitbox centering (offsets already applied to position, so use 0 here)
            hitbox_width = hb_config.w,
            hitbox_height = hb_config.h,
            hitbox_offset_x = 0,
            hitbox_offset_y = 0,
            -- Track enemies already hit (prevents multi-proc on same enemy)
            hit_list = {}
         }

         EntityUtils.spawn_entity(world, "collidable,drawable,timers,middleground,melee_hitbox", hitbox)
      end
   end)()

   -- Sync melee hitbox positions with their owners
   world.sys("melee_hitbox", function(hitbox)
      local owner = hitbox.owner_entity
      if owner and owner.x then
         hitbox.x = owner.x + (hitbox.offset_x or 0)
         hitbox.y = owner.y + (hitbox.offset_y or 0)
      else
         -- Owner dead/gone? Delete hitbox
         world.del(hitbox)
      end
   end)()
end

return Melee

:: src/systems/particles.lua
-- Particle System using Picotron batch GFX operations
-- Uses userdata pools for efficient CPU usage

local Particles = {}

-- Configuration
local MAX_PARTICLES = 256
local GRAVITY = 0.15
local FRICTION = 0.98

-- Particle pool (columns: x, y, vx, vy, life, color, size)
local pool = nil
local draw_buf = nil

-- Particle type presets
local PRESETS = {
   hit_spark = {
      count = 5,
      speed_min = 1.5,
      speed_max = 3.0,
      life_min = 8,
      life_max = 15,
      size_min = 1,
      size_max = 2,
      colors = {7, 10, 9, 25}, -- white, yellow, orange, dark orange
      gravity = 0,
      friction = 0.9,
   },
   yolk = {
      count = 8,
      speed_min = 0.8,
      speed_max = 2,
      life_min = 15,
      life_max = 30,
      size_min = 1,
      size_max = 2,
      colors = {9, 25}, -- dark orange
      gravity = 0,
      friction = 1,
   },
   explosion = {
      count = 50,
      speed_min = 2.0,
      speed_max = 4,
      life_min = 15,
      life_max = 30,
      size_min = 2,
      size_max = 4,
      colors = {10, 9, 25, 24}, -- yellow, orange, dark orange, dark red
      gravity = 0.05,
      friction = 0.95,
   },
   blood = {
      count = 6,
      speed_min = 0.5,
      speed_max = 2.0,
      life_min = 20,
      life_max = 40,
      size_min = 1,
      size_max = 3,
      colors = {8, 2, 1}, -- red, dark red, dark blue
      gravity = 0.2,
      friction = 0.98,
   },
   smoke = {
      count = 4,
      speed_min = 0.2,
      speed_max = 0.5,
      life_min = 30,
      life_max = 60,
      size_min = 2,
      size_max = 4,
      colors = {6, 5, 1}, -- gray, dark gray, dark blue
      gravity = -0.02,    -- rises
      friction = 0.99,
   },
   sparkle = {
      count = 8,
      speed_min = 0.3,
      speed_max = 1.0,
      life_min = 10,
      life_max = 25,
      size_min = 1,
      size_max = 1,
      colors = {7, 10, 12, 11}, -- white, yellow, cyan, green
      gravity = 0,
      friction = 0.95,
   },
   muzzle_flash = {
      count = 4,
      speed_min = 1.5,
      speed_max = 3.0,
      life_min = 8,
      life_max = 15,
      size_min = 1,
      size_max = 2,
      colors = {7, 6, 12}, -- white, light gray, light blue
      gravity = 0,
      friction = 0.8,
   },
}

--- Initialize the particle system
function Particles.init()
   -- Create particle pool: x, y, vx, vy, life, color, size, gravity, friction
   pool = userdata("f64", 9, MAX_PARTICLES)
   -- Zero out pool (all particles dead)
   for i = 0, MAX_PARTICLES - 1 do
      pool:set(0, i, 0, 0, 0, 0, 0, 0, 0, 0, 0)
   end

   -- Create reusable draw buffer for circfill batch
   draw_buf = userdata("f64", 4, MAX_PARTICLES)
end

--- Find next free slot in pool
--- @return number|nil Free slot index or nil if pool is full
local function find_free_slot()
   for i = 0, MAX_PARTICLES - 1 do
      if pool:get(4, i) <= 0 then -- life column
         return i
      end
   end
   return nil
end

--- Spawn a single particle
--- @param x number X position
--- @param y number Y position
--- @param vx number X velocity
--- @param vy number Y velocity
--- @param life number Lifetime in frames
--- @param color number Draw color
--- @param size number Radius
--- @param gravity number|nil Gravity (default 0)
--- @param friction number|nil Friction (default 1)
function Particles.spawn(x, y, vx, vy, life, color, size, gravity, friction)
   local slot = find_free_slot()
   if not slot then return end

   pool:set(0, slot,
      x, y, vx, vy, life, color, size,
      gravity or 0,
      friction or 1
   )
end

--- Spawn a burst of particles with preset type
--- @param x number Center X
--- @param y number Center Y
--- @param ptype string Particle type ("hit_spark", "explosion", etc)
--- @param count number|nil Override count
--- @param colors table|nil Override colors array
function Particles.spawn_burst(x, y, ptype, count, colors)
   local preset = PRESETS[ptype]
   if not preset then return end

   count = count or preset.count
   colors = colors or preset.colors

   for i = 1, count do
      -- Random direction
      local angle = rnd(1) * 6.2832 -- 2*pi
      local speed = preset.speed_min + rnd(1) * (preset.speed_max - preset.speed_min)
      local vx = cos(angle / 6.2832) * speed
      local vy = sin(angle / 6.2832) * speed

      -- Random properties
      local life = preset.life_min + flr(rnd(1) * (preset.life_max - preset.life_min + 1))
      local color = colors[flr(rnd(1) * #colors) + 1]
      local size = preset.size_min + flr(rnd(1) * (preset.size_max - preset.size_min + 1))

      Particles.spawn(x, y, vx, vy, life, color, size, preset.gravity, preset.friction)
   end
end

--- Update all particles (physics + decay)
function Particles.update()
   if not pool then return end

   for i = 0, MAX_PARTICLES - 1 do
      local life = pool:get(4, i)
      if life > 0 then
         -- Get current values
         local x = pool:get(0, i)
         local y = pool:get(1, i)
         local vx = pool:get(2, i)
         local vy = pool:get(3, i)
         local gravity = pool:get(7, i)
         local friction = pool:get(8, i)

         -- Apply gravity
         vy = vy + gravity

         -- Apply friction
         vx = vx * friction
         vy = vy * friction

         -- Update position
         x = x + vx
         y = y + vy

         -- Decrement life
         life = life - 1

         -- Write back
         pool:set(0, i, x, y, vx, vy, life)
      end
   end
end

--- Draw all living particles using batch circfill
--- @param clip_bounds table|nil Optional clip bounds {x, y, w, h}
function Particles.draw(clip_bounds)
   if not pool or not draw_buf then return end

   -- Apply clipping if bounds provided
   if clip_bounds then
      clip(clip_bounds.x, clip_bounds.y, clip_bounds.w, clip_bounds.h)
   end

   local count = 0

   -- Extract living particles into draw buffer
   for i = 0, MAX_PARTICLES - 1 do
      local life = pool:get(4, i)
      if life > 0 then
         -- Copy x, y, size, color to draw buffer
         draw_buf:set(0, count,
            pool:get(0, i), -- x
            pool:get(1, i), -- y
            pool:get(6, i), -- size (radius)
            pool:get(5, i)  -- color
         )
         count = count + 1
      end
   end

   -- Batch draw all living particles
   if count > 0 then
      circfill(draw_buf, 0, count, 4, 4)
   end

   -- Reset clipping
   if clip_bounds then
      clip()
   end
end

--- Get current active particle count (for debugging)
--- @return number Active particle count
function Particles.get_count()
   if not pool then return 0 end
   local count = 0
   for i = 0, MAX_PARTICLES - 1 do
      if pool:get(4, i) > 0 then
         count = count + 1
      end
   end
   return count
end

return Particles

:: src/systems/physics.lua
-- Physics and movement systems
-- Handles acceleration, friction, and velocity application
local Entities = require("src/entities")
local Effects = require("src/systems/effects")
local DungeonManager = require("src/world/dungeon_manager")

local Physics = {}

-- Internal: apply acceleration, friction, and clamp velocity
local function apply_acceleration(entity)
   -- Handle stun: no movement at all
   if entity.stun_timer and entity.stun_timer > 0 then
      entity.stun_timer = entity.stun_timer - 1
      entity.vel_x = 0
      entity.vel_y = 0
      return
   end

   local dx = entity.dir_x or 0
   local dy = entity.dir_y or 0

   -- Normalize acceleration for diagonal movement
   local accel = entity.accel
   if dx ~= 0 and dy ~= 0 then
      accel = accel * 0.7071 -- sqrt(2)/2 for diagonal
   end

   -- Apply acceleration
   if dx ~= 0 then entity.vel_x += dx * accel end
   if dy ~= 0 then entity.vel_y += dy * accel end

   -- Apply friction when not actively moving in a direction
   if dx == 0 then entity.vel_x *= entity.friction end
   if dy == 0 then entity.vel_y *= entity.friction end

   -- Clamp to max speed
   entity.vel_x = mid(-entity.max_speed, entity.vel_x, entity.max_speed)
   entity.vel_y = mid(-entity.max_speed, entity.vel_y, entity.max_speed)

   -- Stop completely if very slow (prevents drift)
   if abs(entity.vel_x) < 0.1 then entity.vel_x = 0 end
   if abs(entity.vel_y) < 0.1 then entity.vel_y = 0 end
end

-- Internal: apply velocity to position with sub-pixel precision
local function apply_velocity(entity)
   -- Handle slow: reduce velocity temporarily
   local vel_x = entity.vel_x or 0
   local vel_y = entity.vel_y or 0
   if entity.slow_timer and entity.slow_timer > 0 then
      entity.slow_timer = entity.slow_timer - 1
      local slow = entity.slow_factor or 0.5
      vel_x = vel_x * slow
      vel_y = vel_y * slow
   end

   -- Initialize sub-pixel accumulators if not present
   entity.sub_x = entity.sub_x or 0
   entity.sub_y = entity.sub_y or 0

   -- Accumulate velocity (including fractional parts)
   entity.sub_x += vel_x
   entity.sub_y += vel_y

   -- Extract whole pixel movement
   local move_x = flr(entity.sub_x)
   local move_y = flr(entity.sub_y)

   -- Handle negative values correctly (flr rounds toward negative infinity)
   if entity.sub_x < 0 and entity.sub_x ~= move_x then
      move_x = ceil(entity.sub_x) - 1
   end
   if entity.sub_y < 0 and entity.sub_y ~= move_y then
      move_y = ceil(entity.sub_y) - 1
   end

   -- Apply whole pixel movement
   entity.x += move_x
   entity.y += move_y

   -- Keep the remainder for next frame
   entity.sub_x -= move_x
   entity.sub_y -= move_y
end

-- Update acceleration for all entities with acceleration tag
-- @param world - ECS world
function Physics.acceleration(world)
   world.sys("acceleration", apply_acceleration)()
end

-- Update velocity for all entities with velocity tag
-- @param world - ECS world
function Physics.velocity(world)
   world.sys("velocity", apply_velocity)()
end

-- Apply knockback to velocity BEFORE collision resolution
function Physics.knockback_pre(world)
   world.sys("velocity", function(entity)
      local kb_x = entity.knockback_vel_x or 0
      local kb_y = entity.knockback_vel_y or 0
      if kb_x ~= 0 or kb_y ~= 0 then
         entity.vel_x = (entity.vel_x or 0) + kb_x
         entity.vel_y = (entity.vel_y or 0) + kb_y
      end
   end)()
end

-- Decay knockback AFTER velocity is applied
function Physics.knockback_post(world)
   world.sys("velocity", function(entity)
      local kb_x = entity.knockback_vel_x or 0
      local kb_y = entity.knockback_vel_y or 0
      if kb_x ~= 0 or kb_y ~= 0 then
         entity.vel_x = (entity.vel_x or 0) - kb_x
         entity.vel_y = (entity.vel_y or 0) - kb_y
         local KNOCKBACK_FRICTION = 0.75
         entity.knockback_vel_x = kb_x * KNOCKBACK_FRICTION
         entity.knockback_vel_y = kb_y * KNOCKBACK_FRICTION
         if abs(entity.knockback_vel_x) < 0.1 then entity.knockback_vel_x = 0 end
         if abs(entity.knockback_vel_y) < 0.1 then entity.knockback_vel_y = 0 end
      end
   end)()
end

-- Update Z-axis physics (gravity, movement, ground collision)
-- @param world - ECS world
function Physics.z_axis(world)
   world.sys("velocity", function(entity)
      -- Only process entities with Z-axis properties
      if not entity.z and not entity.vel_z then return end

      entity.z = entity.z or 0
      entity.vel_z = entity.vel_z or 0
      entity.gravity_z = entity.gravity_z or -0.15

      -- Update age (if using projectile flight mechanics)
      if entity.age and entity.max_age then
         entity.age += 1
         -- Only apply gravity in the last 25% of the flight
         -- T_drop_start = max_age * 0.75
         local drop_start = entity.max_age * 0.75
         if entity.age >= drop_start then
            entity.vel_z += entity.gravity_z
         end
      else
         -- Standard gravity for non-projectiles or if age not tracked
         entity.vel_z += entity.gravity_z
      end

      -- Apply velocity
      local prev_z = entity.z
      entity.z += entity.vel_z

      -- For vertical UPWARD shots: shadow moves toward sprite instead of sprite dropping to shadow
      -- This keeps visual position constant (y - z) while shadow (y) catches up
      -- Only apply for upward shots (dir_y < 0) - downward shots use normal sprite-falls-to-shadow behavior
      -- Only apply while z > 0 (still falling) - stop when grounded
      -- IMPORTANT: Don't stop vel_x/vel_y - let the egg continue its full trajectory
      local is_upward_shot = entity.dir_y and entity.dir_y < 0
      if entity.vertical_shot and is_upward_shot and entity.vel_z < 0 and entity.z > 0 then
         -- Move shadow toward visual position by the same amount Z decreased
         -- This keeps visual_y = y - z constant while the egg continues moving
         local z_delta = entity.z - prev_z -- This is negative
         entity.y += z_delta               -- Shadow catches up to sprite
      end

      -- Ground collision (only for entities that use z elevation)
      -- Skip if gravity_z is 0 (projectile was never elevated, e.g., vertical shots)
      if entity.z <= 0 and entity.gravity_z and entity.gravity_z < 0 then
         entity.z = 0
         entity.vel_z = 0 -- Stop gravity accumulation

         -- Player Egg: apply fertility roll on landing
         if entity.tags and string.find(entity.tags, "projectile") and entity.owner == "player" then
            -- Skip if landing on a pit tile
            if mget(flr(entity.x / GRID_SIZE), flr(entity.y / GRID_SIZE)) ~= PIT_TILE then
               -- Prevent double processing if already handled
               if entity.hit_obstacle then return end
               entity.hit_obstacle = true

               -- Single roll with 3 equal outcomes (33% each)
               local roll = rnd()

               -- Get projectile stats
               local hatch_time = entity.hatch_time or 120
               local drain_heal = entity.drain_heal or 5

               if roll < 0.33 then
                  -- Heavy Impact (33%): Egg breaks, sunk cost (Net: -5 HP)
                  Effects.spawn_visual_effect(world, entity.x, entity.y, BROKEN_EGG_SPRITE, 15)
               elseif roll < 0.66 then
                  -- The Hatching (33%): Spawns a chick (Net: -5 HP, +1 Minion)
                  Entities.spawn_egg(world, entity.x, entity.y, {
                     hatch_timer = hatch_time,
                  })
               else
                  -- Parasitic Drain (33%): Refund/Heal (Net: 0 HP - Free shot)
                  -- Spawns a health pickup equal to the drain heal amount

                  local sx, sy = DungeonManager.snap_to_nearest_floor(entity.x, entity.y, DungeonManager.current_room)
                  if not sx then sx, sy = entity.x, entity.y end -- Fall back to original position
                  Entities.spawn_health_pickup(world, sx, sy, drain_heal)
               end
            end
         end

         -- Destroy projectile on ground impact
         if entity.tags and string.find(entity.tags, "projectile") then
            world.del(entity)
         end
      end
   end)()
end

return Physics

:: src/systems/rendering.lua
-- Rendering system: core entity drawing
-- Focused on sprite drawing, layer rendering, and palette swaps

local qsort = require("lib/qsort")
local Effects = require("src/systems/effects")
local Rotator = require("src/systems/sprite_rotator")

local Rendering = {}

-- Outline offsets for 8-neighbor technique
local OUTLINE_OFFSETS = {
   {-1, 0}, {1, 0}, {0, -1}, {0, 1},
   {-1, -1}, {1, -1}, {-1, 1}, {1, 1}
}

-- Draw a sprite with a colored outline
-- @param sprite_index - Sprite to draw
-- @param x, y - Position
-- @param outline_color - Color for outline (default: 0 black)
-- @param flip_x, flip_y - Optional flip flags
function Rendering.draw_outlined(sprite_index, x, y, outline_color, flip_x, flip_y)
   outline_color = outline_color or 0

   -- Set all colors to outline color
   for i = 1, 63 do pal(i, outline_color, 0) end

   -- Draw 8 outline sprites at offset positions
   for _, o in ipairs(OUTLINE_OFFSETS) do
      spr(sprite_index, x + o[1], y + o[2], flip_x, flip_y)
   end

   -- Reset palette and draw center sprite
   pal()
   spr(sprite_index, x, y, flip_x, flip_y)
end

-- Draw a composite sprite (top + bottom halves) with a colored outline
function Rendering.draw_outlined_composite(sprite_top, sprite_bottom, x, y, width, height, split_row, outline_color,
                                           flip_x, flip_y)
   outline_color = outline_color or 0
   split_row = split_row or flr(height / 2)
   local bottom_height = height - split_row

   -- Helper to draw the composite sprite
   local function draw_composite(ox, oy)
      -- Draw top half
      sspr(sprite_top, 0, 0, width, split_row, x + ox, y + oy, width, split_row, flip_x, flip_y)
      -- Draw bottom half
      sspr(sprite_bottom, 0, split_row, width, bottom_height, x + ox, y + oy + split_row, width, bottom_height, flip_x,
         flip_y)
   end

   -- Set all colors to outline color (keep color 0 transparent)
   for i = 1, 63 do pal(i, outline_color, 0) end

   -- Draw 8 outline offsets
   for _, o in ipairs(OUTLINE_OFFSETS) do
      draw_composite(o[1], o[2])
   end

   pal()

   -- Draw center composite normally
   draw_composite(0, 0)
end

-- Apply palette swaps for an entity
local function apply_palette_swaps(entity)
   if not entity.palette_swaps then return end
   for _, swap in ipairs(entity.palette_swaps) do
      pal(swap.from, swap.to)
   end
end

-- Internal sprite drawer (combines flash check and standard drawing)
local function draw_sprite(entity)
   local was_flashing = entity.flash_timer and entity.flash_timer > 0
   Effects.update_flash(entity)

   -- Actual drawing
   local flip_x = entity.flip_x or entity.flip or false
   local flip_y = entity.flip_y or false
   local sx = entity.x + (entity.sprite_offset_x or 0)
   local sy = entity.y + (entity.sprite_offset_y or 0) - (entity.z or 0)

   -- Apply palette swaps
   local palette_swapped = false
   if entity.palette_swaps then
      apply_palette_swaps(entity)
      palette_swapped = true
   end

   -- Check for death state to apply procedural effects
   if entity.fsm and entity.fsm:is("death") then
      local t = entity.anim_timer or 0
      local max_t = 30
      local p = min(t / max_t, 1.0)
      sx = sx + rnd(2) - 1
      sy = sy + rnd(2) - 1
      if t < 4 then
         for i = 1, 15 do pal(i, 7) end
         for i = 32, 63 do pal(i, 7) end
      else
         if flr(t / 4) % 2 == 0 then
            pal(6, 8)
            pal(5, 2)
            pal(13, 2)
         end
      end
      local n = entity.sprite_index or 0
      local w = entity.width
      local h = entity.height
      local target_h = h * (1 - p)
      local target_w = w * (1 + p * 1.5)
      local draw_x = sx - (target_w - w) / 2
      local draw_y = sy + (h - target_h)
      sspr(n, 0, 0, w, h, draw_x, draw_y, target_w, target_h, flip_x, flip_y)
      pal()
      return
   end

   -- Check for composite sprite (top + bottom halves)
   if entity.sprite_top ~= nil and entity.sprite_bottom ~= nil then
      local width = entity.width
      local height = entity.height
      local split_row = entity.split_row

      -- Skip outline if entity is flashing (flash takes priority)
      if entity.outline_color ~= nil and not was_flashing then
         Rendering.draw_outlined_composite(
            entity.sprite_top, entity.sprite_bottom,
            sx, sy, width, height, split_row,
            entity.outline_color, flip_x, flip_y
         )
      else
         local bottom_height = height - split_row
         sspr(entity.sprite_top, 0, 0, width, split_row, sx, sy, width, split_row, flip_x, flip_y)
         sspr(entity.sprite_bottom, 0, split_row, width, bottom_height, sx, sy + split_row, width, bottom_height,
            flip_x, flip_y)
      end
   else
      -- Standard single sprite
      local drawable = entity.sprite_index
      if entity.rotation_angle and entity.rotation_angle ~= 0 then
         drawable = Rotator.get(entity.sprite_index, entity.rotation_angle)
      end

      -- Skip outline if entity is flashing (flash takes priority)
      if entity.outline_color ~= nil and not was_flashing then
         Rendering.draw_outlined(drawable, sx, sy, entity.outline_color, flip_x, flip_y)
      else
         spr(drawable, sx, sy, flip_x, flip_y)
      end
   end

   -- Reset palette if swapped OR if outlined (which calls pal()) OR was flashing
   if palette_swapped or (entity.outline_color ~= nil) or was_flashing then
      pal()
   end
end

-- Active room keys for visibility filtering (set by play.lua before drawing)
-- Entities with room_key will only be drawn if their key is in this table
Rendering.active_room_keys = {}

--- Set which rooms are currently visible (call before draw_layer)
--- @param room_keys Table of room key strings like {"0,0", "1,0"}
function Rendering.set_active_rooms(room_keys)
   Rendering.active_room_keys = {}
   for _, key in ipairs(room_keys) do
      Rendering.active_room_keys[key] = true
   end
end

--- Check if entity should be visible based on room_key
---
--- @param entity Entity to check
--- @return true if entity should be rendered
local function is_entity_visible(entity)
   -- Entities without room_key are always visible (player, projectiles, etc)
   if not entity.room_key then return true end

   -- Check if entity's room is in active rooms
   return Rendering.active_room_keys[entity.room_key] == true
end

--- Draws all entities matching 'tags'. Optionally sorts them by Y position.
---
--- Filters out entities whose room_key is not in active_room_keys
---
--- @param world ECS world
--- @param tags Table of tag strings like {"player", "enemy"}
--- @param sorted Boolean whether to sort entities by Y position
function Rendering.draw_layer(world, tags, sorted)
   if sorted then
      local entities = {}
      world.sys(tags, function(e)
         if is_entity_visible(e) then
            add(entities, e)
         end
      end)()

      -- Sort by Y position (foot position for proper 2.5D sorting)
      -- Use sort_offset_y to specify where the entity's "feet" are (default: bottom of sprite)
      qsort(entities, function(a, b)
         local ay = a.y + (a.sort_offset_y or a.height or 16)
         local by = b.y + (b.sort_offset_y or b.height or 16)
         return ay < by
      end)

      for i = 1, #entities do
         draw_sprite(entities[i])
      end
   else
      world.sys(tags, function(e)
         if is_entity_visible(e) then
            draw_sprite(e)
         end
      end)()
   end
end

-- Apply palette swaps for all palette_swappable entities
function Rendering.apply_palette_swaps(world)
   world.sys("palette_swappable", apply_palette_swaps)()
end

return Rendering

:: src/systems/shadows.lua
-- Shadows system: shadow entity sync and drawing

local HitboxUtils = require("src/utils/hitbox_utils")
local Rendering = require("src/systems/rendering")

local Shadows = {}

-- Sync shadow entity properties to parent
local function sync_shadow(world, shadow)
   local parent = shadow.parent

   if not parent or not world.msk(parent) then
      world.del(shadow)
      return
   end

   -- Optimization: skip syncing properties for static parent objects
   if parent.static then return end

   shadow.x = parent.x
   shadow.y = parent.y
   shadow.w = parent.width or 16
   shadow.h = parent.height or 16
   shadow.shadow_offset_y = parent.shadow_offset_y or 0
   shadow.shadow_offsets_y = parent.shadow_offsets_y
   shadow.shadow_offset_x = parent.shadow_offset_x or 0
   shadow.shadow_offsets_x = parent.shadow_offsets_x
   shadow.shadow_width = parent.shadow_width
   shadow.shadow_height = parent.shadow_height
   shadow.shadow_widths = parent.shadow_widths
   shadow.shadow_heights = parent.shadow_heights
   shadow.direction = parent.direction or parent.current_direction

   -- Propagate room_key for visibility filtering
   shadow.room_key = parent.room_key
end

-- Draw a shadow entity
-- @param world - ECS world
-- @param shadow - Shadow entity
-- @param clip_square - Clipping rectangle {x, y, w, h}
local function draw_shadow(world, shadow, clip_square)
   local parent = shadow.parent
   if not parent or not world.msk(parent) then return end

   local dir = parent.direction or parent.current_direction
   local hb = HitboxUtils.get_hitbox(parent)

   local sw = shadow.shadow_width
   if shadow.shadow_widths and dir and shadow.shadow_widths[dir] then
      sw = shadow.shadow_widths[dir]
   end
   if not sw then
      local w_scale = 0.8
      if hb.w < 8 then w_scale = 1.0 end
      sw = hb.w * w_scale
   end

   local sh = shadow.shadow_height
   if shadow.shadow_heights and dir and shadow.shadow_heights[dir] then
      sh = shadow.shadow_heights[dir]
   end
   sh = sh or 3

   local offset_y = shadow.shadow_offset_y or 0
   if shadow.shadow_offsets_y and dir and shadow.shadow_offsets_y[dir] then
      offset_y = shadow.shadow_offsets_y[dir]
   end

   local offset_x = shadow.shadow_offset_x or 0
   if shadow.shadow_offsets_x and dir and shadow.shadow_offsets_x[dir] then
      offset_x = shadow.shadow_offsets_x[dir]
   end

   local cx = flr(hb.x + hb.w / 2) + offset_x
   local ground_y = flr((hb.y + hb.h) + (parent.z or 0) - (parent.sprite_offset_y or 0))
   local cy = ground_y + offset_y

   local x1 = cx - flr(sw / 2)
   local x2 = cx + flr(sw / 2)
   local y1 = cy - flr(sh / 2)
   local y2 = cy + flr(sh / 2)

   clip(clip_square.x, clip_square.y, clip_square.w, clip_square.h)
   palt(0, false)
   ovalfill(x1, y1, x2, y2, 0)
   palt(0, true)
   clip()
end

-- Sync all shadow entities to their parents
-- @param world - ECS world
function Shadows.sync(world)
   world.sys("shadow_sync", function(e) sync_shadow(world, e) end)()
end

-- Draw all shadow entities
-- @param world - ECS world
-- @param clip_square - Clipping rectangle
function Shadows.draw(world, clip_square)
   world.sys("background,drawable_shadow", function(shadow)
      -- Filter by room_key (same logic as Rendering)
      if shadow.room_key and not Rendering.active_room_keys[shadow.room_key] then
         return
      end
      draw_shadow(world, shadow, clip_square)
   end)()
end

return Shadows

:: src/systems/shooter.lua
local Entities = require("src/entities")
local GameConstants = require("src/game/game_config")
local GameState = require("src/game/game_state")
local EntityUtils = require("src/utils/entity_utils")

local Shooter = {}

-- Shooting system: works for ANY entity with "shooter" tag
function Shooter.update(world)
   world.sys("shooter", function(entity)
      local sx = entity.shoot_dir_x or 0
      local sy = entity.shoot_dir_y or 0

      local cooldown_ready = (entity.shoot_cooldown or 0) == 0
      local wants_to_shoot = sx ~= 0 or sy ~= 0

      -- Check ammo (HP for entities with health_as_ammo, unlimited otherwise)
      -- free_attacks cheat bypasses ammo check
      local has_ammo = true
      local shot_cost = 0

      if entity.health_as_ammo then
         local max_hp = entity.max_hp or 100
         local ratio = entity.max_hp_to_shot_cost_ratio or (GameConstants.Player.max_hp_to_shot_cost_ratio)
         shot_cost = max_hp * ratio
      end

      -- If entity explicitly specifies shot_cost (overriding dynamic calc), use it
      if entity.shot_cost then shot_cost = entity.shot_cost end

      if entity.health_as_ammo and entity.hp and not GameState.cheats.free_attacks then
         has_ammo = entity.hp >= shot_cost
      end

      if wants_to_shoot then
         entity.current_direction = EntityUtils.get_direction_name(sx, sy, entity.current_direction)
         if entity.type == "Player" then
            world.tag(entity, "aiming")
         end
      else
         world.unt(entity, "aiming")
         return
      end

      if (btnp(GameConstants.controls.attack) and entity.type == "Player" and cooldown_ready) or (entity.type == "Enemy" and cooldown_ready) then
         world.tag(entity, "shooting")
      else
         world.unt(entity, "shooting")
      end

      local is_shooting = world.msk(entity).shooting

      if has_ammo and is_shooting then
         -- Trigger attack animation for entities with FSM
         if entity.fsm then entity.fsm:attack() end

         -- Consume ammo if using health (skip if free_attacks cheat active)
         if entity.health_as_ammo and not GameState.cheats.free_attacks then
            -- Clamp HP to minimum 1 so player doesn't die from shooting
            entity.hp = max(1, entity.hp - shot_cost)
            entity.time_since_shot = 0
         end

         -- Spawn projectile
         local projectile_type = entity.projectile_type or "Egg"
         -- Calculate damage dynamically
         local damage = entity.damage
         if not damage and entity.max_hp_to_damage_ratio then
            damage = (entity.max_hp or 100) * entity.max_hp_to_damage_ratio
         end

         Entities.spawn_projectile_from_origin(
            world, entity, sx, sy, projectile_type,
            {
               speed = entity.shot_speed,
               damage = damage,
               knockback = entity.knockback,
               recovery_percent = entity.recovery_percent,
               shot_cost = shot_cost,
               lifetime = (entity.range and entity.shot_speed)
                  and (entity.range / entity.shot_speed) or 60,
               -- Egg outcome stats (single roll, 3 outcomes)
               impact_damage = entity.impact_damage,
               drain_damage = entity.drain_damage,
               drain_heal = entity.drain_heal,
               hatch_time = entity.hatch_time,

               -- Pass mutation-specific stats
               dud_damage = entity.dud_damage,     -- Used by Eggsaggerated
               leech_damage = entity.leech_damage, -- Used by Pureblood (if needed)
               roll_dud_chance = entity.roll_dud_chance,
               roll_hatch_chance = entity.roll_hatch_chance,
               roll_leech_chance = entity.roll_leech_chance,
               broodmother_active = entity.broodmother_active, -- For Broodmother minion buff

               -- Sticky Yolk effect stats
               egg_slow_duration = entity.egg_slow_duration,
               egg_slow_factor = entity.egg_slow_factor,
            }
         )

         entity.shoot_cooldown = entity.shoot_cooldown_duration or 15
      end
   end)()
end

return Shooter

:: src/systems/spawner.lua
-- Enemy spawning system
local Entities = require("src/entities")
local GameConstants = require("src/game/game_config")
local DungeonManager = require("src/world/dungeon_manager")
local Spawner = {}

Spawner.indicator_sprite = SPAWNER_INDICATOR_SPRITE

function Spawner.update(world, room)
    -- Regular enemy spawning (room is in spawning state)
    if room and room.lifecycle:is("spawning") then
        room.spawn_timer -= 1
        if room.spawn_timer <= 0 then
            for _, pos in ipairs(room.enemy_positions) do
                Entities.spawn_enemy(world, pos.x, pos.y, pos.type)
            end
            room.lifecycle:spawn()
        end
    end

    -- Skull timer and spawning (for both active/locked and cleared combat rooms)
    if room and room.skull_timer and not room.skull_spawned then
        room.skull_timer -= 1
        if room.skull_timer <= 0 then
            -- If room is active (locked), ignore health check to add pressure
            local ignore_health = room.lifecycle:is("active")
            if Spawner.spawn_skull(world, room, ignore_health) then
                room.skull_spawned = true
            end
        end
    end
end

function Spawner.draw(room)
    if not room or not room.lifecycle:is("spawning") then return end

    -- Blinking effect: toggle visibility every 15 frames, visible for 8
    if room.spawn_timer % 15 < 8 then
        for _, pos in ipairs(room.enemy_positions) do
            spr(Spawner.indicator_sprite, pos.x, pos.y)
        end
    end
end

-- Check if space is free for spawning
function Spawner.is_free_space(room, x, y)
    for _, pos in ipairs(room.enemy_positions) do
        local dx = x - pos.x
        local dy = y - pos.y
        if dx * dx + dy * dy < 16 * 16 then return false end
    end
    return true
end

-- Populate room with enemies based on configuration
-- config: { wave_pattern = pattern } or legacy { enemies = { count, types } }
function Spawner.populate(room, player)
    -- Early exit if not in populated state or no config
    if not room or not room.lifecycle:is("populated") then return end

    -- Boss room handling: spawn single boss at room center
    if room.room_type == "boss" then
        local bounds = room:get_inner_bounds()
        local cx = ((bounds.x1 + bounds.x2) / 2) * GRID_SIZE
        local cy = ((bounds.y1 + bounds.y2) / 2) * GRID_SIZE
        room.enemy_positions = {{x = cx, y = cy, type = "GreenWitch"}}
        room.spawn_timer = 90 -- Longer spawn delay for dramatic effect
        return
    end

    -- Skip non-combat rooms (shop, treasure, start)
    if not room.contents_config then return end

    local WavePatterns = require("src/world/wave_patterns")
    local RoomLayouts = require("src/world/room_layouts")

    -- Get room inner bounds once (in pixel space) for bounds checking
    local room_bounds = room:get_inner_bounds()
    local room_px = {
        x1 = room_bounds.x1 * GRID_SIZE,
        y1 = room_bounds.y1 * GRID_SIZE,
        x2 = (room_bounds.x2 + 1) * GRID_SIZE,
        y2 = (room_bounds.y2 + 1) * GRID_SIZE
    }

    -- Helper: Check if a single tile is valid for spawning
    local function is_tile_valid(tx, ty)
        -- Check tile is within room bounds
        if tx < room_bounds.x1 or tx > room_bounds.x2 or
           ty < room_bounds.y1 or ty > room_bounds.y2 then
            return false
        end

        -- Check if it's a floor tile (not pit or other solid)
        if not RoomLayouts.is_floor_tile(tx, ty) then return false end

        -- Direct pit tile check (for layouts without grid pattern data)
        local tile = mget(tx, ty)
        if tile == PIT_TILE then return false end

        -- Fast layout-based feature check (Rocks/Pits/Destructibles/Chests)
        if room.layout and room.layout.grid then
            local floor_rect = room:get_inner_bounds()
            local room_w = floor_rect.x2 - floor_rect.x1 + 1
            local room_h = floor_rect.y2 - floor_rect.y1 + 1
            local gx = tx - floor_rect.x1
            local gy = ty - floor_rect.y1

            local feature = RoomLayouts.get_feature_at(room.layout, gx, gy, room_w, room_h)
            if feature == "rock" or feature == "destructible" or feature == "pit"
               or feature == "chest" or feature == "locked_chest" or feature == "no_spawn" then
                return false
            end
        end

        return true
    end

    -- Helper: Check if a position is valid for spawning (check entity footprint)
    local function is_valid_spawn(px, py, etype)
        -- First check if position is within room pixel bounds
        if px < room_px.x1 or px + 16 > room_px.x2 or
           py < room_px.y1 or py + 16 > room_px.y2 then
            return false
        end

        local config = GameConstants.Enemy[etype or "Skulker"]
        if not config then return true end

        local w = config.hitbox_width or config.width or 16
        local h = config.hitbox_height or config.height or 16
        local ox = config.hitbox_offset_x or 0
        local oy = config.hitbox_offset_y or 0

        local x1 = flr((px + ox) / GRID_SIZE)
        local y1 = flr((py + oy) / GRID_SIZE)
        local x2 = flr((px + ox + w - 0.1) / GRID_SIZE)
        local y2 = flr((py + oy + h - 0.1) / GRID_SIZE)

        for ty = y1, y2 do
            for tx = x1, x2 do
                if not is_tile_valid(tx, ty) then return false end
            end
        end
        return true
    end

    -- Helper: Find nearest valid tile (within room bounds)
    local function nudge_to_valid(px, py, etype)
        if is_valid_spawn(px, py, etype) then return px, py end

        -- Use robust snap logic from DungeonManager to find nearest floor
        return DungeonManager.snap_to_nearest_floor(px, py, room)
    end

    -- Pattern-based spawning
    if room.contents_config.wave_pattern then
        local pattern = room.contents_config.wave_pattern
        local calc_pos = WavePatterns.calculate_positions(pattern, room:get_inner_bounds())

        room.enemy_positions = {}
        for _, pos in ipairs(calc_pos) do
            local nx, ny = nudge_to_valid(pos.x, pos.y, pos.type)
            if nx then
                add(room.enemy_positions, {x = nx, y = ny, type = pos.type})
            end
        end

        -- Fallback to random if pattern completely failed
        if #room.enemy_positions > 0 then
            room.spawn_timer = 60
            return
        end
        Log.info("Pattern "..tostring(pattern.name).." failed to find valid positions, falling back to random")
    end

    -- Random spawning (Fallback or primary if no pattern)
    local enemy_config = room.contents_config.enemies
    -- If we came from a failed pattern, we need to create a config
    if not enemy_config then
        local pattern = room.contents_config.wave_pattern
        local difficulty = pattern and pattern.difficulty or 1
        enemy_config = {
            count = mid(2, difficulty * 2, 6),
            min_dist = 80,
            types = (difficulty == 1) and {"Skulker"} or {"Skulker", "Shooter"}
        }
    end

    if not enemy_config or not enemy_config.count or enemy_config.count <= 0 then return end

    local num_enemies = enemy_config.count
    local min_dist = enemy_config.min_dist or 96

    room.enemy_positions = {}
    local floor = room:get_inner_bounds()
    local attempts = 0
    local max_attempts = 500

    while #room.enemy_positions < num_enemies and attempts < max_attempts do
        attempts = attempts + 1

        -- Scale down min_dist if struggling to find spots
        local active_min_dist = min_dist
        if attempts > 200 then active_min_dist = min_dist * 0.7 end
        if attempts > 400 then active_min_dist = 32 end

        -- Pick random tile within floor bounds
        local tx = floor.x1 + flr(rnd(floor.x2 - floor.x1 + 1))
        local ty = floor.y1 + flr(rnd(floor.y2 - floor.y1 + 1))
        local rx = tx * GRID_SIZE
        local ry = ty * GRID_SIZE

        local etype = "Skulker"
        if enemy_config.types and #enemy_config.types > 0 then
            etype = enemy_config.types[flr(rnd(#enemy_config.types)) + 1]
        elseif rnd(1) < 0.4 then
            etype = "Shooter"
        end

        -- Check if valid floor position
        local nx, ny = nudge_to_valid(rx, ry, etype)
        if not nx then
            goto continue
        end

        -- Check distance from player
        local dx = nx - player.x
        local dy = ny - player.y
        if dx * dx + dy * dy > active_min_dist * active_min_dist then
            if Spawner.is_free_space(room, nx, ny) then
                table.insert(room.enemy_positions, {x = nx, y = ny, type = etype})
            end
        end
        ::continue::
    end

    if #room.enemy_positions > 0 then
        room.spawn_timer = 60 -- Default spawn delay
    end
end

-- Spawn skull at farthest corner from player (outside screen)
function Spawner.spawn_skull(world, room, ignore_health_check)
    if not room then return false end

    -- Get player position
    local player_x, player_y
    local player_entity
    world.sys("player", function(p)
        player_x = p.x
        player_y = p.y
        player_entity = p
    end)()

    -- If no player, don't spawn
    if not player_x then return false end

    -- Don't spawn if player is at full health (no idle regeneration to punish)
    -- UNLESS we are ignoring the health check (e.g. pressure in locked room)
    if not ignore_health_check and player_entity and player_entity.hp >= player_entity.max_hp then
        return false
    end

    -- Calculate offscreen spawn positions (beyond screen edges relative to room center)
    local bounds = room:get_inner_bounds()
    local offset_pixels = 32 -- Spawn 32 pixels beyond visible screen area

    local center_x = (bounds.x1 + (bounds.x2 - bounds.x1) / 2) * GRID_SIZE
    local center_y = (bounds.y1 + (bounds.y2 - bounds.y1) / 2) * GRID_SIZE

    local corners = {
        {x = center_x - (SCREEN_WIDTH / 2) - offset_pixels, y = center_y - (SCREEN_HEIGHT / 2) - offset_pixels}, -- Top-left offscreen
        {x = center_x + (SCREEN_WIDTH / 2) + offset_pixels, y = center_y - (SCREEN_HEIGHT / 2) - offset_pixels}, -- Top-right offscreen
        {x = center_x - (SCREEN_WIDTH / 2) - offset_pixels, y = center_y + (SCREEN_HEIGHT / 2) + offset_pixels}, -- Bottom-left offscreen
        {x = center_x + (SCREEN_WIDTH / 2) + offset_pixels, y = center_y + (SCREEN_HEIGHT / 2) + offset_pixels}  -- Bottom-right offscreen
    }

    -- Find farthest corner from player
    local max_dist = 0
    local spawn_pos = corners[1]
    for _, corner in ipairs(corners) do
        local dx = corner.x - player_x
        local dy = corner.y - player_y
        local dist = dx * dx + dy * dy
        if dist > max_dist then
            max_dist = dist
            spawn_pos = corner
        end
    end

    -- Spawn skull at farthest corner
    local skull = Entities.spawn_enemy(world, spawn_pos.x, spawn_pos.y, "Skull")
    room.skull_entity = skull -- Track for cleanup
    return true
end

return Spawner

:: src/systems/sprite_rotator.lua
local Rotator = {}

Rotator.cache = {}

-- Get a rotated version of the sprite (Userdata)
-- angle must be 0, 90, 180, or 270
function Rotator.get(sprite_index, angle)
   -- Normalize angle to 0, 90, 180, 270
   local normalized_angle = angle % 360

   if normalized_angle == 0 then
      return sprite_index
   end

   if not Rotator.cache[sprite_index] then
      Rotator.cache[sprite_index] = {}
   end

   if Rotator.cache[sprite_index][normalized_angle] then
      return Rotator.cache[sprite_index][normalized_angle]
   end

   -- Create rotated sprite
   local src_ud = get_spr(sprite_index)

   -- Safety check if get_spr returns nil or invalid type (though manual says it returns userdata u8)
   if not src_ud then
      return sprite_index
   end

   local w, h = src_ud:width(), src_ud:height()

   -- Swap dimensions for 90/270 degrees
   local dest_w, dest_h = w, h
   if normalized_angle == 90 or normalized_angle == 270 then
      dest_w, dest_h = h, w
   end

   local dest_ud = userdata("u8", dest_w, dest_h)

   for y = 0, h - 1 do
      for x = 0, w - 1 do
         local val = src_ud:get(x, y)
         local dx, dy

         if normalized_angle == 90 then
            -- (x, y) -> (h - 1 - y, x)
            dx = h - 1 - y
            dy = x
         elseif normalized_angle == 180 then
            -- (x, y) -> (w - 1 - x, h - 1 - y)
            dx = w - 1 - x
            dy = h - 1 - y
         elseif normalized_angle == 270 then
            -- (x, y) -> (y, w - 1 - x)
            dx = y
            dy = w - 1 - x
         end

         dest_ud:set(dx, dy, val)
      end
   end

   Rotator.cache[sprite_index][normalized_angle] = dest_ud
   return dest_ud
end

-- Clear cache if needed (e.g. level change)
function Rotator.clear_cache()
   Rotator.cache = {}
end

return Rotator

:: src/systems/timers.lua
-- Generic countdown timer system
local GameState = require("src/game/game_state")

local Timers = {}

-- Update countdown timers on entities with "timers" tag
function Timers.update(world)
   world.sys("timers", function(entity)
      -- Invulnerability timer
      if entity.invuln_timer and entity.invuln_timer > 0 then
         entity.invuln_timer -= 1
      end

      -- Shooting cooldown
      if entity.shoot_cooldown and entity.shoot_cooldown > 0 then
         entity.shoot_cooldown -= 1
      end

      -- Melee cooldown
      if entity.melee_cooldown and entity.melee_cooldown > 0 then
         entity.melee_cooldown -= 1
      end

      -- HP drain (for minions with finite lifespan based on health)
      -- Skip drain if godmode is active
      if entity.hp_drain_rate and not GameState.cheats.godmode then
         entity.hp_drain_timer = (entity.hp_drain_timer or 0) + 1
         if entity.hp_drain_timer >= entity.hp_drain_rate then
            entity.hp_drain_timer = 0
            entity.hp -= 1
            if entity.hp <= 0 then
               if entity.fsm and entity.fsm:is("death") then
                  -- Already dying, wait for animation
               elseif entity.fsm and entity.fsm.die then
                  entity.fsm:die()
               else
                  world.del(entity)
               end
            end
         end
      end

      -- Entity lifespan (for temporary hitboxes)
      if entity.lifespan then
         entity.lifespan -= 1
         if entity.lifespan <= 0 then
            world.del(entity)
         end
      end
   end)()
end

return Timers

:: src/systems/ui.lua
-- UI system: health bars, debug visualization

local HitboxUtils = require("src/utils/hitbox_utils")

local UI = {}

local function draw_health_bar(entity)
   if not entity.hp or entity.type == "Skull" or entity.type == "Player" then return end

   local bar_h = 3
   local py = flr(entity.y - 8)

   if entity.health_as_ammo then
      -- Segmented bar for ammo-based entities (Player)
      local shot_cost = entity.shot_cost
      if not shot_cost and entity.max_hp_to_shot_cost_ratio then
         shot_cost = entity.max_hp * entity.max_hp_to_shot_cost_ratio
      end
      shot_cost = shot_cost or 20 -- Fallback

      local base_segments = ceil(entity.max_hp / shot_cost)
      local overheal = entity.overflow_hp or 0
      local overheal_segments = ceil(overheal / shot_cost)
      local total_segments = base_segments + overheal_segments
      local seg_w = 6
      local gap = 1
      local total_w = (seg_w + gap) * total_segments - gap
      local px = flr(entity.x + (entity.width or 16) / 2 - total_w / 2)

      -- Draw base HP segments (green)
      for i = 0, base_segments - 1 do
         local start_x = px + i * (seg_w + gap)
         local segment_hp = min(shot_cost, max(0, entity.hp - (i * shot_cost)))

         if segment_hp >= shot_cost then
            rectfill(start_x, py, start_x + seg_w - 1, py + bar_h, 11) -- Full (green)
         elseif segment_hp > 0 then
            rectfill(start_x, py, start_x + seg_w - 1, py + bar_h, 8)  -- Empty (dark)
            local fill_w = ceil((segment_hp / shot_cost) * seg_w)
            rectfill(start_x, py, start_x + fill_w - 1, py + bar_h, 9) -- Partial (orange)
         else
            rectfill(start_x, py, start_x + seg_w - 1, py + bar_h, 8)  -- Empty (dark)
         end
      end

      -- Draw overheal segments (light blue)
      for i = 0, overheal_segments - 1 do
         local start_x = px + (base_segments + i) * (seg_w + gap)
         local segment_overheal = min(shot_cost, max(0, overheal - (i * shot_cost)))

         if segment_overheal >= shot_cost then
            rectfill(start_x, py, start_x + seg_w - 1, py + bar_h, 12)  -- Full (light blue)
         elseif segment_overheal > 0 then
            rectfill(start_x, py, start_x + seg_w - 1, py + bar_h, 8)   -- Empty (dark)
            local fill_w = ceil((segment_overheal / shot_cost) * seg_w)
            rectfill(start_x, py, start_x + fill_w - 1, py + bar_h, 12) -- Partial (light blue)
         end
      end
   else
      -- Continuous bar for standard entities (Enemies)
      local total_w = entity.width or 16
      local px = flr(entity.x + (entity.width or 16) / 2 - total_w / 2)

      -- Background
      rectfill(px, py, px + total_w - 1, py + bar_h, 8)

      -- Foreground
      if entity.max_hp and entity.max_hp > 0 then
         local fill_w = ceil((entity.hp / entity.max_hp) * total_w)
         if fill_w > 0 then
            rectfill(px, py, px + fill_w - 1, py + bar_h, 11)
         end
      end
   end
end

-- Draw debug hitbox for an entity
local function draw_hitbox(entity)
   local hb = HitboxUtils.get_hitbox(entity)
   rect(hb.x, hb.y, hb.x + hb.w, hb.y + hb.h, 8)
end

-- Draw aim line for an entity (origin matches projectile visual center)
local function draw_aim_line(entity)
   -- Projectile origin is a direct offset from entity sprite top-left
   local origin_x = entity.x + (entity.projectile_origin_x or 0)
   local origin_y = entity.y + (entity.projectile_origin_y or 0)

   -- Get shoot direction
   local dx = entity.shoot_dir_x or 0
   local dy = entity.shoot_dir_y or 0

   -- Apply z offset (projectile visually rendered at y - z)
   if entity.projectile_origin_z then
      origin_y = origin_y - entity.projectile_origin_z
   end

   local aim_line = {
      x1 = origin_x,
      y1 = origin_y,
      x2 = origin_x + entity.range * dx,
      y2 = origin_y + entity.range * dy,
   }
   fillp(0x5A5A)
   line(aim_line.x1, aim_line.y1, aim_line.x2, aim_line.y2, 8)
   fillp()
end

-- Draw health bars for all entities with health
-- @param world - ECS world
function UI.draw_health_bars(world)
   world.sys("health", draw_health_bar)()
end

-- Draw debug hitboxes for all collidable entities
-- @param world - ECS world
function UI.draw_hitboxes(world)
   world.sys("collidable", draw_hitbox)()
end

function UI.draw_aim_lines(world)
   world.sys("aiming", draw_aim_line)()
end

return UI

:: src/ui.lua
-- Root redirect for UI module
return require("src/ui/init")

:: src/ui/health_bar.lua
local GameConstants = require("src/game/game_config")

local HealthBar = {}

-- Helper to apply palette swaps based on config
-- Heart sprite base colors (in luminance order): 7, 8, 24, 2
-- colors array maps: {target_for_7, target_for_8, target_for_24, target_for_2}
local function apply_palette(colors)
   if not colors then return end
   pal(7, colors[1], 0)
   pal(8, colors[2], 0)
   pal(24, colors[3], 0)
   pal(2, colors[4], 0)
end

-- Helper to draw a heart (full, half, or empty)
local function draw_heart_sprite(x, y, type, config, colors)
   apply_palette(colors)

   local sprite
   if type == "full" then
      sprite = config.heart_sprite
   elseif type == "half" then
      sprite = config.half_heart_sprite
   else
      -- Empty
      sprite = config.empty_heart_sprite or config.heart_sprite
   end

   spr(sprite, x, y, false, false, 2, 2)

   pal()
end

function HealthBar.draw(player)
   if not player or not player.hp then return end

   local config = GameConstants.Hud.health_bar
   local x = config.x
   local y = config.y
   local spacing = config.heart_spacing

   -- Logic: 1 Heart = 10 HP.
   local hp_per_heart = 10

   local max_hp = player.max_hp
   local current_hp = player.hp
   local overheal = player.overflow_hp or 0

   local base_hearts = ceil(max_hp / hp_per_heart)
   local overheal_hearts = ceil(overheal / hp_per_heart)

   -- Wrapping Constants
   local MAX_PER_ROW = config.max_per_row or 10
   local row = 0
   local col = 0

   -- Helper to calculate position and advance counters
   local function get_pos_and_advance()
      -- Calculate position based on current row/col
      local heart_x = x + (col * spacing)
      local heart_y = y + (row * spacing)

      -- Advance counters
      col = col + 1
      if col >= MAX_PER_ROW then
         col = 0
         row = row + 1
      end

      return heart_x, heart_y
   end

   -- Draw Base Hearts
   for i = 0, base_hearts - 1 do
      local heart_x, heart_y = get_pos_and_advance()

      local hp_in_heart = min(hp_per_heart, max(0, current_hp - (i * hp_per_heart)))

      if hp_in_heart >= 10 then
         -- Full
         draw_heart_sprite(heart_x, heart_y, "full", config, config.colors.normal)
      elseif hp_in_heart >= 5 then
         -- Half
         -- Draw empty backing first, then half on top
         draw_heart_sprite(heart_x, heart_y, "empty", config, config.colors.empty)
         draw_heart_sprite(heart_x, heart_y, "half", config, config.colors.normal)
      else
         -- Empty
         draw_heart_sprite(heart_x, heart_y, "empty", config, config.colors.empty)
      end
   end

   -- Draw Overheal Hearts (Blue)
   for i = 0, overheal_hearts - 1 do
      local heart_x, heart_y = get_pos_and_advance()

      local hp_in_heart = min(hp_per_heart, max(0, overheal - (i * hp_per_heart)))

      if hp_in_heart >= 10 then
         draw_heart_sprite(heart_x, heart_y, "full", config, config.colors.overheal)
      elseif hp_in_heart >= 5 then
         -- Half Overheal
         draw_heart_sprite(heart_x, heart_y, "half", config, config.colors.overheal)
      end
   end
end

return HealthBar

:: src/ui/hud.lua
local GameConstants = require("src/game/game_config")
local Rendering = require("src/systems/rendering")
local HitboxUtils = require("src/utils/hitbox_utils")

local Hud = {}

-- Helper to draw text with shadow
local function print_shadowed(str, x, y, col, shadow_col)
   print(str, x + 1, y + 1, shadow_col)
   print(str, x, y, col)
end

--- Draw mutations HUD
--- @param player table - The player entity to read stats from
function Hud.draw_mutations(player)
   if not player then return end

   local config = GameConstants.Hud.mutations
   local x = config.x
   local y = config.y
   local spacing_x = config.spacing_x

   -- Draw mutations
   local mutations = player.mutations
   local names = {"Eggsaggerated", "Broodmother", "Pureblood"}

   for i = 1, 3 do
      local mutation_name = names[i]
      local mutation_level = mutations[mutation_name]
      x += i == 1 and 0 or spacing_x
      Rendering.draw_outlined(config.sprites[mutation_name], x, y, config.shadow_color)
      print_shadowed(
         mutation_level,
         x + config.text_offset_x,
         y + config.text_offset_y,
         config.text_color,
         config.shadow_color)
   end
end

--- Draw the inventory HUD
--- @param player table - The player entity to read stats from
function Hud.draw_inventory(player)
   if not player then return end

   local config = GameConstants.Hud.inventory
   local x = config.x
   local y = config.y
   local spacing = config.spacing_x

   -- Draw Coins
   Rendering.draw_outlined(config.sprites.coins, x, y, config.shadow_color)
   local coin_str = string.format("%02d", player.coins or 0)
   print_shadowed(coin_str, x + config.text_offset_x, y + config.text_offset_y, config.text_color, config.shadow_color)

   -- Draw Bombs
   x += spacing
   Rendering.draw_outlined(config.sprites.bombs, x, y, config.shadow_color)
   local bomb_str = string.format("%02d", player.bombs or 0)
   print_shadowed(bomb_str, x + config.text_offset_x, y + config.text_offset_y, config.text_color, config.shadow_color)

   -- Draw Keys
   x += spacing
   Rendering.draw_outlined(config.sprites.keys, x, y, config.shadow_color)
   local key_str = string.format("%02d", player.keys or 0)
   print_shadowed(key_str, x + config.text_offset_x, y + config.text_offset_y, config.text_color, config.shadow_color)
end

--- Draw shop item price tags (called in world-space before camera reset)
--- @param shop_world table - The ECS world to query for shop items
function Hud.draw_shop_prices(shop_world)
   shop_world.sys("shop_item,drawable", function(item)
      if item.purchased then return end

      local price = item.price or 10
      local price_str = "$"..price
      local text_x = item.x + 8 - #price_str * 2 -- Center text (each char ~4px)
      local text_y = item.y + 18                 -- Below the item

      -- Draw price with shadow
      print(price_str, text_x + 1, text_y + 1, 0) -- Shadow
      print(price_str, text_x, text_y, 10)        -- Yellow text

      -- Draw item name above
      if item.item_name then
         local name_x = item.x + 8 - #item.item_name * 2
         local name_y = item.y - 8
         print(item.item_name, name_x + 1, name_y + 1, 0) -- Shadow
         print(item.item_name, name_x, name_y, 7)         -- White text
      end
   end)()
end

--- Draw boss health bar at top of screen
--- @param world table - The ECS world to query for boss entities
function Hud.draw_boss_health(world)
   -- Find boss entity
   local boss = nil
   world.sys("boss,health", function(e)
      if not e.dead then
         boss = e
      end
   end)()

   if not boss then return end

   -- Health bar config
   local bar_width = 200
   local bar_height = 12
   local bar_x = (SCREEN_WIDTH - bar_width) / 2
   local bar_y = 26

   -- Background (dark)
   rectfill(bar_x - 2, bar_y - 2, bar_x + bar_width + 1, bar_y + bar_height + 1, 0)

   -- Border
   rect(bar_x - 1, bar_y - 1, bar_x + bar_width, bar_y + bar_height, 5)

   -- Health fill
   local hp_ratio = (boss.hp or 0) / (boss.max_hp or 1)
   local fill_width = flr(bar_width * hp_ratio)

   -- Color based on phase (green -> yellow -> red)
   local fill_color = 11 -- Green
   if hp_ratio <= 0.33 then
      fill_color = 8     -- Red for phase 3
   elseif hp_ratio <= 0.66 then
      fill_color = 10    -- Yellow for phase 2
   end

   if fill_width > 0 then
      rectfill(bar_x, bar_y, bar_x + fill_width - 1, bar_y + bar_height - 1, fill_color)
   end

   -- Phase indicators (tick marks at 33% and 66%)
   local phase2_x = bar_x + flr(bar_width * 0.66)
   local phase3_x = bar_x + flr(bar_width * 0.33)
   line(phase2_x, bar_y, phase2_x, bar_y + bar_height - 1, 0)
   line(phase3_x, bar_y, phase3_x, bar_y + bar_height - 1, 0)

   -- Boss name
   local name = "GREEN WITCH"
   local name_x = (SCREEN_WIDTH - #name * 4) / 2
   print(name, name_x + 1, bar_y + bar_height + 4, 0) -- Shadow
   print(name, name_x, bar_y + bar_height + 3, 7)     -- White
end

local function draw_trajectory_indicator(entity)
   local is_moving = entity.vel_x ~= 0 or entity.vel_y ~= 0
   local has_target = entity.flee_target_x
   if not is_moving or not has_target then return end

   -- Get center position (get_center returns two values, not a table)
   local cx, cy = HitboxUtils.get_center(entity)
   -- Target center (add 16 to center on 32x32 indicator sprite)
   local tx = entity.flee_target_x + 16
   local ty = entity.flee_target_y + 16

   -- Draw thick line using multiple parallel lines
   local thickness = 3
   for i = -thickness, thickness do
      line(cx + i, cy, tx + i, ty, 8) -- Horizontal offset
      line(cx, cy + i, tx, ty + i, 8) -- Vertical offset
   end
end

--- Draw boss telegraphs (flee targets, attack indicators, trajectory)
--- Call in world-space (before camera reset)
--- @param world table - The ECS world to query for boss entities
function Hud.draw_boss_telegraphs(world)
   -- Find boss entity
   local boss = nil
   world.sys("boss,enemy", function(e)
      if not e.dead then
         boss = e
      end
   end)()

   if not boss then return end

   draw_trajectory_indicator(boss)
end

return Hud

:: src/ui/init.lua
-- UI Module Aggregator
-- Exposes all UI-related modules through a single namespace

local Minimap = require("src/ui/minimap")
local Hud = require("src/ui/hud")
local XpBar = require("src/ui/xp_bar")
local HealthBar = require("src/ui/health_bar")

return {
   Minimap = Minimap,
   Hud = Hud,
   XpBar = XpBar,
   HealthBar = HealthBar,
}

:: src/ui/minimap.lua
-- Minimap Module
-- Isaac-style minimap displaying dungeon layout in the corner
--
-- Displays:
-- - Visited rooms as filled cells
-- - Current room with highlight (centered in viewport)
-- - Adjacent unvisited rooms (fog of war)
-- - Special room icons (start, shop, treasure, boss)
-- - Fixed viewport with scrolling when dungeon is larger

local DungeonManager = require("src/world/dungeon_manager")
local GameConstants = require("src/game/game_config")
local Events = require("src/game/events")

local Minimap = {}

-- State
Minimap.visited = {}           -- Hash map of visited room keys
Minimap.current_x = nil        -- Current X position
Minimap.current_y = nil        -- Current Y position
Minimap.target_x = nil         -- Target X position
Minimap.target_y = nil         -- Target Y position
Minimap.start_x = nil          -- Start X for tween
Minimap.start_y = nil          -- Start Y for tween
Minimap.quadrant = 0           -- 0:TR, 1:BR, 2:BL, 3:TL
Minimap.tween_timer = 0        -- Tween progress timer
Minimap.player_in_zone = false -- Track if player is overlapping

--- Helper: Get target coordinates for a quadrant
function Minimap.get_quadrant_pos(q)
   local cfg = GameConstants.Minimap
   local cell_total = cfg.cell_size + cfg.padding
   local viewport_width = cfg.viewport_w * cell_total - cfg.padding
   local viewport_height = cfg.viewport_h * cell_total - cfg.padding

   local x, y
   if q == 0 then -- Top-Right
      x = SCREEN_WIDTH - cfg.margin_x - viewport_width
      y = cfg.margin_y
   elseif q == 1 then -- Bottom-Right
      x = SCREEN_WIDTH - cfg.margin_x - viewport_width
      y = SCREEN_HEIGHT - cfg.margin_y_bottom - viewport_height
   elseif q == 2 then -- Bottom-Left
      x = cfg.margin_x
      y = SCREEN_HEIGHT - cfg.margin_y_bottom - viewport_height
   elseif q == 3 then -- Top-Left
      x = cfg.margin_x
      y = cfg.margin_y
   end
   return x, y
end

--- Helper: Get rotation direction based on approach velocity
--- @param q number Current quadrant (0-3)
--- @param vx number velocity X
--- @param vy number velocity Y
--- @return integer 1 (CW) or -1 (ACW)
function Minimap.get_rotation_direction(q, vx, vy)
   -- Default to Clockwise (1)
   local dir = 1
   local abs_vx = abs(vx)
   local abs_vy = abs(vy)

   if q == 0 then                    -- Top-Right
      if abs_vx > abs_vy then
         if vx > 0 then dir = 1 end  -- From Left -> CW
      else
         if vy < 0 then dir = -1 end -- From Bottom (moving up) -> ACW
      end
   elseif q == 1 then                -- Bottom-Right
      if abs_vy > abs_vx then
         if vy > 0 then dir = 1 end  -- From Top (moving down) -> CW
      else
         if vx > 0 then dir = -1 end -- From Left -> ACW
      end
   elseif q == 2 then                -- Bottom-Left
      if abs_vx > abs_vy then
         if vx < 0 then dir = 1 end  -- From Right -> CW
      else
         if vy > 0 then dir = -1 end -- From Top -> ACW
      end
   elseif q == 3 then                -- Top-Left
      if abs_vy > abs_vx then
         if vy < 0 then dir = 1 end  -- From Bottom -> CW
      else
         if vx < 0 then dir = -1 end -- From Right -> ACW
      end
   end
   return dir
end

--- Reset minimap state (call when entering play scene)
function Minimap.init()
   local cfg = GameConstants.Minimap

   Minimap.visited = {}
   Minimap.quadrant = 0 -- Start at Top-Right

   local start_x, start_y = Minimap.get_quadrant_pos(0)
   Minimap.current_x = start_x
   Minimap.current_y = start_y
   Minimap.target_x = start_x
   Minimap.target_y = start_y
   Minimap.start_x = start_x
   Minimap.start_y = start_y
   Minimap.tween_timer = 0
   Minimap.player_in_zone = false

   -- Subscribe to zone events
   Events.on(Events.MINIMAP_ZONE_ENTER, function(dir)
      -- Move to next quadrant based on direction (default CW)
      local d = dir or 1
      Minimap.quadrant = (Minimap.quadrant + d + 4) % 4
      Minimap.start_x = Minimap.current_x
      Minimap.start_y = Minimap.current_y
      Minimap.target_x, Minimap.target_y = Minimap.get_quadrant_pos(Minimap.quadrant)
      Minimap.tween_timer = cfg.tween_duration
   end)

   Events.on(Events.MINIMAP_ZONE_EXIT, function()
      -- Do nothing on exit; we stay in the new safe corner
   end)
end

--- Mark a room as visited
--- @param room The room to mark as visited
function Minimap.visit(room)
   if room then
      local key = room.grid_x..","..room.grid_y
      Minimap.visited[key] = true
   end
end

--- Check if a room has been visited
--- @param gx Grid X coordinate
--- @param gy Grid Y coordinate
--- @return boolean
function Minimap.is_visited(gx, gy)
   return Minimap.visited[gx..","..gy] == true
end

--- Calculate the grid bounds of all rooms
--- @return min_gx, max_gx, min_gy, max_gy
function Minimap.get_grid_bounds()
   local min_gx, max_gx = 0, 0
   local min_gy, max_gy = 0, 0

   for _, room in pairs(DungeonManager.rooms) do
      min_gx = min(min_gx, room.grid_x)
      max_gx = max(max_gx, room.grid_x)
      min_gy = min(min_gy, room.grid_y)
      max_gy = max(max_gy, room.grid_y)
   end

   return min_gx, max_gx, min_gy, max_gy
end

--- Calculate viewport offset to center on current room
--- @param current_room The player's current room
--- @param min_gx Minimum grid X
--- @param max_gx Maximum grid X
--- @param min_gy Minimum grid Y
--- @param max_gy Maximum grid Y
--- @return view_min_gx, view_min_gy (the grid coordinates of top-left cell in viewport)
function Minimap.get_viewport_bounds(current_room, min_gx, max_gx, min_gy, max_gy)
   local cfg = GameConstants.Minimap

   if not current_room then
      return min_gx, min_gy
   end

   -- Calculate the ideal top-left to center current room in viewport
   local half_vp_w = flr(cfg.viewport_w / 2)
   local half_vp_h = flr(cfg.viewport_h / 2)

   -- Always center on current room
   local view_min_gx = current_room.grid_x - half_vp_w
   local view_min_gy = current_room.grid_y - half_vp_h

   return view_min_gx, view_min_gy
end

--- Convert grid coordinates to screen position (with viewport bounds)
--- @param gx Grid X coordinate
--- @param gy Grid Y coordinate
--- @param view_min_gx Top-left grid X of viewport
--- @param view_min_gy Top-left grid Y of viewport
--- @param viewport_width Viewport width in pixels
--- @param map_y Y position of the minimap (top-left corner)
--- @return number screen_x, number screen_y, boolean is_visible
function Minimap.grid_to_screen_viewport(gx, gy, view_min_gx, view_min_gy, viewport_width, map_x, map_y)
   local cfg = GameConstants.Minimap
   local cell_total = cfg.cell_size + cfg.padding

   -- Position relative to viewport's top-left
   local rel_x = gx - view_min_gx
   local rel_y = gy - view_min_gy

   -- Check if within viewport bounds
   local is_visible = rel_x >= 0 and rel_x < cfg.viewport_w and
      rel_y >= 0 and rel_y < cfg.viewport_h

   local screen_x = map_x + rel_x * cell_total
   local screen_y = map_y + rel_y * cell_total

   return screen_x, screen_y, is_visible
end

--- Check if player screen position overlaps with minimap bounds (with margin)
--- @param player_screen_x Player X position in screen coordinates
--- @param player_screen_y Player Y position in screen coordinates
--- @param map_x Minimap X position
--- @param map_y Minimap Y position
--- @param viewport_width Minimap width
--- @param viewport_height Minimap height
--- @return boolean
function Minimap.is_player_overlapping(player_screen_x, player_screen_y, map_x, map_y, viewport_width, viewport_height)
   local cfg = GameConstants.Minimap
   local margin_x = cfg.overlap_margin_x or 16
   local margin_y = cfg.overlap_margin_y or 16

   -- Expand minimap bounds by margin for earlier detection
   local left = map_x - margin_x
   local right = map_x + viewport_width + margin_x
   local top = map_y - margin_y
   local bottom = map_y + viewport_height + margin_y

   -- Check if player center is within expanded minimap bounds
   return player_screen_x >= left and player_screen_x <= right and
      player_screen_y >= top and player_screen_y <= bottom
end

--- Update tween animation (call once per frame)
function Minimap.update()
   if Minimap.tween_timer > 0 then
      local cfg = GameConstants.Minimap
      -- Calculate progress (0 to 1, from end to start because timer counts down)
      local progress = 1 - (Minimap.tween_timer / cfg.tween_duration)
      -- Ease-out: fast start, slow end
      local eased = 1 - (1 - progress) * (1 - progress)

      -- Interpolate X and Y
      Minimap.current_x = Minimap.start_x + (Minimap.target_x - Minimap.start_x) * eased
      Minimap.current_y = Minimap.start_y + (Minimap.target_y - Minimap.start_y) * eased

      Minimap.tween_timer = Minimap.tween_timer - 1
   else
      Minimap.current_x = Minimap.target_x
      Minimap.current_y = Minimap.target_y
   end
end

--- Draw the minimap
--- @param current_room The player's current room
function Minimap.draw(current_room)
   local cfg = GameConstants.Minimap

   -- Get grid bounds
   local min_gx, max_gx, min_gy, max_gy = Minimap.get_grid_bounds()

   -- Calculate viewport bounds centered on current room
   local view_min_gx, view_min_gy = Minimap.get_viewport_bounds(current_room, min_gx, max_gx, min_gy, max_gy)

   -- Calculate viewport size in pixels
   local cell_total = cfg.cell_size + cfg.padding
   local viewport_width = cfg.viewport_w * cell_total - cfg.padding
   local viewport_height = cfg.viewport_h * cell_total - cfg.padding

   -- Calculate position using tweened current_y
   -- Calculate position using tweened current_x/y
   local map_x = Minimap.current_x or (SCREEN_WIDTH - cfg.margin_x - viewport_width)
   local map_y = Minimap.current_y or cfg.margin_y

   -- Draw checkerboard background (1px pattern: 0x5A5A)
   fillp(0x5A5A)
   rrectfill(map_x, map_y, viewport_width, viewport_height, 1, cfg.background_color)
   fillp(0) -- Reset fill pattern

   -- First pass: draw unexplored but adjacent rooms (fog of war)
   for _, room in pairs(DungeonManager.rooms) do
      local key = room.grid_x..","..room.grid_y
      if not Minimap.visited[key] then
         -- Check if adjacent to any visited room
         local is_adjacent = false
         if room.doors then
            for _, door in pairs(room.doors) do
               if Minimap.is_visited(door.target_gx, door.target_gy) then
                  is_adjacent = true
                  break
               end
            end
         end

         if is_adjacent then
            local sx, sy, is_visible = Minimap.grid_to_screen_viewport(
               room.grid_x, room.grid_y, view_min_gx, view_min_gy, viewport_width, map_x, map_y)

            if is_visible then
               -- Draw filled cell for unexplored adjacent room
               rrectfill(sx, sy, cfg.cell_size, cfg.cell_size, 1, cfg.unexplored_color)

               -- Draw special room icon if applicable
               local icon = cfg.icons[room.room_type]
               if icon then
                  local icon_x = sx + flr((cfg.cell_size - cfg.icon_size) / 2)
                  local icon_y = sy + flr((cfg.cell_size - cfg.icon_size) / 2)
                  spr(icon, icon_x, icon_y)
               end
            end
         end
      end
   end

   -- Second pass: draw visited rooms
   for key, _ in pairs(Minimap.visited) do
      -- Parse grid coordinates from key
      local gx, gy = key:match("(-?%d+),(-?%d+)")
      gx, gy = tonumber(gx), tonumber(gy)

      local room = DungeonManager.rooms[key]
      if room then
         local sx, sy, is_visible = Minimap.grid_to_screen_viewport(
            gx, gy, view_min_gx, view_min_gy, viewport_width, map_x, map_y)

         if is_visible then
            -- Determine if this is the current room
            local is_current = current_room and
               current_room.grid_x == gx and
               current_room.grid_y == gy

            -- Draw filled cell
            local fill_color = is_current and cfg.current_color or cfg.visited_color
            rrectfill(sx, sy, cfg.cell_size, cfg.cell_size, 1, fill_color)

            -- Draw special room icon
            local icon = cfg.icons[room.room_type]
            if icon then
               -- Center the 10x10 icon in the cell
               local icon_x = sx + flr((cfg.cell_size - cfg.icon_size) / 2)
               local icon_y = sy + flr((cfg.cell_size - cfg.icon_size) / 2)
               spr(icon, icon_x, icon_y)
            end
         end
      end
   end
end

--- Update minimap trigger logic (check player overlap)
--- @param player Player entity
--- @param camera_manager CameraManager instance
function Minimap.update_trigger(player, camera_manager)
   if not player then return end

   local cfg = GameConstants.Minimap
   local sx, sy = camera_manager:get_offset()
   local player_screen_x = player.x - sx + player.width / 2
   local player_screen_y = player.y - sy + player.height / 2

   local cell_total = cfg.cell_size + cfg.padding
   local viewport_width = cfg.viewport_w * cell_total - cfg.padding
   local viewport_height = cfg.viewport_h * cell_total - cfg.padding

   local map_x = Minimap.current_x or (SCREEN_WIDTH - cfg.margin_x - viewport_width)
   local map_y = Minimap.current_y or cfg.margin_y

   local is_overlapping = Minimap.is_player_overlapping(
      player_screen_x, player_screen_y, map_x, map_y, viewport_width, viewport_height)

   if is_overlapping and not Minimap.player_in_zone then
      Minimap.player_in_zone = true
      local dir = Minimap.get_rotation_direction(Minimap.quadrant, player.vel_x, player.vel_y)
      Events.emit(Events.MINIMAP_ZONE_ENTER, dir)
   elseif not is_overlapping and Minimap.player_in_zone then
      Minimap.player_in_zone = false
      Events.emit(Events.MINIMAP_ZONE_EXIT)
   end
end

return Minimap

:: src/ui/xp_bar.lua
-- XP Bar UI component
-- Renders XP progress bar at the bottom of the screen
local GameConstants = require("src/game/game_config")

local XpBar = {}

-- Helper to draw text with shadow for readability
local function print_shadowed(str, x, y, col, shadow_col)
   print(str, x + 1, y + 1, shadow_col or 1)
   print(str, x, y, col)
end

-- Draw the XP bar
-- @param player - The player entity to read XP stats from
function XpBar.draw(player)
   if not player then return end

   local config = GameConstants.Hud.xp_bar
   local screen_width = SCREEN_WIDTH -- Picotron screen width

   -- Calculate bar dimensions
   local bar_height = config.height or 6
   local bar_x = config.x or 4
   local bar_y = config.y or 256
   local bar_width = config.width or screen_width - (bar_x * 2)

   -- Calculate fill percentage
   local xp = player.xp or 0
   local xp_needed = player.xp_to_next_level or GameConstants.Player.base_xp_to_level
   local fill_percent = xp / xp_needed
   if fill_percent > 1 then fill_percent = 1 end
   local fill_width = math.floor(bar_width * fill_percent)

   -- Draw background
   rectfill(bar_x, bar_y, bar_x + bar_width, bar_y + bar_height, config.bg_color or 1)

   -- Draw fill
   if fill_width > 0 then
      rectfill(bar_x + 1, bar_y + 1, bar_x + fill_width - 1, bar_y + bar_height - 1, config.fill_color or 10)
   end

   -- Draw border
   rect(bar_x, bar_y, bar_x + bar_width, bar_y + bar_height, config.border_color or 5)

   -- Draw level text (inside the bar, left aligned)
   local level_text = "Lv."..tostring(player.level or 1)
   print_shadowed(level_text, bar_x + 4, bar_y + 1, config.text_color or 7, 0)

   -- Draw XP text (inside the bar, right aligned)
   local xp_text = xp.."/"..xp_needed.." XP"
   local text_width = #xp_text * 4
   print_shadowed(xp_text, bar_x + bar_width - text_width - 8, bar_y + 1, config.text_color or 7, 0)
end

return XpBar

:: src/utils.lua
return require("src/utils/init")

:: src/utils/collision_utils.lua
-- Collision Utilities
-- Low-level collision detection primitives (stateless)
-- Extracted to avoid circular dependencies between Collision System and Handlers

local CollisionUtils = {}

local HitboxUtils = require("src/utils/hitbox_utils")

local get_hitbox = HitboxUtils.get_hitbox

-- Constants (Must match global config if not passed)
local GRID_SIZE = 16
local TILE_EDGE_TOLERANCE = 1
local SOLID_FLAG = 0
local FEATURE_FLAG_PIT = 4 -- Check globals or pass explicitly if needed

--- Helper: Iterate over tiles overlapping a hitbox
--- @param hb Hitbox
--- @param callback function(tx, ty, tile)
--- @return nil|number, nil|number, nil|number
function CollisionUtils.for_each_tile(hb, callback)
   local x1 = flr(hb.x / GRID_SIZE)
   local y1 = flr(hb.y / GRID_SIZE)
   local x2 = flr((hb.x + hb.w - TILE_EDGE_TOLERANCE) / GRID_SIZE)
   local y2 = flr((hb.y + hb.h - TILE_EDGE_TOLERANCE) / GRID_SIZE)

   for tx = x1, x2 do
      for ty = y1, y2 do
         local tile = mget(tx, ty)
         local r1, r2, r3 = callback(tx, ty, tile)
         if r1 ~= nil then return r1, r2, r3 end
      end
   end
   return nil, nil, nil
end

--- Find solid tile with entity-aware logic
---
--- @param x number
--- @param y number
--- @param w number
--- @param h number
--- @param entity Entity
--- @returns nil|number, nil|number, nil|number
function CollisionUtils.find_solid_tile(x, y, w, h, entity)
   local stx, sty, stile = CollisionUtils.for_each_tile({x = x, y = y, w = w, h = h}, function(tx, ty, tile)
      if tile and fget(tile, SOLID_FLAG) then
         -- All projectiles (player and enemy) can fly over pits
         if fget(tile, FEATURE_FLAG_PIT) and entity and
            (entity.type == "Projectile" or entity.type == "EnemyProjectile") then
            return nil     -- Projectiles ignore pits
         end
         return tx, ty, tile
      end
   end)

   return stx, sty, stile
end

--- Check if an area contains a solid tile
---
--- @param x number
--- @param y number
--- @param w number
--- @param h number
--- @param entity Entity
--- @return boolean
function CollisionUtils.is_solid(x, y, w, h, entity)
   return CollisionUtils.find_solid_tile(x, y, w, h, entity) ~= nil
end

return CollisionUtils

:: src/utils/entity_utils.lua
local GameConstants = require("src/game/game_config")
local Utils = {}

-- Get the configuration table for an entity based on its type and enemy_type
function Utils.get_config(entity)
    if entity.type == "Enemy" and entity.enemy_type then
        return GameConstants.Enemy[entity.enemy_type]
    end
    -- Handle projectile Type Object pattern
    if (entity.type == "Projectile" or entity.type == "EnemyProjectile") and entity.projectile_type then
        return GameConstants.Projectile[entity.projectile_type]
    end
    -- Handle minion Type Object pattern
    if entity.minion_type then
        return GameConstants.Minion[entity.minion_type]
    end
    return GameConstants[entity.type]
end

-- Convert direction vector (dx, dy) to direction name string
-- @param dx - x component of direction (-1, 0, or 1)
-- @param dy - y component of direction (-1, 0, or 1)
-- @return "right", "left", "up", or "down"
-- Convert direction vector (dx, dy) to direction name string
-- @param dx - x component of direction
-- @param dy - y component of direction
-- @param default - optional fallback value if movement is below threshold
-- @return "right", "left", "up", "down", or the provided default
function Utils.get_direction_name(dx, dy, default)
    local threshold = 0.1
    if dx > threshold then
        return "right"
    elseif dx < -threshold then
        return "left"
    elseif dy > threshold then
        return "down"
    elseif dy < -threshold then
        return "up"
    end
    return default
end

-- Get center coordinates of an entity
-- @param entity
-- @return cx, cy
function Utils.get_center(entity)
    return entity.x + (entity.width or 16) / 2, entity.y + (entity.height or 16) / 2
end

-- Convert direction name string to vector (dx, dy)
-- @param dir_name - "right", "left", "up", or "down"
-- @return dx, dy
function Utils.get_direction_vector(dir_name)
    if dir_name == "up" then return 0, -1 end
    if dir_name == "down" then return 0, 1 end
    if dir_name == "left" then return -1, 0 end
    if dir_name == "right" then return 1, 0 end
    return 0, 1 -- Default to down
end

-- Centralized entity spawning with automatic shadow creation
-- @param world - ECS world
-- @param tags - comma-separated tag string (include "shadow" for auto shadow creation)
-- @param entity_data - entity property table
-- @return the created entity
function Utils.spawn_entity(world, tags, entity_data)
    local ent = world.ent(tags, entity_data)

    -- Auto-spawn shadow if entity has "shadow" tag
    if tags:find("shadow") then
        local Shadow = require("src/entities/shadow")
        Shadow.spawn(world, ent)
    end

    return ent
end

return Utils

:: src/utils/hitbox_utils.lua
local HitboxUtils = {}

function HitboxUtils.get_center(entity)
    local hitbox = HitboxUtils.get_hitbox(entity)
    return hitbox.x + hitbox.w / 2, hitbox.y + hitbox.h / 2
end

-- Get hitbox bounds in world space
-- Returns {x, y, w, h} for collision detection
-- Supports two formats:
--   1. Simple: entity.hitbox = {w, h, ox, oy} - same hitbox for all directions
--   2. Per-direction: entity.hitboxes = {down = {...}, up = {...}, ...}
-- Falls back to hitbox_* properties, then width/height
function HitboxUtils.get_hitbox(entity)
    local w, h, ox, oy

    -- Check for per-direction hitboxes table first
    if entity.hitboxes then
        local dir = entity.direction or entity.current_direction
        local dir_hb = dir and entity.hitboxes[dir]
        if dir_hb then
            w = dir_hb.w
            h = dir_hb.h
            ox = dir_hb.ox or 0
            oy = dir_hb.oy or 0
        end
    end

    -- Check for simple hitbox table (same for all directions)
    if not w and entity.hitbox and entity.hitbox.w then
        w = entity.hitbox.w
        h = entity.hitbox.h
        ox = entity.hitbox.ox or 0
        oy = entity.hitbox.oy or 0
    end

    -- Fallback to simple hitbox properties
    w = w or entity.hitbox_width or entity.width or 16
    h = h or entity.hitbox_height or entity.height or 16
    ox = ox or entity.hitbox_offset_x or 0
    oy = oy or entity.hitbox_offset_y or 0

    return {
        x = entity.x + ox + (entity.sprite_offset_x or 0),
        y = entity.y + oy + (entity.sprite_offset_y or 0) - (entity.z or 0),
        w = w,
        h = h
    }
end

return HitboxUtils

:: src/utils/init.lua
-- Utils module aggregator
local HitboxUtils = require("src/utils/hitbox_utils")
local EntityUtils = require("src/utils/entity_utils")
local Palette = require("src/utils/palette")
local TextUtils = require("src/utils/text_utils")

local Utils = {}

Utils.Hitbox = HitboxUtils
Utils.Entity = EntityUtils
Utils.Palette = Palette
Utils.Text = TextUtils

return Utils

:: src/utils/leveling.lua
-- Leveling utility module
-- Handles XP accumulation and level progression (player-specific, not ECS system)
local GameConstants = require("src/game/game_config")
local Events = require("src/game/events")

local Leveling = {}

-- Calculate XP needed for a given level (linear for levels 1-10)
function Leveling.xp_for_level(level)
   local base = GameConstants.Player.base_xp_to_level
   local linear = GameConstants.Player.xp_per_level_linear
   return base + (level - 1) * linear
end

-- Check and process level ups (called from play.lua with player entity)
function Leveling.check_level_up(player)
   if not player then return end

   local required = player.xp_to_next_level or Leveling.xp_for_level(player.level or 1)

   while player.xp >= required do
      player.xp = player.xp - required
      player.level = player.level + 1
      player.xp_to_next_level = Leveling.xp_for_level(player.level)
      required = player.xp_to_next_level

      -- Emit level up event for UI/effects
      Events.emit(Events.LEVEL_UP, player, player.level)
   end
end

return Leveling

:: src/utils/math_utils.lua
local MathUtils = {}

--- Check if a line segment intersects an AABB (Axis-Aligned Bounding Box)
--- @param x1 number Segment start X
--- @param y1 number Segment start Y
--- @param x2 number Segment end X
--- @param y2 number Segment end Y
--- @param bx number Box X (top-left)
--- @param by number Box Y (top-left)
--- @param bw number Box Width
--- @param bh number Box Height
--- @return boolean
function MathUtils.segment_intersects_aabb(x1, y1, x2, y2, bx, by, bw, bh)
   -- 1. Check if the segment's bounding box intersects the AABB (Broad phase)
   local min_x = min(x1, x2)
   local max_x = max(x1, x2)
   local min_y = min(y1, y2)
   local max_y = max(y1, y2)

   if max_x < bx or min_x > bx + bw or max_y < by or min_y > by + bh then
      return false
   end

   -- 2. Check overlap logic using the slab method or similar
   -- Since we are in 2D, we can check intersection with the four lines of the box
   -- simple Liang-Barsky line clipping algorithm is robust here

   local t0, t1 = 0, 1
   local dx = x2 - x1
   local dy = y2 - y1

   local p = {-dx, dx, -dy, dy}
   local q = {x1 - bx, bx + bw - x1, y1 - by, by + bh - y1}

   for i = 1, 4 do
      if p[i] == 0 then
         -- Line is parallel to this boundary
         if q[i] < 0 then return false end    -- Outside boundary
      else
         local t = q[i] / p[i]
         if p[i] < 0 then
            if t > t1 then return false end
            if t > t0 then t0 = t end
         else
            if t < t0 then return false end
            if t < t1 then t1 = t end
         end
      end
   end

   return true
end

return MathUtils

:: src/utils/palette.lua
-- Palette utility for extended color initialization
local Palette = {}

Palette.BASE_COLORS = {
   [0] = 0x000000,
   [1] = 0x1d2b53,
   [2] = 0x7e2553,
   [3] = 0x008751,
   [4] = 0xab5236,
   [5] = 0x5f574f,
   [6] = 0xc2c3c7,
   [7] = 0xfff1e8,
   [8] = 0xff004d,
   [9] = 0xffa300,
   [10] = 0xffec27,
   [11] = 0x00e436,
   [12] = 0x29adff,
   [13] = 0x83769c,
   [14] = 0xff77a8,
   [15] = 0xffccaa
}

-- Initialize extended palette with lighter/darker color variants
-- Colors 32-47: Lighter variants of 0-15
-- Colors 48-63: Darker variants of 0-15
function Palette.init_extended_palette()
   for i = 0, 15 do
      local c = Palette.BASE_COLORS[i]
      local r = (c >> 16) & 0xff
      local g = (c >> 8) & 0xff
      local b = c & 0xff

      -- Lighter variant (2% toward white)
      local lr = flr(r + (255 - r) * 0.02)
      local lg = flr(g + (255 - g) * 0.02)
      local lb = flr(b + (255 - b) * 0.02)
      local light_argb = 0xff000000 | (lr << 16) | (lg << 8) | lb
      pal(32 + i, light_argb, 2)

      -- Darker variant (50% toward black)
      local dr = flr(r * 0.5)
      local dg = flr(g * 0.5)
      local db = flr(b * 0.5)
      local dark_argb = 0xff000000 | (dr << 16) | (dg << 8) | db
      pal(48 + i, dark_argb, 2)
   end
end

return Palette

:: src/utils/text_utils.lua
-- Text utilities for P8SCII and formatting
local TextUtils = {}

--- Build a p8scii string with an outline for visibility
-- Format: \^o{outline_color}{neighbor_bits}{text}
-- @param text The text to outline
-- @param outline_color The color index for the outline (default 0)
-- @param neighbor_bits Bitmask for neighbors (default "5a" - top, bottom, left, right)
-- @return The formatted P8SCII string
function TextUtils.get_outlined_text(text, outline_color, neighbor_bits)
   outline_color = outline_color or 0
   neighbor_bits = neighbor_bits or "5a"
   local hex_col = string.format("%x", outline_color)
   return string.format("\^o%s%s%s", hex_col, neighbor_bits, text)
end

--- Print text with an outline, handling palt(0, false) automatically
-- @param text The text to print
-- @param x X coordinate
-- @param y Y coordinate
-- @param color Main text color
-- @param outline_color Outline color (default 0)
-- @param neighbor_bits Bitmask for neighbors (default "5a")
function TextUtils.print_outlined(text, x, y, color, outline_color, neighbor_bits)
   local text_str = TextUtils.get_outlined_text(text, outline_color, neighbor_bits)
   palt(0, false)
   print(text_str, x, y, color)
   palt()
end

return TextUtils

:: src/world.lua
return require("src/world/init")

:: src/world/camera_manager.lua
local GameConstants = require("src/game/game_config")
local Events = require("src/game/events")
local CameraManager = Class("CameraManager")
CameraManager:include(Stateful)

local DungeonManager = require("src/world/dungeon_manager")

-- Camera manager responsible for following the player and handling transitions
function CameraManager:initialize(player)
    self.player = player
    self.x = 0
    self.y = 0
    self.current_room = nil
    self:gotoState("Following")
end

-- Base update (empty, will be handled by states)
function CameraManager:update()
end

-- FOLLOWING STATE: Normal camera behavior
local Following = CameraManager:addState("Following")

function Following:update()
    if not self.player or not self.current_room then return end

    -- Calculate ideal camera position (center on player)
    local ideal_x = self.player.x - SCREEN_WIDTH / 2
    local ideal_y = self.player.y - SCREEN_HEIGHT / 2

    -- Get room bounds in pixels
    local room_px = self.current_room.pixels

    -- Clamp camera to room boundaries
    -- If room is smaller than screen, center on room
    local cam_x, cam_y

    if room_px.w >= SCREEN_WIDTH then
        -- Room wider than screen: clamp within room
        cam_x = mid(room_px.x, ideal_x, room_px.x + room_px.w - SCREEN_WIDTH)
    else
        -- Room narrower than screen: center on room
        cam_x = room_px.x - (SCREEN_WIDTH - room_px.w) / 2
    end

    if room_px.h >= SCREEN_HEIGHT then
        -- Room taller than screen: clamp within room
        cam_y = mid(room_px.y, ideal_y, room_px.y + room_px.h - SCREEN_HEIGHT)
    else
        -- Room shorter than screen: center on room
        cam_y = room_px.y - (SCREEN_HEIGHT - room_px.h) / 2
    end

    self.x = cam_x
    self.y = cam_y
end

-- SCROLLING STATE: Interpolate between rooms
local Scrolling = CameraManager:addState("Scrolling")

function Scrolling:enteredState(new_room, dir_gx, dir_gy)
    self.old_room = self.current_room
    self.new_room = new_room
    self.dir_gx = dir_gx
    self.dir_gy = dir_gy
    self.timer = 0
    self.duration = 30 -- Faster transition (45 was a bit long)

    -- Trigger transition events via pub/sub (spawns enemies, clears entities)
    Events.emit(Events.ROOM_TRANSITION, new_room)

    self.start_x = self.x
    self.start_y = self.y

    -- Target camera position centering on new room
    local new_px = new_room.pixels
    if new_px.w >= SCREEN_WIDTH then
        -- Ideal X would be centered on player, but for now we clamp to the new room walls
        self.target_x = mid(new_px.x, self.player.x - SCREEN_WIDTH / 2, new_px.x + new_px.w - SCREEN_WIDTH)
    else
        self.target_x = new_px.x - (SCREEN_WIDTH - new_px.w) / 2
    end

    if new_px.h >= SCREEN_HEIGHT then
        self.target_y = mid(new_px.y, self.player.y - SCREEN_HEIGHT / 2, new_px.y + new_px.h - SCREEN_HEIGHT)
    else
        self.target_y = new_px.y - (SCREEN_HEIGHT - new_px.h) / 2
    end
end

function Scrolling:update()
    self.timer = self.timer + 1
    local t = self.timer / self.duration

    -- Smoothstep interpolation
    t = 3 * t * t - 2 * t * t * t

    self.x = self.start_x + (self.target_x - self.start_x) * t
    self.y = self.start_y + (self.target_y - self.start_y) * t

    -- Lock player movement while scrolling
    if self.player then
        self.player.vel_x = 0
        self.player.vel_y = 0
    end

    if self.timer >= self.duration then
        self:set_room(self.new_room)
        self:gotoState("Following")
    end
end

-- Get camera offset for use with camera() function
function CameraManager:get_offset()
    return self.x, self.y
end

-- Handle transition trigger - detect direction and lookup adjacent room
function CameraManager:on_trigger(px, py)
    -- Determine direction based on player position relative to room center
    local room = self.current_room
    local room_cx = room.pixels.x + room.pixels.w / 2
    local room_cy = room.pixels.y + room.pixels.h / 2

    local dx = px - room_cx
    local dy = py - room_cy

    -- Determine primary direction (use larger delta)
    local dir_gx, dir_gy = 0, 0
    if abs(dx) > abs(dy) then
        dir_gx = dx > 0 and 1 or -1
    else
        dir_gy = dy > 0 and 1 or -1
    end

    -- Calculate target grid position
    local target_gx = room.grid_x + dir_gx
    local target_gy = room.grid_y + dir_gy
    local key = target_gx..","..target_gy

    local new_room = DungeonManager.rooms[key]

    if new_room then
        -- Reposition player to entry point (opposite side of new room)
        -- We do this BEFORE the scroll starts so they are in the right spot
        local new_px = new_room.pixels
        local margin = 24 -- Pixels from wall

        local p_w = GameConstants.Player.width or 16
        local p_h = GameConstants.Player.height or 16

        if dir_gx == 1 then
            -- Entered from west, position at left side (preserve Y)
            self.player.x = new_px.x + margin
        elseif dir_gx == -1 then
            -- Entered from east, position at right side (preserve Y)
            self.player.x = new_px.x + new_px.w - margin - p_w
        elseif dir_gy == 1 then
            -- Entered from north, position at top (preserve X)
            self.player.y = new_px.y + margin
        elseif dir_gy == -1 then
            -- Entered from south, position at bottom (preserve X)
            self.player.y = new_px.y + new_px.h - margin - p_h
        end

        self:gotoState("Scrolling", new_room, dir_gx, dir_gy)
        return new_room
    end
    return nil
end

-- Set the current room for camera bounds
function CameraManager:set_room(room)
    self.current_room = room
    DungeonManager.current_room = room
    DungeonManager.current_grid_x = room.grid_x
    DungeonManager.current_grid_y = room.grid_y
end

function CameraManager:is_scrolling()
    local states = self:getStateStackDebugInfo()
    return states[1] == "Scrolling"
end

return CameraManager

:: src/world/dungeon_manager.lua
local Room = require("src/world/room")
local Events = require("src/game/events")
local RoomLayouts = require("src/world/room_layouts")
local FloorPatterns = require("src/world/floor_patterns")
local WavePatterns = require("src/world/wave_patterns")
local ShopItems = require("src/game/config/shop_items")
local Mutations = require("src/game/mutations")

-- Constants for procedural generation
local ROOM_TILES_W = 29 -- Fixed room width in tiles
local ROOM_TILES_H = 16 -- Fixed room height in tiles (256px fits in 270px screen)
local MIN_ENEMIES_PER_ROOM = 2
local MAX_ENEMIES_PER_ROOM = 5
local ENEMY_DENSITY_DIVISOR = 100      -- Tiles per enemy
local DEFAULT_ENEMY_MIN_DIST = 80      -- Minimum pixels from player
local MAP_MEMORY_ADDRESS = 0x100000    -- Picotron Extended Map Address
local EXT_MAP_W = 256                  -- Large static world map
local EXT_MAP_H = 256                  -- Large static world map
local GRID_STRIDE_X = ROOM_TILES_W - 1 -- Rooms overlap by 1 tile (shared wall)
local GRID_STRIDE_Y = ROOM_TILES_H - 1 -- Rooms overlap by 1 tile (shared wall)
local BASE_OFFSET_X = 128              -- Center offset for grid 0,0 (enough for ~4 rooms in each direction)
local BASE_OFFSET_Y = 128              -- Center offset for grid 0,0 (enough for ~4 rooms in each direction)
local TARGET_ROOM_COUNT = 12
local DIRECTIONS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}

local DungeonManager = {}

DungeonManager.current_room = nil
DungeonManager.rooms = {} -- Hash map: "x,y" -> Room
DungeonManager.map_data = nil

-- Helper: Count neighbors at a grid position
function DungeonManager.count_neighbors(gx, gy)
   local count = 0
   for _, d in ipairs(DIRECTIONS) do
      if DungeonManager.rooms[(gx + d[1])..","..(gy + d[2])] then
         count += 1
      end
   end
   return count
end

-- Helper: Check if a room has no valid expansion directions
function DungeonManager.is_surrounded(gx, gy)
   return DungeonManager.count_neighbors(gx, gy) >= 4
      or DungeonManager.count_valid_expansion_dirs(gx, gy) == 0
end

-- Helper: Count directions where a new room could be placed (Rule of One)
function DungeonManager.count_valid_expansion_dirs(gx, gy)
   local count = 0
   for _, d in ipairs(DIRECTIONS) do
      local nx, ny = gx + d[1], gy + d[2]
      local key = nx..","..ny
      if not DungeonManager.rooms[key] and DungeonManager.count_neighbors(nx, ny) == 1 then
         count += 1
      end
   end
   return count
end

-- Helper: Get all rooms as a list
function DungeonManager.get_all_rooms()
   local list = {}
   for _, r in pairs(DungeonManager.rooms) do add(list, r) end
   return list
end

function DungeonManager.generate()
   DungeonManager.rooms = {}
   local active_list = {}

   -- Phase 1: Create Start Room at 0,0 (Safe Zone)
   local start_room = DungeonManager.create_room(0, 0, true)
   start_room.room_type = "start"
   DungeonManager.rooms["0,0"] = start_room
   add(active_list, start_room)

   -- Phase 2: Expansion Loop (Random Walk with Rule of One)
   while #DungeonManager.get_all_rooms() < TARGET_ROOM_COUNT and #active_list > 0 do
      -- Pick random room from active list
      local parent = active_list[flr(rnd(#active_list)) + 1]

      -- Pick random direction from constant
      local dir = DIRECTIONS[flr(rnd(#DIRECTIONS)) + 1]
      local nx, ny = parent.grid_x + dir[1], parent.grid_y + dir[2]
      local key = nx..","..ny

      -- Check: empty AND only 1 neighbor (Rule of One prevents 2x2 clusters)
      if not DungeonManager.rooms[key] then
         local neighbors = DungeonManager.count_neighbors(nx, ny)
         if neighbors == 1 then
            local new_room = DungeonManager.create_room(nx, ny, false)
            DungeonManager.rooms[key] = new_room
            add(active_list, new_room)
         end
      end

      -- Remove exhausted rooms (no valid expansion directions left)
      if DungeonManager.is_surrounded(parent.grid_x, parent.grid_y) then
         del(active_list, parent)
      end
   end

   -- Phase 3: Specialization (assign room types based on distance/topology)
   DungeonManager.assign_room_types()

   -- Phase 4: Connection (Connect Neighbor Rooms with corridor)
   DungeonManager.connect_neighbor_rooms()

   -- Phase 5: Carve entire dungeon into map
   DungeonManager.fill_map_with_walls() -- Fill entire map with walls first
   -- Carve floors for all rooms (pure floor tiles for autotiling)
   for _, room in pairs(DungeonManager.rooms) do
      DungeonManager.carve_room_floor(room)
   end

   -- Phase 6: Apply autotiling to walls (corners, H/V variants)
   DungeonManager.autotile_walls()

   -- Phase 7: Place obstacles (rocks, pits) AFTER autotiling
   for _, room in pairs(DungeonManager.rooms) do
      DungeonManager.place_room_obstacles(room)
   end

   -- Phase 8: Carve corridors (opens door passages with frame tiles)
   for _, room in pairs(DungeonManager.rooms) do
      DungeonManager.carve_corridors(room)
   end

   -- Set initial state
   DungeonManager.current_room = start_room

   Log.info("Generated dungeon with "..#DungeonManager.get_all_rooms().." rooms")
end

function DungeonManager.create_room(gx, gy, is_safe)
   -- Fixed room dimensions (Isaac style - fills screen)
   local w = ROOM_TILES_W
   local h = ROOM_TILES_H

   -- Grid-based absolute position (rooms directly adjacent)
   local world_tx = BASE_OFFSET_X + (gx * GRID_STRIDE_X)
   local world_ty = BASE_OFFSET_Y + (gy * GRID_STRIDE_Y)

   local room = Room:new(world_tx, world_ty, w, h, is_safe)

   -- Initialize room metadata
   room.grid_x = gx
   room.grid_y = gy

   return room
end

function DungeonManager.apply_door_sprites(room)
   if not room.doors then return end

   for dir, door in pairs(room.doors) do
      local pos = room:get_door_tile(dir)
      if pos then
         mset(pos.tx, pos.ty, door.sprite)
      end
   end
end

function DungeonManager.carve_corridors(room)
   if not room.doors then return end

   for dir, door in pairs(room.doors) do
      -- Get door position in current room
      local pos = room:get_door_tile(dir)
      if pos then
         -- Set door tile to EMPTY_TILE (transparent) - actual door sprite drawn by rendering
         mset(pos.tx, pos.ty, EMPTY_TILE)

         -- Place door frame tiles based on direction
         if dir == "north" or dir == "south" then
            -- North/South door: frame on left and right
            local left_tile = DOOR_FRAME_V_LEFT[flr(rnd(#DOOR_FRAME_V_LEFT)) + 1]
            local right_tile = DOOR_FRAME_V_RIGHT[flr(rnd(#DOOR_FRAME_V_RIGHT)) + 1]
            mset(pos.tx - 1, pos.ty, left_tile)
            mset(pos.tx + 1, pos.ty, right_tile)
         else
            -- East/West door: frame on top and bottom
            local top_tile = DOOR_FRAME_H_TOP[flr(rnd(#DOOR_FRAME_H_TOP)) + 1]
            local bottom_tile = DOOR_FRAME_H_BOTTOM[flr(rnd(#DOOR_FRAME_H_BOTTOM)) + 1]
            mset(pos.tx, pos.ty - 1, top_tile)
            mset(pos.tx, pos.ty + 1, bottom_tile)
         end
      end
   end
end

-- Phase 1: Carve pure floor tiles (called before autotiling)
function DungeonManager.carve_room_floor(room)
   -- Select and assign layout for this room
   local layout = RoomLayouts.get_random_layout(room.room_type or "combat", room)
   room.layout = layout
   Log.info("Carving room ("..
      room.grid_x..","..room.grid_y..") Type="..(room.room_type or "combat").." Layout="..layout.name)
   room.destructibles = {} -- Store positions for destructible entity spawning

   local floor = room:get_inner_bounds()

   local pattern = FloorPatterns.get_pattern(layout.floor_pattern or "random")

   -- First pass: carve all as floor tiles (for proper autotiling)
   for ty = floor.y1, floor.y2 do
      for tx = floor.x1, floor.x2 do
         local floor_tile = pattern(tx, ty, FLOOR_TILES)
         mset(tx, ty, floor_tile)
      end
   end
end

-- Phase 2: Place map-based obstacles (e.g. pits) and pre-generate obstacle data
function DungeonManager.place_room_obstacles(room)
   if not room.layout or not room.layout.grid then return end

   local floor_rect = room:get_inner_bounds()

   -- Use get_all_features for precise cell_pattern placement
   local features = RoomLayouts.get_all_features(room.layout, floor_rect.x1, floor_rect.y1)

   -- Pre-generate obstacle data with deterministic sprite selection (while RNG is seeded)
   room.obstacle_data = {}

   -- For shop rooms, pre-select which items will be sold
   local shop_items_selected = nil
   if room.room_type == "shop" then
      -- Count how many shop_item features are in the layout
      local shop_count = 0
      for _, f in ipairs(features) do
         if f.feature == "shop_item" then shop_count += 1 end
      end
      Log.info("Room ("..room.grid_x..","..room.grid_y..") is SHOP. Found "..shop_count.." shop_item features.")
      shop_items_selected = ShopItems.pick_random_items(shop_count)
   end
   local shop_item_index = 1

   local treasure_selected = nil
   if room.room_type == "treasure" then
      local treasure_count = 0
      for _, f in ipairs(features) do
         if f.feature == "treasure_chest" then treasure_count += 1 end
      end
      Log.info("Room ("..
         room.grid_x..","..room.grid_y..") is TREASURE. Found "..treasure_count.." treasure_chest features.")
      treasure_selected = Mutations.pick_random_items(treasure_count)
   end
   local treasure_index = 1

   for _, f in ipairs(features) do
      if f.feature == "pit" then
         mset(f.tx, f.ty, PIT_TILE)
      elseif f.feature == "rock" then
         -- Pre-select sprite during generation for seed determinism
         local sprite = ROCK_TILES[flr(rnd(#ROCK_TILES)) + 1]
         add(room.obstacle_data, {feature = "rock", tx = f.tx, ty = f.ty, sprite = sprite})
      elseif f.feature == "destructible" then
         -- Pre-select sprite during generation for seed determinism
         local sprite = DESTRUCTIBLE_TILES[flr(rnd(#DESTRUCTIBLE_TILES)) + 1]
         add(room.obstacle_data, {feature = "destructible", tx = f.tx, ty = f.ty, sprite = sprite})
      elseif f.feature == "chest" then
         -- Normal chest - sprite is fixed
         add(room.obstacle_data, {feature = "chest", tx = f.tx, ty = f.ty, sprite = CHEST_TILE})
      elseif f.feature == "locked_chest" then
         -- Locked chest - sprite is fixed
         add(room.obstacle_data, {feature = "locked_chest", tx = f.tx, ty = f.ty, sprite = LOCKED_CHEST_TILE})
      elseif f.feature == "shop_item" and shop_items_selected then
         local item = shop_items_selected[shop_item_index]
         if item then
            add(room.obstacle_data, {
               feature = "shop_item",
               tx = f.tx,
               ty = f.ty,
               sprite = 58, -- Pedestal base sprite
               item_id = item.id,
               item_name = item.name,
               item_sprite = item.sprite,
               price = item.price,
               apply_fn = item.apply
            })
            shop_item_index += 1
         end
      elseif f.feature == "treasure_chest" then
         -- Treasure chest spawning
         local mutation_data = nil
         if treasure_selected and treasure_selected[treasure_index] then
            mutation_data = treasure_selected[treasure_index]
            treasure_index += 1
         end

         add(room.obstacle_data, {
            feature = "treasure_chest",
            tx = f.tx,
            ty = f.ty,
            sprite = TREASURE_CHEST_TILE,
            mutation = mutation_data and mutation_data.mutation,
            mutation_sprite = mutation_data and mutation_data.sprite_index_offsets and
               mutation_data.sprite_index_offsets.down
         })
      end
   end

   DungeonManager.apply_door_sprites(room)
end

function DungeonManager.assign_enemies(room, num_enemies, min_dist, types)
   local area = room.tiles.w * room.tiles.h
   local default_count = mid(MIN_ENEMIES_PER_ROOM, flr(area / ENEMY_DENSITY_DIVISOR), MAX_ENEMIES_PER_ROOM)

   room.contents_config = room.contents_config or {}
   room.contents_config.enemies = {
      count = num_enemies or default_count,
      min_dist = min_dist or DEFAULT_ENEMY_MIN_DIST,
      types = types
   }
end

-- Phase 3: Assign room types based on distance and topology
function DungeonManager.assign_room_types()
   -- Calculate Manhattan distance from origin for each room
   for _, room in pairs(DungeonManager.rooms) do
      room.distance = abs(room.grid_x) + abs(room.grid_y)
   end

   -- Categorize rooms
   local leaves = {}
   local others = {}
   for _, room in pairs(DungeonManager.rooms) do
      if room.room_type ~= "start" then
         local neighbors = DungeonManager.count_neighbors(room.grid_x, room.grid_y)
         if neighbors == 1 then
            add(leaves, room)
         else
            add(others, room)
         end
      end
   end

   -- Note: PICO-8 sort is basic bubble sort usually, or we can use custom implementation
   -- But here we used bubble sort in original code. Retaining that logic or using table.sort if available?
   -- Lua sort: table.sort(list, func). Pico-8 (standard) uses simple sort?
   -- Original code implemented bubble sort manually. I'll stick to that or use a helper.
   -- Let's replicate manual sort for safety/consistency with original code style.
   local function manual_sort(list)
      for i = 1, #list - 1 do
         for j = i + 1, #list do
            if list[j].distance > list[i].distance then
               list[i], list[j] = list[j], list[i]
            end
         end
      end
   end
   manual_sort(leaves)
   manual_sort(others)

   -- Helper to pick next available room (prefer leaves, then others)
   local function pick_next()
      if #leaves > 0 then
         return deli(leaves, 1) -- Take farthest leaf
      elseif #others > 0 then
         return deli(others, 1) -- Fallback to farthest non-leaf
      end
      return nil
   end

   -- Assign special types
   local boss_room = pick_next()
   if boss_room then
      boss_room.room_type = "boss"
      Log.info("Assigned BOSS room: "..boss_room.grid_x..","..boss_room.grid_y)
   end

   local treasure_room = pick_next()
   if treasure_room then
      treasure_room.room_type = "treasure"
      Log.info("Assigned TREASURE room: "..treasure_room.grid_x..","..treasure_room.grid_y)
   else
      Log.error("FAILED to assign TREASURE room! Not enough candidates.")
   end

   local shop_room = pick_next()
   if shop_room then
      shop_room.room_type = "shop"
      Log.info("Assigned SHOP room: "..shop_room.grid_x..","..shop_room.grid_y)
   end

   -- Remaining rooms are combat rooms with wave patterns
   for _, room in pairs(DungeonManager.rooms) do
      if not room.room_type then
         room.room_type = "combat"
         -- Difficulty scales with distance: 1-2 = easy, 3-4 = medium, 5+ = hard
         local difficulty = min(3, flr(room.distance / 2) + 1)
         local pattern = WavePatterns.get_random_pattern(difficulty)
         room.contents_config = {wave_pattern = pattern}
      end
   end
end

-- Phase 4: Connect neighbor rooms and setup corridors
function DungeonManager.connect_neighbor_rooms()
   local door_dirs = {
      {dx = 1,  dy = 0,  from = "east",  to = "west"},
      {dx = -1, dy = 0,  from = "west",  to = "east"},
      {dx = 0,  dy = -1, from = "north", to = "south"},
      {dx = 0,  dy = 1,  from = "south", to = "north"}
   }

   for _, room in pairs(DungeonManager.rooms) do
      room.doors = room.doors or {}
      for _, d in ipairs(door_dirs) do
         local neighbor_key = (room.grid_x + d.dx)..","..(room.grid_y + d.dy)
         if DungeonManager.rooms[neighbor_key] then
            room.doors[d.from] = {
               sprite = DOOR_OPEN_TILE,
               target_gx = room.grid_x + d.dx,
               target_gy = room.grid_y + d.dy
            }
         end
      end
   end
end

function DungeonManager.fill_map_with_walls()
   for ty = 0, EXT_MAP_H - 1 do
      for tx = 0, EXT_MAP_W - 1 do
         mset(tx, ty, WALL_TILE)
      end
   end
end

function DungeonManager.is_floor_tile(tx, ty)
   local tile = mget(tx, ty)
   if tile == 0 then return true end
   for _, f in ipairs(FLOOR_TILES) do
      if tile == f then return true end
   end
   return false
end

function DungeonManager.autotile_walls()
   local tiles_to_check = {}
   local visited = {}

   for _, room in pairs(DungeonManager.rooms) do
      local floor = room:get_inner_bounds()
      -- Check the wall ring around the floor (1 tile margin on all sides)
      local x1, y1 = floor.x1 - 1, floor.y1 - 1
      local x2, y2 = floor.x2 + 1, floor.y2 + 1

      for ty = y1, y2 do
         for tx = x1, x2 do
            -- Only add wall tiles (skip interior floor tiles)
            local is_interior = tx >= floor.x1 and tx <= floor.x2 and ty >= floor.y1 and ty <= floor.y2
            if not is_interior then
               local key = tx..","..ty
               if not visited[key] then
                  visited[key] = true
                  add(tiles_to_check, {tx = tx, ty = ty})
               end
            end
         end
      end
   end

   -- Bitmask lookup: TL=1, TR=2, BL=4, BR=8
   local CORNER_TILES = {
      [1]  = WALL_TILE_CORNER_BR,    -- TL only: outer corner
      [2]  = WALL_TILE_CORNER_BL,    -- TR only: outer corner
      [4]  = WALL_TILE_CORNER_TR,    -- BL only: outer corner
      [8]  = WALL_TILE_CORNER_TL,    -- BR only: outer corner
      [3]  = WALL_TILE_INNER_TOP,    -- TL+TR: inner top
      [12] = WALL_TILE_INNER_BOTTOM, -- BL+BR: inner bottom
      [10] = WALL_TILE_INNER_RIGHT,  -- TR+BR: inner right
      [5]  = WALL_TILE_INNER_LEFT,   -- TL+BL: inner left
   }

   for _, tile in ipairs(tiles_to_check) do
      local tx, ty = tile.tx, tile.ty
      if DungeonManager.is_floor_tile(tx, ty) then goto continue end

      local floor_above = DungeonManager.is_floor_tile(tx, ty - 1)
      local floor_below = DungeonManager.is_floor_tile(tx, ty + 1)
      local floor_left  = DungeonManager.is_floor_tile(tx - 1, ty)
      local floor_right = DungeonManager.is_floor_tile(tx + 1, ty)

      local new_tile    = nil

      if floor_above or floor_below or floor_left or floor_right then
         if floor_above or floor_below then
            new_tile = WALL_TILE_HORIZONTAL[flr(rnd(#WALL_TILE_HORIZONTAL)) + 1]
         else
            new_tile = WALL_TILE_VERTICAL[flr(rnd(#WALL_TILE_VERTICAL)) + 1]
         end
      else
         -- No orthogonal floors: check diagonals with bitmask
         local diag_mask = 0
         if DungeonManager.is_floor_tile(tx - 1, ty - 1) then diag_mask += 1 end -- TL
         if DungeonManager.is_floor_tile(tx + 1, ty - 1) then diag_mask += 2 end -- TR
         if DungeonManager.is_floor_tile(tx - 1, ty + 1) then diag_mask += 4 end -- BL
         if DungeonManager.is_floor_tile(tx + 1, ty + 1) then diag_mask += 8 end -- BR
         new_tile = CORNER_TILES[diag_mask]
      end

      if new_tile then
         mset(tx, ty, new_tile)
      end

      ::continue::
   end
end

--- Setup a room upon entry (spawning, lifecycle transitions, skull timer)
-- @param room The room to setup
-- @param player The player entity (for spawn distance calculations)
-- @param world The ECS world instance
function DungeonManager.setup_room(room, player, world)
   local Systems = require("src/systems")

   -- Log room entry with wave pattern info
   if room.contents_config and room.contents_config.wave_pattern then
      local pattern = room.contents_config.wave_pattern
      Log.info("Entering room ("..room.grid_x..","..room.grid_y..")")
      Log.info("wave pattern="..pattern.name)
      Log.info("Room layout="..room.layout.name)
   end

   Systems.Spawner.populate(room, player)

   -- Spawn obstacles (Rocks, Destructibles, Chests, ShopItems) if not already spawned
   -- Uses pre-generated obstacle_data from dungeon generation for seed determinism
   if not room.obstacles_spawned and room.obstacle_data then
      local Entities = require("src/entities")
      local rocks_count = 0
      local dest_count = 0
      local chest_count = 0
      local locked_chest_count = 0
      local shop_item_count = 0
      local treasure_count = 0

      -- Initialize obstacle entity tracking for this room
      room.obstacle_entities = room.obstacle_entities or {}

      for _, f in ipairs(room.obstacle_data) do
         -- Base position: tile coords to pixels
         -- Rocks/Destructibles have hitbox_offset=4, so we offset by -4 to align hitbox with tile
         -- Chests/ShopItems have custom offsets, no adjustment needed
         local wx, wy
         if f.feature == "chest" or f.feature == "locked_chest" or f.feature == "shop_item" or f.feature == "treasure_chest" then
            wx, wy = f.tx * GRID_SIZE, f.ty * GRID_SIZE
         else
            wx, wy = f.tx * GRID_SIZE - 4, f.ty * GRID_SIZE - 4
         end
         local entity = nil
         if f.feature == "rock" then
            entity = Entities.spawn_obstacle(world, wx, wy, "Rock", f.sprite)
            rocks_count += 1
         elseif f.feature == "destructible" then
            entity = Entities.spawn_obstacle(world, wx, wy, "Destructible", f.sprite)
            dest_count += 1
         elseif f.feature == "chest" then
            entity = Entities.spawn_obstacle(world, wx, wy, "Chest", f.sprite)
            chest_count += 1
         elseif f.feature == "locked_chest" then
            entity = Entities.spawn_obstacle(world, wx, wy, "LockedChest", f.sprite)
            locked_chest_count += 1
         elseif f.feature == "shop_item" then
            entity = Entities.spawn_obstacle(world, wx, wy, "ShopItem", f.item_sprite)
            -- Transfer shop item data from obstacle_data to entity
            entity.item_id = f.item_id
            entity.item_name = f.item_name
            entity.price = f.price
            entity.apply_fn = f.apply_fn
            shop_item_count += 1
         elseif f.feature == "treasure_chest" then
            entity = Entities.spawn_obstacle(world, wx, wy, "TreasureChest", f.sprite)
            if entity then
               entity.mutation = f.mutation
               entity.mutation_sprite = f.mutation_sprite
            end
            treasure_count += 1
         end
         if entity then
            entity.room_key = room.grid_x..","..room.grid_y
            -- Store original tile coordinates for pathfinder (pixel offset doesn't affect this)
            entity.tile_x = f.tx
            entity.tile_y = f.ty
            add(room.obstacle_entities, entity)
         end
      end
      Log.info("Spawned obstacles in room ("..
         room.grid_x..","..room.grid_y.."): "..rocks_count.." rocks, "..dest_count..
         " destructibles, "..chest_count.." chests, "..locked_chest_count..
         " locked chests, "..shop_item_count.." shop items, "..treasure_count.." treasure chests")
      room.obstacles_spawned = true
   end

   -- If enemies assigned and room is populated, trigger enter to lock doors
   if #room.enemy_positions > 0 and room.lifecycle:can("enter") then
      room.lifecycle:enter()
      DungeonManager.apply_door_sprites(room)
   end

   -- Restart skull timer if entering a cleared combat room
   if room.lifecycle:is("cleared") and room.room_type == "combat" then
      room.skull_timer = SKULL_SPAWN_TIMER
      room.skull_spawned = false
   end
end

--- Check if an active room has been cleared of enemies
--- @param room Room to check
--- @param world ECSWorld instance
function DungeonManager.check_room_clear(room, world)
   if not room.lifecycle:is("active") then return end

   local enemy_count = 0
   room.combat_timer += 1
   world.sys("enemy", function(e)
      -- Exclude skulls from enemy count (pressure mechanic, not room enemies)
      if not e.dead and not world.msk(e).skull then
         enemy_count += 1
      end
   end)()

   if enemy_count == 0 then
      room.lifecycle:clear()
      DungeonManager.apply_door_sprites(room)

      -- Notify listeners via pub/sub (play.lua subscribes for player healing, etc.)
      Events.emit(Events.ROOM_CLEAR, room)
   end
end

function DungeonManager.init()
   DungeonManager.map_data = userdata("i16", EXT_MAP_W, EXT_MAP_H)
   memmap(DungeonManager.map_data, MAP_MEMORY_ADDRESS)
   DungeonManager.generate()
end

--- Find the nearest valid floor tile to a position
--- @param px number Pixel X
--- @param py number Pixel Y
--- @param room table|nil Optional room object to check layout features
--- @return number|nil, number|nil (New valid pixel coordinates, or nil if no valid tile found)
function DungeonManager.snap_to_nearest_floor(px, py, room)
   local cx = flr(px / GRID_SIZE)
   local cy = flr(py / GRID_SIZE)

   -- Check if current tile is valid
   if DungeonManager.is_valid_spawn_tile(cx, cy, room) then
      return px, py
   end

   -- Spiral search for nearest valid tile
   local radius = 1
   local max_radius = 5 -- Search up to 5 tiles away

   while radius <= max_radius do
      for dy = -radius, radius do
         for dx = -radius, radius do
            -- Only check the outer ring
            if abs(dx) == radius or abs(dy) == radius then
               local tx, ty = cx + dx, cy + dy
               if DungeonManager.is_valid_spawn_tile(tx, ty, room) then
                  -- Return center of the valid tile
                  return tx * GRID_SIZE + GRID_SIZE / 2 - 8, ty * GRID_SIZE + GRID_SIZE / 2 - 8
                  -- Note: -8 centers a 16x16 entity.
                  -- Ideally we'd know entity size, but centering on tile is a safe default.
               end
            end
         end
      end
      radius = radius + 1
   end

   return nil, nil -- Fallback: no valid tile found, let caller handle
end

--- Check if a tile is a valid spawn location (floor, no pit/obstacle, within room)
function DungeonManager.is_valid_spawn_tile(tx, ty, room)
   -- 1. Check map bounds
   if tx < 0 or tx >= EXT_MAP_W or ty < 0 or ty >= EXT_MAP_H then return false end

   -- 2. Check room inner bounds (must be provided for spawn checks)
   if room then
      local floor_rect = room:get_inner_bounds()
      if tx < floor_rect.x1 or tx > floor_rect.x2 or
         ty < floor_rect.y1 or ty > floor_rect.y2 then
         return false
      end
   end

   -- 3. Check if floor tile
   if not DungeonManager.is_floor_tile(tx, ty) then return false end

   -- 4. Check for map features (Pits)
   local tile = mget(tx, ty)
   if tile == PIT_TILE then return false end
   if fget(tile, FEATURE_FLAG_PIT) then return false end

   -- 5. Check for layout features (Rocks/Destructibles/Chests) if room provided
   if room and room.layout and room.layout.grid then
      local RoomLayouts = require("src/world/room_layouts")
      local floor_rect = room:get_inner_bounds()
      local room_w = floor_rect.x2 - floor_rect.x1 + 1
      local room_h = floor_rect.y2 - floor_rect.y1 + 1
      local gx = tx - floor_rect.x1
      local gy = ty - floor_rect.y1

      local feature = RoomLayouts.get_feature_at(room.layout, gx, gy, room_w, room_h)
      if feature == "rock" or feature == "destructible" or feature == "pit"
         or feature == "chest" or feature == "locked_chest" or feature == "no_spawn" then
         return false
      end
   end

   return true
end

return DungeonManager

:: src/world/floor_patterns.lua
-- Floor Pattern System
-- Provides tile selection patterns for room floors
-- Currently uses random as default, prepared for future patterns

local FloorPatterns = {}

-- Pattern registry
local Patterns = {}

--- Default random pattern (current behavior)
-- @param tx Tile X position
-- @param ty Tile Y position
-- @param tiles Table of floor tile options
-- @return Selected tile number
Patterns.random = function(tx, ty, tiles)
   return tiles[flr(rnd(#tiles)) + 1]
end

--- Get a floor pattern function by name
-- @param name Pattern name
-- @return Pattern function or random as fallback
function FloorPatterns.get_pattern(name)
   return Patterns[name] or Patterns.random
end

--- Get a floor tile using a pattern
-- @param pattern_name Pattern name string
-- @param tx Tile X position
-- @param ty Tile Y position
-- @param tiles Table of floor tile options (default: FLOOR_TILES)
-- @return Selected tile number
function FloorPatterns.get_tile(pattern_name, tx, ty, tiles)
   tiles = tiles or FLOOR_TILES
   local pattern = FloorPatterns.get_pattern(pattern_name)
   return pattern(tx, ty, tiles)
end

-- Future patterns can be added here:
-- Patterns.checkerboard = function(tx, ty, tiles) ... end
-- Patterns.border = function(tx, ty, tiles, bounds) ... end
-- Patterns.gradient = function(tx, ty, tiles, center) ... end

return FloorPatterns

:: src/world/init.lua
-- World module aggregator
local Room = require("src/world/room")
local DungeonManager = require("src/world/dungeon_manager")
local RoomRenderer = require("src/world/room_renderer")
local CameraManager = require("src/world/camera_manager")
local WavePatterns = require("src/world/wave_patterns")
local RoomLayouts = require("src/world/room_layouts")
local FloorPatterns = require("src/world/floor_patterns")

local World = {}

World.Room = Room
World.DungeonManager = DungeonManager
World.RoomRenderer = RoomRenderer
World.CameraManager = CameraManager
World.WavePatterns = WavePatterns
World.RoomLayouts = RoomLayouts
World.FloorPatterns = FloorPatterns

return World

:: src/world/room.lua
local machine = require("lib/lua-state-machine/statemachine")
local Room = Class("Room")
local GameState = require("src/game/game_state")

function Room:initialize(tx, ty, w, h, is_safe)
    self.tiles = {x = tx, y = ty, w = w, h = h}
    self.pixels = {
        x = tx * GRID_SIZE,
        y = ty * GRID_SIZE,
        w = w * GRID_SIZE,
        h = h * GRID_SIZE
    }

    self.enemy_positions = {}

    -- Lifecycle FSM
    local room = self
    self.lifecycle = machine.create({
        initial = is_safe and "empty" or "populated",
        events = {
            {name = "enter", from = "populated", to = "spawning"},
            {name = "spawn", from = "spawning",  to = "active"},
            {name = "clear", from = "active",    to = "cleared"},
        },
        callbacks = {
            onenterspawning = function()
                -- Skip door blocking if cheat enabled
                if GameState.cheats.unlock_all_rooms then return end
                if room.doors then
                    for _, door in pairs(room.doors) do
                        door.sprite = DOOR_BLOCKED_TILE
                    end
                end
            end,
            onenteractive = function()
                room.combat_timer = 0
                if room.room_type == "combat" then
                    room.skull_timer = SKULL_SPAWN_LOCKED_TIMER
                    room.skull_spawned = false
                end
            end,
            onentercleared = function()
                room.combat_timer = -1
                if room.doors then
                    for _, door in pairs(room.doors) do
                        door.sprite = DOOR_OPEN_TILE
                    end
                end
                if room.room_type == "combat" then
                    room.skull_timer = SKULL_SPAWN_TIMER
                    room.skull_spawned = false
                end
            end,
        }
    })
end

function Room:get_bounds()
    return {
        x1 = self.tiles.x,
        y1 = self.tiles.y,
        x2 = self.tiles.x + self.tiles.w - 1,
        y2 = self.tiles.y + self.tiles.h - 1
    }
end

function Room:get_inner_bounds()
    return {
        x1 = self.tiles.x + 1,
        y1 = self.tiles.y + 1,
        x2 = self.tiles.x + self.tiles.w - 2,
        y2 = self.tiles.y + self.tiles.h - 2
    }
end

function Room:get_center_tile()
    return {
        tx = self.tiles.x + flr(self.tiles.w / 2),
        ty = self.tiles.y + flr(self.tiles.h / 2)
    }
end

function Room:get_door_tile(direction)
    local center = self:get_center_tile()
    local bounds = self:get_bounds()

    if direction == "north" then return {tx = center.tx, ty = bounds.y1} end
    if direction == "south" then return {tx = center.tx, ty = bounds.y2} end
    if direction == "west" then return {tx = bounds.x1, ty = center.ty} end
    if direction == "east" then return {tx = bounds.x2, ty = center.ty} end

    return nil
end

return Room

:: src/world/room_renderer.lua
-- Room Renderer
-- Handles visual rendering of rooms, adjacent room masking, and void coverage
--
-- This module extracts rendering-related functions from play.lua to keep
-- the scene file focused on orchestration.

local DungeonManager = require("src/world/dungeon_manager")

local RoomRenderer = {}

--- Hide blocked doors from map rendering (temporarily clear to 0)
-- @param room The room to process
function RoomRenderer.hide_blocked_doors(room)
    if not room or not room.doors then return end
    for dir, door in pairs(room.doors) do
        if door.sprite == DOOR_BLOCKED_TILE then
            local pos = room:get_door_tile(dir)
            if pos then mset(pos.tx, pos.ty, 0) end
        end
    end
end

--- Restore blocked doors to map for collision detection
-- @param room The room to restore
function RoomRenderer.restore_blocked_doors(room)
    if not room or not room.doors then return end
    for dir, door in pairs(room.doors) do
        if door.sprite == DOOR_BLOCKED_TILE then
            local pos = room:get_door_tile(dir)
            if pos then mset(pos.tx, pos.ty, DOOR_BLOCKED_TILE) end
        end
    end
end

--- Fill adjacent room floors with black to hide them through doors
-- Keeps adjacent room walls visible (autotiled corners, H/V walls)
-- @param room The current room
-- @param excluded_rooms Optional table of rooms to skip (used during transitions)
function RoomRenderer.cover_adjacent_room_floors(room, excluded_rooms)
    if not room or not room.doors then return end

    excluded_rooms = excluded_rooms or {}
    palt(0, false)
    for _, door in pairs(room.doors) do
        local adj_room = DungeonManager.rooms[door.target_gx..","..door.target_gy]
        if adj_room then
            -- Check if this room should be excluded
            local skip = false
            for _, excluded in ipairs(excluded_rooms) do
                if excluded == adj_room then
                    skip = true
                    break
                end
            end

            if not skip then
                -- Cover only the floor (inner bounds), not the walls
                local floor = adj_room:get_inner_bounds()
                rectfill(
                    floor.x1 * GRID_SIZE,
                    floor.y1 * GRID_SIZE,
                    (floor.x2 + 1) * GRID_SIZE - 1,
                    (floor.y2 + 1) * GRID_SIZE - 1,
                    0
                )
            end
        end
    end
    palt()
end

--- Cover everything outside the active rooms with black, then redraw adjacent room walls
-- @param active_rooms Table of rooms that are currently visible (single room or both during transition)
-- @param cam_x Camera X offset
-- @param cam_y Camera Y offset
function RoomRenderer.cover_void_walls(active_rooms, cam_x, cam_y)
    if not active_rooms or #active_rooms == 0 then return end

    -- Calculate combined bounds of all active rooms
    local first_bounds = active_rooms[1]:get_bounds()
    local min_x, min_y = first_bounds.x1, first_bounds.y1
    local max_x, max_y = first_bounds.x2, first_bounds.y2

    for i = 2, #active_rooms do
        local b = active_rooms[i]:get_bounds()
        min_x = min(min_x, b.x1)
        min_y = min(min_y, b.y1)
        max_x = max(max_x, b.x2)
        max_y = max(max_y, b.y2)
    end

    local px1 = min_x * GRID_SIZE
    local py1 = min_y * GRID_SIZE
    local px2 = (max_x + 1) * GRID_SIZE - 1
    local py2 = (max_y + 1) * GRID_SIZE - 1

    -- Screen bounds in world coordinates
    local screen_x1 = cam_x
    local screen_y1 = cam_y
    local screen_x2 = cam_x + SCREEN_WIDTH - 1
    local screen_y2 = cam_y + SCREEN_HEIGHT - 1

    palt(0, false)
    -- Fill all 4 areas outside combined room bounds with black
    -- Left
    if screen_x1 < px1 then
        rectfill(screen_x1, screen_y1, px1 - 1, screen_y2, 0)
    end
    -- Right
    if screen_x2 > px2 then
        rectfill(px2 + 1, screen_y1, screen_x2, screen_y2, 0)
    end
    -- Top (only the part between left and right room edges)
    if screen_y1 < py1 then
        rectfill(max(screen_x1, px1), screen_y1, min(screen_x2, px2), py1 - 1, 0)
    end
    -- Bottom (only the part between left and right room edges)
    if screen_y2 > py2 then
        rectfill(max(screen_x1, px1), py2 + 1, min(screen_x2, px2), screen_y2, 0)
    end
    palt()

    -- Now redraw the wall tiles of visible adjacent rooms (only their perimeter walls)
    RoomRenderer.redraw_adjacent_walls(active_rooms)
end

--- Redraw wall perimeter of neighbor rooms to maintain visual consistency
-- @param active_rooms Table of rooms that are currently visible
function RoomRenderer.redraw_adjacent_walls(active_rooms)
    local checked = {}
    for _, active_room in ipairs(active_rooms) do
        local gx, gy = active_room.grid_x, active_room.grid_y
        for dy = -2, 2 do
            for dx = -2, 2 do
                local neighbor_key = (gx + dx)..","..(gy + dy)
                -- Skip if already checked or is an active room
                if not checked[neighbor_key] then
                    checked[neighbor_key] = true
                    local neighbor = DungeonManager.rooms[neighbor_key]
                    -- Skip if neighbor is one of the active rooms
                    local is_active = false
                    for _, ar in ipairs(active_rooms) do
                        if ar == neighbor then
                            is_active = true
                            break
                        end
                    end

                    if neighbor and not is_active then
                        -- Redraw wall perimeter of this room using map tiles
                        local nb = neighbor:get_bounds()
                        -- Top wall row
                        for tx = nb.x1, nb.x2 do
                            spr(mget(tx, nb.y1), tx * GRID_SIZE, nb.y1 * GRID_SIZE)
                        end
                        -- Bottom wall row
                        for tx = nb.x1, nb.x2 do
                            spr(mget(tx, nb.y2), tx * GRID_SIZE, nb.y2 * GRID_SIZE)
                        end
                        -- Left wall column (excluding corners already drawn)
                        for ty = nb.y1 + 1, nb.y2 - 1 do
                            spr(mget(nb.x1, ty), nb.x1 * GRID_SIZE, ty * GRID_SIZE)
                        end
                        -- Right wall column (excluding corners already drawn)
                        for ty = nb.y1 + 1, nb.y2 - 1 do
                            spr(mget(nb.x2, ty), nb.x2 * GRID_SIZE, ty * GRID_SIZE)
                        end
                    end
                end
            end
        end
    end
end

--- Draw room during a scroll transition (showing both old and new rooms)
-- @param camera_manager The camera manager instance
-- @param cam_x Camera X offset (including shake)
-- @param cam_y Camera Y offset (including shake)
-- @return clip_square The clip bounds for spotlight rendering
function RoomRenderer.draw_scrolling(camera_manager, cam_x, cam_y)
    local clip_square = {x = 0, y = 0, w = SCREEN_WIDTH, h = SCREEN_HEIGHT}
    local old_room = camera_manager.old_room
    local new_room = camera_manager.new_room
    local active_rooms = {old_room, new_room}

    RoomRenderer.hide_blocked_doors(old_room)
    RoomRenderer.hide_blocked_doors(new_room)
    map()

    -- Cover adjacent room floors, excluding both transitioning rooms
    RoomRenderer.cover_adjacent_room_floors(old_room, active_rooms)
    RoomRenderer.cover_adjacent_room_floors(new_room, active_rooms)

    -- Cover void walls, treating both rooms as active
    RoomRenderer.cover_void_walls(active_rooms, cam_x, cam_y)

    RoomRenderer.restore_blocked_doors(old_room)
    RoomRenderer.restore_blocked_doors(new_room)

    return clip_square, old_room, new_room
end

--- Draw room during normal exploration
-- @param current_room The current room to draw
-- @param cam_x Camera X offset (including shake)
-- @param cam_y Camera Y offset (including shake)
-- @return clip_square The clip bounds for spotlight rendering
function RoomRenderer.draw_exploring(current_room, cam_x, cam_y)
    local room_pixels = current_room.pixels
    local clip_square = {
        x = room_pixels.x - cam_x,
        y = room_pixels.y - cam_y,
        w = room_pixels.w,
        h = room_pixels.h
    }
    RoomRenderer.hide_blocked_doors(current_room)
    map()
    RoomRenderer.cover_adjacent_room_floors(current_room)
    RoomRenderer.cover_void_walls({current_room}, cam_x, cam_y)
    RoomRenderer.restore_blocked_doors(current_room)

    return clip_square
end

--- Draw door sprites for a room (both open and blocked)
-- @param room The room to draw doors for
function RoomRenderer.draw_doors(room)
    if not room.doors then return end

    for dir, door in pairs(room.doors) do
        if door.sprite then
            local pos = room:get_door_tile(dir)
            if pos then
                local px = pos.tx * GRID_SIZE
                local py = pos.ty * GRID_SIZE
                spr(door.sprite, px, py)
            end
        end
    end
end

--- Draw all room features (doors) in correct order
-- @param room The room to draw features for
function RoomRenderer.draw_room_features(room)
    RoomRenderer.draw_doors(room)
end

--- Draw debug grid overlay for tile positions
-- @param room The room to draw grid for
function RoomRenderer.draw_debug_grid(room)
    if not room then return end

    local floor = room:get_inner_bounds()

    -- Draw grid lines
    for ty = floor.y1, floor.y2 + 1 do
        local py = ty * GRID_SIZE
        local px1 = floor.x1 * GRID_SIZE
        local px2 = (floor.x2 + 1) * GRID_SIZE
        line(px1, py, px2, py, 8) -- Red horizontal lines
    end

    for tx = floor.x1, floor.x2 + 1 do
        local px = tx * GRID_SIZE
        local py1 = floor.y1 * GRID_SIZE
        local py2 = (floor.y2 + 1) * GRID_SIZE
        line(px, py1, px, py2, 8) -- Red vertical lines
    end
end

return RoomRenderer

:: .info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-04 08:44:13",runtime=24,workspaces={{location="main.lua#7",workspace_index=1},{location="gfx/0.gfx",workspace_index=2},{location="gfx/2_chickens.gfx",workspace_index=2},{location="gfx/1_dung_tiles.gfx",workspace_index=2},{location="gfx/4_tbj2_16x16b.gfx",workspace_index=2},{location="gfx/3_dung_objects.gfx",workspace_index=2},{location="gfx/t.gfx",workspace_index=2},{location="map/0.map",workspace_index=3}}]]
:: gfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-04 08:44:13"]]
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTI1IDE2OjI5OjU3Iixtb2RpZmllZD0iMjAyNi0w
MS0wMyAyMDo1MjoyMiIscmV2aXNpb249MTU3XV1sejQA9CkAAF9uAADzIXtbMF09e2JtcD1weHUA
QyAQEATwVgcQB8AX0BfABxAH8FYsZmxhZ3M9MCxwYW5feAgAx3k9MCx6b29tPTN9LD4A8DkYIATw
EwjwBgcPGAfwBEfwAwEnAfACBwEHCgcBB-ABBwYICQgGB-AAJw4GDifQp7DHoJcGF6AXBmcGF7AH
FgcGBwYHFgfQDxYLAPA2Fg3wAA1GDfACCi0K8AICCSgJAvAAIigi0CIBLgEiwDEuMbAEHxQXLxcX
HxQEoAQcAw8TDQ8PDQMPExwEkAQcAwcBCw8PBgD-IxwEgAQMDxcPDxElEQUPFwwEoBZlFtAWRRbw
AGHwAQFCAfABYvAAgvABHAAc8AMUABSQ8wALHTjzAB8r8wCfD-AAGQ-jAa-vEeBiFOBiHPAAQvAE
FMDvAMsgABHfAa8UYuAcYvACQvAFzwIp8SoXCBfwA0fwAmfwAWfwACcmJ9AnRiewJ2YnoCcmDxY2
F6AXhhewBw4GDiYOBg4H0B4GDgYOBh7wAB4HAJQCCi4K8AISKBLmACAvGOcAHi3nAE8ODw8O5wAJ
MSkRCecAfxVpFdAVSRXGAqUpBQ-YASMVDPAAIA8T8QAWFfAAMisBFdcB-w9bFQbQFisVDwYNFdBR
HfAAATIBBQHwAEIBBQHgYhGzBLhHDwUBDNYCAQ8A-xqgHxdlHdAWNR8FDQ8GHwXAYRrgAUIBGtBy
GvAAHAAcABrwABQAFAAKcP0AHR9D-QBYYA8UIS4hDPsAIW8X8wBhERsPDxsR7AH8AgsVEQURFQsM
BKAbZRvQG0Ub2QIP1wEe8j3sFvAGJvAFJiAW4B8SQCbQHg8VIDbAHh0AHRbQCQQZBA0eHcAJBA4U
DT4NsAkELgQOBB4doAkUPgQeDQ4NoAkEDgRODQ4doCQOBA4NAgAmoBQMAPAKwB4dMR3QIjgiwCIB
PxgBIrAxPDGgBB8Uf90B8AOQBBsXPw8XGwSABBsXDxMHHw8GAFAbBHAEC9UBQA8TAT8FAM8PDw8X
CwSQGn8PGlCyA3vwBC4i0AIPFAcBLxcHAQ8UAsABDBGZA-ACDxMRDAGwBAwHAwsHDw8HGwfNAWEM
BRclFwXAAxGFywHPHxdlFgwEoCZFJtCGWAg28G8uCAAI8AMIEB8Y8AQON7AHBkAnBgEHkAYHBgAX
ECcRBwqABw8WBjcABicGKXAGDQaXGIAmdwYeCIANFmcWDQ6gDRZHFg0GDbAmJxYNBh2wDVYNBh3Q
HQYNBg0GHfAAXfABUhjgEhECARIewBJREh6wkRKwjxQXDxegNE8UBwP9APADoCQvFB8XBwMRDw_g
BD8UHxcfxAHwFh8PsC8UPxdPD9B-Fw8P4HHwACFC8AARUuARcuAPFAQwDATwAAwHAA_aAx4fRvIA
fzkPDwfzADNvFx-zAD7gIWLvAA-hAYfxAA8TAQcOsGEPFAMRDxewb-AAsAcPD6A0PxQPDxcc_QAw
Dxdc9QDOLxdMsC8UXxccC9CL3gFQBQTwAAUHAB9w0AK-II8X8AD-BDFC4CFSBMAxQh8U0AwE8AYM
BNDJArAP6wACsgEUATLgER8UUvAF6gAPxAIeED-qAJAFHxgQCPACNw6TBfEaBidABgeQCgcRJxAX
AAYHBnApBicGADcGDxYHgBiXBg0GgAgeBncmkA7sADGQDQbtANWgHQYNFicmwB0GDVYN6wAfAbQD
6wDvAPABAgWwjxQHFaA0TAcDFaAkLOoAYQEVoAQ8G9IB8gcVsCwbTw8GDdBbFR0VsHEV0CEyARXQ
rwMfDIwFvFEfDwUBHNUB9AUMBRwL0DsVDQY1sDEVHUWgISIFAtwBUAoE8AAKBwAP8wAeH17zAF9B
fxQ-F4MFMBcRHOUA6hw-DwEMsC8UPE8P0GwbtQIPegUnHxPTDUVDDxgIDdUN9AIUIS0hFKAELxQB
LQEsBJAEzNALQQRMBAvPDL8ZCwQsBAsZ0BlLGSQJBA_tDngP2gAFLxSA2gALD50OAw_xAbIhAALY
AF4MctAUDF0QD4oCrJ4C4HIM4GIMFOAkEg9QD3MzDggOVQ4AUw4C4AAfLpACBBEV4ABPFdAVSy0R
MAAUFvAENyWgTxYFgA4vFy4FYA4NHw8dHggA-wYsHQ4FcA4NLA0OBYAeDQwNBbAu8DZcAAsdNlwA
-x82NaAFPxYFgAUuLxcOcAUeHR8PDnAFDh0cDQ6ADg0sDpAODRwNDqAOHQ7AHvAnXgAd-z8DDxZQ
DmAODxcOEBUADQ5ADg0eABUQDw8NDjAOHHAOIA4NHNAVkA6ADtAOBdAVEBVAHmAODRUgDi1ADR4F
MAUuMC4FQCVADgWgDhAF8AN_AB2QJx8WwA4fFw6gNAFRDQ6QDizVABEcOAH-AhwdHgVwDi0uBYAF
PgWgNfA2XgAoIQ4PXwAhHBVfAH8ODRVwHhUNXwAu-xwPwA4ECg6wDgopkBUaCZAFHxcFCRUPFnAF
HxcPFgUdBXANDxcdBR0FgAU9YgAiGDdiAP8DDioJkA46CZAOKhmgKQTABPA5TwAdEThPABAaTgCR
gB4qCYAOSgmATgBP4ATwOE0AHRNInABRkB4aKXBKAI9KCZAEGhmwFEwAH_BFLw_wBCoEoA4KCQoO
oOUAvwk6CZAZGhmgOfA3TQAdz0YvD7AeCh6gDioOkEsAK-MGgAkgGSApIAkKCQAJGgkACSoJAAkK
CABwOhkKGSoJIAwA8A4ZKglACRoJEAkaCWAZMBlgGcAJGgkwGUAJChkAGToAEEAcAEEZKglQOgBA
KgkwCToAMBoJMBwArylAGWAJCgnQCQDpAB3wAzYoEB8XAmAIDgoYAi4CMB4IGggA-w4gLjgCPgIQ
HgIOAhgCPgIgAj4STgIgEm4iUBIeIoMCHvEWkCEACZBBCUChIIEFMQChBSEAERcVcQAhFwUBBVEQ
ITVhECEFAQwA-wMxBQEFYRDRENEgsTCxQJFwUVDQAB3-Ow0G0AcfFrAGBQ4FBpAGHgAVUA4GAA4F
DhVwFQ4VEAWAJXAHFg4lDgVQBwUQJQAVQAYFMBVwBlAOcAZQBXAOBTAVgBUQFaAFDhWQegAc8gFQ
N5B3UDcaVzAXKhcqBwogBwBAGRAXGggAIikACAAxSRcKDwAwChk3BwBQGgkPFCcJAFMqCQ4ABwkA
wBAKCSopOgkOIA4JCggAz0AOKSoZHlAeOR6QPhABHfI8QBcGBxaABlUPFoBekA8ZGR0PFJANGR0M
kAY1BpAGLxwPDA6QBx8cDwwPEA8ckAcLDwwLCg6QByoPEA6QBwoLCggOkAcICgsIDpAGDgDPBggK
GA6gDhgOwB5gjAAc8DLwEy8YIB4CUA4oDgAOBxgCMA4IFy4oHgIgDggXPggeEiAOKH4CIAIOGE4C
DhIwAg4YDgIOAg4SUAIOCB4CDhJwAgYAr5ASDhKwItAC8Bh_ACkSIH0ANEACIAcAMSguQHwAMi5A
AnsAITACeQAgIAJ4AH8QApASDgACeQAi8RxQMpASOBJQEhg_GBIwAggeOR4IAiACCA4ZOhkOCAIQ
AggOCQo3CgkOCAIADAAQVwwAHxIKAAonAgA2ABUQTAATIF4AETBsAG9QEjgSkDIxAh3wKFA4kCga
KFAoGh8WGigwCBoeFx4aCCAYCg4XGhcOChgQCAoOBxoYGgcOCggAGAoOBwo4CgcOCigKAEAPGDgN
DQDACA0JDgcJXQkHDgktCgAQPQoAIB0AFgD-FhkdGQcOCQ0QHQkOFxkXDgkdIA0ZHhceGQ0wLRke
GS1QLRktkD3kAh7xVB4gHoAuCR4IUC4IDioYHiAIDggeCAkKCQguCBBIHggeOCARCB4IDxMIHggB
IAENBwEYDQMNGAcBDRAdIQ0jHRENEA0DEQ0jDxwDLAMNAA3TAAMNAw1DASMBAwANAw1TDCMMAxMA
IKMQBgBTkxAtAw0CAF8dIAGdEK8AHCHwBLAA8BgAHghgHggeCQ4YHjAYHggqCC4IIDgOCQoJDjgg
IS4ILggREAEPEwG0AAAEAKAdAB0BKAEDARgRowByEyEjESMPHJYAEAylAEABIwEjtgBBDCMME5wA
JaMApwBPIyABvRkGHfI_MBgwGHAIHxgQHgiQPpAeOB5gDggfDhgOGA5QDggdCC4IDkAOOG4wDggS
PhIeMA4CET4RAg4wHggBPgEIHjAuCD4ILjACfgIOAjAiDgLJAxBACgCPMmAPFVIM8AQ1AR30KyIY
YBhACC8YIC4IcE6QDh8OKA5gHggdCB4IHjAOSG4QDhi_AC4SXhIeAB4CEV4RAg4AAh4YXhgOAhCA
AJ8iQIJwHxUwHDB7AB3gBD8XDxaADxcvFg8XDxaWCYBgTg8XDh1QbrIZwEAeFC4NDg0eIB4EHuMZ
8AQdDiAeBC4ELh0OIA4EDR4NBC4kCQDgLgQeBA8SDxUPEgQQDgQOADAMLxULAHBeBAwrBBAeIgBA
DCsMBEcA-wINBAwbDAQgBC4kPARAJEwEULIAP3EPEAEdDAEQtABAER0RELMAQx4FHQW0AAQLAFEu
BB41IK8AQB8SFRuuAEEbHxUbrgAxGzoLrADfC0oLEBQeK1oLICuKIKkAPjA_LTCkADE_HTCiAIMP
EAENAAwBAKYAURENABEApwBRLgUNAAVZASA_NacAUC8SFRsApwBBew8VAKcAEQoCAI8aFB4rigAr
qg8DHfA3UGdQpzAXDxYGFwYeFwYHIAcODxIOFg4dDiYHAAcODQENFg0RDQ4WBwAHDRENFjENFg4A
ByEmQQYeAAchDgYHQQceAAcGAV4P8QoHIQcGHhAHDgEOAQ4GJwYHBg4gDgEGAQYHAgAgDjCDDxEW
CwBBQFaQBzIAf6AOBw4H8AhdAR3xHhcJGrAZCgegDxkPGB8ZDxigDgkaCQ4PGVAKBw4JChcKCQ4J
QBoNCjcKDRkwGQgAMxpACRoAQQcKUA0vAAATDq8NoAcKGbAaCfAXgwAdkBkPGZAaAB8YAJ8KgQcO
GQ4JGlAZWADzCwcKQA8ZAA4JGgcKCQ5gDgkKJxoJDlAOCRonEACRBxoJDgANQAoHLwAgGVAFAO8O
BwoJYBkAHgAakA3wGQEIJRMgAQggQA75BxKgBAD-CAKgAjACgAJQAmACcAJAApACIAKwAgAC8Acg
8CtAAh8YApACDhgeEnAOFxgeAmACCBcYLgJQDjg_AlAeGE4CUAJ_AmACXgJwEj4SkDLAHxXQEtAO
AuAOAgAfcG4AGfMHICAEkB8VNV7wBB41XvACFx41XhfwAAcAVRUeNV4VBwBUFxVXNRcHAJMCFxAV
EBUX8AQIAJMAFxURF1A1F7AIALWQFxURNxARMDUXcAoAEFAKAHBQERARNRcwCwAzIBoADQCxETcw
Ch8XChIwERUOAIAgCg0fDw0KAhAAEBArAPAbIgosDQoPGFI1NxURNxIKDRwdDxYPGVI1NxESNx8Y
ChwdHxYPGTgfGBgVEgBAGwotLxAAEBsPAJEbF0sJPxYJK1gMANZbOTtYFTcVOzh7FzsSCQDSFxA3
Hw47mDcSFzA3FggAVBcVF-YEBwBvUPcIcPcI_AUMHzJaAXYWUFgBNRIfD1cBZjACDQQKDVYBYjIP
GA0KKVUBUjINKgkMUQGTHAgNOglIHBgVDQAiKhkNAHEcF1wpBDxYCgAwbARcSAFmPDh8FzwSCQAB
SAESPEgBEhsIAFQXFRf7BAcAD0gBh0MAPxEgSQEgAB2AAyQdAE4Bcw0CDBgcEg1SAZMQDQwXGBwC
DRBVASAADZ0DRCwCDQBXAYECDQw4PAINIlgBUQINHBhMDQCkERI3DA0CfAINCFsBYw0CXAINGFwB
YjwNEjwSDV4BUkwdMh0MYAFULA0eDQxkAVYsDRINDGgBYygNDAINKG0BMjgNDAwAbxcVF3sti3IB
KADqBNESFwpQChcwFxowGhcwKxD-BkAKCVAJCvA2CgnAKgmwFxqwFwrwG1cAGQCBFT----KKAB0f
8DEACx05MQCnAdcPFgDXDgDXBgMAkQ4ALoYeBQDXBRoAFwUDAATIBx8xYAAVgQDnDxbnDucGAgBA
DucO5gIA0gUORg4VThVmBWYFZg4CAB-wWgAfhSYPFqcOJwanXgAADABQJw6mDiYEAKAFphUeBQ4G
LkYOZAACaAAfBWgAIvAI9z8Glw8WBtcGR6Yn9hIFPhUOBQ42DgXEF58ulg4GPmZ_BWZXACBaDxbX
AAYDAKsO1wAFDqYeAAXXAwAfEHkBH4IBNw8WhxA3BgQAMtcQ1wwAyA6HEA4mDkYOBh4Q1wIAD2AA
HyjXEAIAEdYCAKIPFjY_Jh4QVg5mBABfBQ5W8AFaABzxJwDfFgAulU61PgWfFQUeFR1-FB01DRwV
BAUEBRwNNQ0MFTQVDA0VHg0MBQQFNAUMDR4FDg0MFAsAMAUOFQsAMiQFBCIAACEAEwQiAHMEBRQK
CQoEJQBDJAUcCSUAZSQFBAUMBSYANAQFJEoAIEUEagAPvwAd8hnXEKcGFxCXBicQhwY3EIcPFjcQ
ZwYORxBXBmcQ1xAOph4Qpw4XEJcOIAAxdwZHQAE-RwZ3gwEdQO8WAe4CABMFBgAKAgA-IbURDAQc
gAUvFgUBjgFOBABABY4B7gYAEgVeAP8P3gUBzhUBvgUeAa4FLgXuAY4FTgF_AQU_BRFFQRUhaAAc
N2V-FrEAkP4gAf4ABf4RBQYAbwsFbiUBBVEAHToA1xACAIE-FnYeEBYOpwQAEBcEABIGCAAP6QIg
AV0AeccPFhC3DgbaAfACdw5HEGYOBjcGEGYOVhBmBVZZAxAFGASBHhBGBXYQRg4EAA8AAx5gDxYF
HxJPBQAyPxYFww40DxY1CQAhJR8JAPEJBU4PFQ4FLh0uTS4tTxYFHkwFHgw1Dg0OBQAhBU4EAIAe
TS5NPlweTNgCAhwAJx4NGwARLDYAJBwlNgAxDAU_HAB-DhU9Lk0uDbYAQlEeDxUeDbgAMh0BHboA
EBxjGwG9APAUHBUNBQ4NFS4NDgEMBR4NHg0FDi0RDB4dAR0FLiwNHB4cDRzLADEVDA2uAAC9AxAF
CxDxCQ4FDgEuDR4tAQ0uDQEtLAUeDA0cDQUMDtsARRwFDQXdAABVAADfAAB9AA-hAB0SAEcFAEoC
cQcPFrcQDsdrAk-XEB6WSwUs1G8WAS4BLgFuBS4FLgUGAAQCAAEOAPEAAS4FLkUBBSEVAQURBR4F
LQDpHgU_AW4lTgVuBQFeBW4CAC8RhUQDH-ATbxYBHkUBbgEeBQE1bgEVAUVuASUeJW4RFT4FbgEV
HgUeAQcAYSUBVZFuAQIAHwUCAAAv9QF2ABwAJB36CQF_BU4BjgU_BZ4F7gUeBb4VAc4FAd4F7gIA
PxHFERYELV8fFgYOdvcGLQRhCR8zMQAUXv8W4PUAugAPZQATHzTrACcPlQItL_UBAgAIH-HoAR4g
Hxa4AjJlAS4HANAeBQElAWUBBS4BlQE_CgAgLrV-AvAGZRFFITUhZQFlAeUBpR4FEZUuFQGVfAKv
HoUBLgEedQEFLnsAHjBlARVlAmB1DgVOAXU1A-EAhR4BLgFlATUBHgF1DhUujwCxFS4RRSFFEW4B
ZQEEABR1AwCfAWUBXgUBZfEBfQIjATgGQgYHENc2Bn8OJwYQHkY_fAktA10AM2cGVwYAAQQAMg8W
V4oGA44GPwUeBo8GMQWNAh8wMQBFAM8ADIUMEA4DABLWAwBABQAONscLQQBWDmYFAD8OAFbKCyMA
jAyCBucmdwYHFh4zDA_PDDgP6QwB-wIOFR4mLgYOBR4F5gXmDnYOVlkAIZD3YPYgBR8WJi77AACv
AC928DICHw9vDAQgDtYDALEF1gAlHhYuJh4ABRAALw5muAsgSe8WBe4CAGHwATcGDndzDDEnBpeA
CSIGDjkHHwBUAh0QgWsrD0wABA_gAk1I4AHnAAIAEeYCACAPFjUC0AUAZgU2DhYAZg5mAGbfAQ82
AR8vAO4CAAge5d4AD4gCIQCHAi82HgkPLAHyDZEPFscQBwa3ENeIAQCQAeBHDlYeEDcedxAXFpcQ
HhoAD1EOKgozBdceFkcONxA3Nh43EJcWNwUOXgAP9QEVDzEA2VQBLxY2Z1QFALsCA-sDIWdmwwKy
BQ4VDkUuFQBmBWbBAi8FZloEJRQOUQQUBgkAVi6mDgAOwhAADAAfDrkBIA8dBgZRHgYOdi4MAAWd
EgEYAA8bAh9BALcGFwQAMacGJwQA9hCXBjcAlw8WNwCXDhYXAOYAlg42AJYFNgAVHkUOBS4FMAEu
DmbwAw-2AXA4lwYnMwGglwYXBg4Alw4GFwwAbycGAKYXBloHPRG3WgcEAgAwDie2dgSSBSYFHhYe
BT4FegQf5loHJYFnDxZnAGcGZ8MCEecKAAEEADF2AOaIAQG-Bw_XASsSAFgEkQ8WFicWDgYXFpgR
BQQAYg5HEHYORgQAnwVGEA42LgUeBucSLQJyAMeXFh8WEB4WhwYQBrcEACdnVl4AQB4mHhByFA5u
AA93AiAPzwSpAU0TAHwRADoBIocGDACxhw43EB4GDkYOJg4YAA8kBokD5AYEAgCPDxYGB0YnBh64
AFnwERgYBPByLxXwBQ4fFi7wAR49DuAeFg8NBR0ewA5GDRUdeStBRg0FFp4sUBYdDAAmhCvwDwUM
DSYFAA0WDQ6wDSYFIC3wBR3gPvAEDiYO8AMODAYAXgwtDvByugAPYy4I8QoYBPBzLxXwBA4NHxYO
4D48HsAOBRwOHA0VewBhHAUNJgUc-yvwA1YcBQ5wDiwNZgUNBYAOHAYNhhEsYAV2DBYOkKoA-xEm
DBUsDqAMBgwNDCYNLA6wDhw2DQ7gDhwmDA0O8AINLJgAGwGoAQJqBAB6BjLHDgYdBkEOJwCWRAUB
OwdUHiYuRg5vBA46Bw9lABACOgdhHtcOBtcWAgDwBQYO1x7WHtYOBdY1HhYeRg4V1gUOEAAPWgAe
AhsZYwAnBqcA5wIAAAwAISe2uwAPLgUfDyABBgoSCwGkDA8VATQTFgIAcB7XLpYOBi4nAY4F1wUO
1x7XHuQHDxIBKTEmDqYEAF9eFR42DhUBJwDNAvEFWi8V8AAuAA4vFj6wDh0OLR8NBR3QIfAMHAUm
LQ6QDhUmBSYFHQ6QDgw2DTYcDoAOBg2GBwCxZg0mBQ6QDhYNNgxsA-8sDQYMJg0FPQUOgA4dDC0M
BS0FDA0OcA4dBQ0MJhwNJg6ABQ0FDDYFDSYNDrAOJgwFLQzQDi0M8AQt8FyzAB3xBFwvFfADHiYO
8AEORg0OwD4mDxa0AGANHA0MNgWdAEAdHGYcfgBALQVmLYUA8AYVZgUdDoAeBRwmDB0FDqAOFhwN
DCbQMCA2DXwDcYAOLBYFLA3nMPEATAUsLqAOHA0cDiAOHA7ACACfLA7wBAUcDvBVwQEdVQGnDxYn
ogkAwQEBDABiDicApg4mxgFwBWYOJgAFHjEVCckBDy0CHwuDAnA_Bg6GDgUOgAIChgIDAwAPiAIh
AlgKIQY3wwABaQoABAAiDjdlCgNpCiAORjMQD2oKGx84FwYdHziSCAIA1g0BBABxDxaXECYOlgQA
EdYGAADBGgEEAE4OZxBWjQgPmgBFAKgC8BeKTxXwAg5EDvAADhQuFA7gDgQPFC4NBA7QHhQuFB6w
Lg0EKQQNLmwDIE0OwAIwLUQtegNGFCkUHQgA8wIeDWQNHrAOHUQdDtAeTR7wb4YAHzWGABX3DYlv
FfAADmQO0A4UTxQUDrAOFG4UDqAOBA1uDQQIAAEWAFAeFE0UHsQyQRQpFA7RBh9kgwAJDzoBQgDU
AQQfFD-XENctFAAPuxoVD58ARQUxAB8xMQBzAOYBclbPFaAOpA4EAIEUDh8UDh0OFAsAAgIAQaAO
FA0CAAkKAAQxABCt6wERbnYCAwIABpYCAhgAT60O8G16Ah0YbpQAAAQAZx8UBD0UHREABHwARa0O
oM4KAA9sAB5zEBAEJQGlAQQAwDEAAQUBAAElERBlAJUXf2UAZQBl8IHkARwmpQFTAMAAMaBVIBEl
AQBVAHUEALFwASURMAEAMVARIAYAL-BQXQAc4BUgVSAFAQUAFABVABQACQDwCXAUABEAHxQPFV8U
DxUfFBAFAB4PFV4NHh0Aah4AEQAhAAsAlRAecB4wHg1eDQYAEnAEAIMdcB0wHQBdAAYAL-ACmwAc
oV8WJRE_AV4BBW5THwDgGsEuBa4BHgG_AQUBziXlGk4B3hXesR8PYgAVoT8WESVeAW4BBV6RH-IJ
ngU_Ba4FLgG_AR4BzgEVziXeFd4BBd4BICAfAWEAINAlDxYFHhURPgEVDgEeyQCbFQEVAY4BBR4V
zACwEd4RzhEFvgUOAe6DABAFiwCvjgEFLgUhRTEVIXYAHCDwESweYh8WDxJPFggA8QAPFQAOBRQF
BC8WBAUUBQ4NADIUDRQMADA1RDUGAPILBCUENQ4AXgkaXgABTxIJCglMAQAODDUsNQwwACYEJTwA
TgQNBA1KAA8aAAcf7sIAHPEEDxLfDx8SDw8JDnkOCQ4fEikECQIAgDkNDxUJBAlkDAD-MRxUHVQc
TQ8ZEQtNDAs5CzFJWwkxCUs8DQkLERkNTD0LMQk9DA1EMUQdBDk0OQQdNFk0DQw9BDkEPSw9ND1c
fTxVAR0f8LcDKAAwNgEMBAoKBLEDEQBBIBEQgRAxAAoATwAB8EBmABz2ACUgJSAlARUAFAAlABQA
FQoAESHEA-AJMB8UMBUAPgABAB4AIRUAThEeDxUhFQAezwOBDR4AERANHkADAKEwHR4NMB4NIB4N
CAAwEC4AygMwIB4QGwACzQM-IC1wxQMfBGQjgBXeEd4R3iXOnR4wHgG_-gIAsh4B2gMA4wNuBV4V
EQU_YgMPYAAVEAUMBMcR3gEFziXOARW_AR5HAwLkH88BPgURFU4FUUURBSFlABwAfh0wDkUBex2A
TgElHgUuAR4zIaABXgE1TgUeBR4l3B-wAQEFIY4BFSEFjjUBFY4FLhXVAOA_BR4xBQElLhUuERUe
BdADMD4BFQUAUE4BFR4B3QTfJQE_BV4VIS4FIXURFf0AGpEgEAQA-w8OAA8oAyT5CCkDlxQJFAkk
CTQJFDEDIfQHMgPwIdQd1BzdBwrdDA8ZSQtJCxkKKQtJC0n7ABnrPB1Mm0wdTF38Al0MDVT9AlQd
BDn0BDcDIfkGOAMg_QQ5A6-0BD0cACz9CCwAqgAc8hrwsA8ZSQ5JDhkKKQ5JDkn_ABnuPxUfEk8V
nk0fEk1c-QJcDQxU-AJUHHcAEBx3ADAMDTx3AN88LTz0BDwdAC38CC0AuQEcdCABpQEAFAAFACQf
FJEH8QAgHgAlAGUBAB8VACUBZRAOADAQHtACAFId0BTQFAoAH8DzAx4lBSBxAJAQMXAfFABVIBEs
BzBVAEVsAAAHAIAecAElAQAeELAHEB62BxlAdAAP4wAdIPANOwAQHz4AQx8V0B4CAA9RAChQXxYF
AQV5BxAReAdADgFuAYAWF26wBgBQA8IRFQ4VAQU_FRFeBW6GBwDBIhHuBgB-bgFuIUUBVY4HLDE_
BU76FjAOAV5xAxAVXCMQAaskMAV_AUIqcAGOEQUuBX6IO0CuAR4RUQcBOAAR7iUAAN0lUwUOFREF
CgBPJUGVEfYDIACSACBOFZMA8A4eBR5FTgGlPsUuAbUBHgG1EcUB1QHVATUB5QF1ARchgFUBfgFl
fgE17SOfPgUhBSElASUhZQZNDzEAHiIAHxcCBS4CFB0CACDwDgUAHg1QAA-uCitQUxRwFDAEAAdT
Cg9kABwv8MJEAC8CeSPB9Q8R1RH1EAH1AAG1EQC-RQGFAVUBdQF1EUV8Bh9DbxYFbn4GcG4FXgUB
bgU0A4xeARVOBQEFPogGYW4FDgFOAYoGLwUuiwYmAYwjYAUeJREFXn8DAXEmABwD0AUeVV4BdQFO
hREFLgG-Jv8Q1T51AW5lAW6FHuUehQElLnUBNR4RNREeVVEVHgURBZoCfP8GCgoEsF8ZIG4gHnAe
0B5wHiBuIF6wQQAc46BPGUB_QE4QHgAeQB4ABgA-QB5QSQAfwn8ZEC4QLrAuEC4QfgIAH6DNACAC
OwBTDhAeEA4GAD9_MD5TBhr-BwsLBHAPGXAeYC5QbiCOAP4cAI4gbhBCABz-CUAPGYAuYE5AbiCO
EI4QjiBuQE5gLoAOQEcAHP8B8BI-GTB_ID4QjhDOUD7wDA8CHg_9MT4fODMA_V8ICATwMDEASvFV
GCAEsBHwBBEdAeBBHQUhsAEtAQUNBREdAZABPQElAT0BcAE9AQghCAE9AWABBS0BAigCAS0FAWAB
JR0BIgEdJQFwAUUhRQGAAaUBoOFwAQUBAwEDCiMKAwEDAQUBUAEFHRELAwIAUBEFHQEwXABwDQUN
AUsBFQcA8QswMQUNAQVBNQ0hIAEjIYUREwEgARsDMVUhIwkA8A4BBZEFITABIwEVIQoZESUBUDEl
QS0FDQFwAWUBDXQA-wJFARVBoAFFIS0BsLHwAkHwnvoAHCfwLPsAI4Ax_wBDMTABG-0AZRsBEAEL
AwIBZwMLAQABEwcBVRMBABEDCwGTEwEQMUUhRTEgPAfzBiABNaE1ATABJREDGgMaAxElAUARFQwA
QBURUBFuRBBL6gggEXDCLEEBCwILCAChgBEFgQURgAElEfcA-weAATVBNQGAAcUBkAGlAbABhQHQ
gfC46wAd8BImLUAtsA0nDSANJw2gDQIXDSANFwINoA0SBw0gDQcSDbAUABAAFADxBsANEgctBxIN
0A0CRwIN0A0GZwYNwPBO8BuwHRYIJwgWHZANFw0WBwIHFg0WDXANJwYNRg0BJg1gDRcGDQFNEQ0W
DVALAHAxJiEdYA0mCAAQgBhP-yoNISYxkC0WESYRLaANJgEmHScNkA0WDTYNBwYCBg2QDSY9FiIN
oA0mDRANBiINsC0gDRYCBg3wAz3YAR8fVu0ADDVgLRDvAJMQLRANBw0HDQD3ABMADgBBFgcNEAIB
QhANBxYQABEADAEQABAA8QQQDRYHHQYYJxgGHQcWDSANJgcNDgCDDQcmDTANJgEgAfAJASYNUB0G
EQ1GDREGHYANIQ0GAQYNIQ2wvEzwAw0GISYhBg2gDaYNoA0WDUYNFv4A-wBNJg2wDSYNAA0mDdAt
IC3pAR9QcHHwAVEOA-E2A0XwAKGwwdBtsA0wDQYIBggGDbAFHRANRg2wJT0mDcAFEAUNFk2gFRAN
B1YVkAUgDRcBJgclDWA1AA0XBkcNFQ0GMAUAFwCiNwYNEAUNUAUgDSA_wRYdEA1gBRAdFgEmDRsA
UXANBwZdMQHQcA0XZgcGDRAtUA2HBjIBAAIAEEA4AWMHBg0gDXBCAAIOAI_AHWYd4G3wQeMAHfAa
iHGgBUBRMAVQBVBBUAUgBQAFUEVQBTA1AKEANTAFEMEQBUAVMG0wFVDvAPAgGAYYDRAdBWAlLRgG
GC0lkAUtBgIGLQXAHRY9Bh3ADRcWARYXDcANhw3ADQYnASfsAgOiAFAHBg3AHakCkrANBwZtBgcN
oN0AEaDbABOg1QAZsC8AD9EAH2AICASQLTAxAxIgBQBvJg0wLfADvSAZAEMA-wA3IFcQVxBHBhAG
JxYgNpA-ABz-BxAnMFcQNwAHAHcGAEcGACc2AFYgFjBFAB3gF0AnBgAHEAYXBkAWABcKAEAnBhAX
HSB-FwYAFiAGQFEAHcAHUBcGUAbwAAcQF0BGAF8QBwYQB0cAHq_QB-ATB2AGEAdQOQAZ8CkQEARQ
QYARRBFQAQQBCQspITARBAkEAxsECRQBIAEEKRMLKQQBEAEUGQQJEwQZFAEAASQBSQEkAWlXQBQp
FAESAFEEAYQBBAgAYAQKRAoEATEA8AcECgQKJAoECgQBIAGkATABCmQKAVAREQBvChGAQfAFpAAc
4PA1UWAhVCEgARQBWQEUYABQCSspBBl2APAXFAkjKxQJFBEUARkzGQEUEQQBFFkUAQQhBAoUORQK
BBEAARQKVAo0AP8ACpQKASARGgQaBBoRUHEwJwEgsDQhUAEUARkBJAEwEwFBCxkUCiYBQRspBAom
ATELEykcASMZIwgAMgMJBAoAIAkE4BIRCrIAURE5ARQKJgEyAUQBJAEACgDPJAEwEUQBFAFQETQh
JAErMEkBFJAAgAQZBCsEGQQKdACBKQsTKQQKBBEJAPMCJBEUGQQTCQQZJBEkAQkTGQGZADEBVAHJ
AEAEAXQBLAEedCgBD08CWQAIADMQAaRDAl_EAVARRD0CVL80OTQRAAG0ARABtAcBIQCPA-8AChAK
QBowWjAaQAoQCvACPwAc74AJMAnwAQlQCZAJEAmQPQAhTwgJ8Ag4AB4v8A02AA8PLg8eDzEA----
-7dQbT04fX0=
:: gfx/1_dung_tiles.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTI1IDEzOjM0OjQxIixtb2RpZmllZD0iMjAyNS0x
Mi0yNSAxNTowMjozNCIscmV2aXNpb249MTNdXWx6NAAPDAAAd0EAAPcPe1swXT17Ym1wPXB4dQBD
IBAQBPAB1w8WANcOANcGAwCRDgAuhh4FANcFGgAXBQMA8wAALGZsYWdzPTAscGFuX3gIAMt5PTAs
em9vbT04fSxgAIEA5w8W5w7nBgIAQA7nDuYCANIFDkYOFU4VZgVmBWYOAgAf8FoAH4UmDxanDicG
p14AAAwAUCcOpg4mBACgBaYVHgUOBi5GDmQAAmgAHwVoACL-Ffc-BpcPFgbXBkemJ-YSBT4VDgUO
Ng4FDiYOBi6WDgY_Zn4FZlcAIFoPFtcABgMAqw7XAAUOph4ABdcDAB8QeQEfggE3DxaHEDcGBAAy
1xDXDADIDocQDiYORg4GHhDXAgAPYAAfKNcQAgAR1gIAog8WNj4mHhBWDmYEAF8FDlbwAVoAHR-w
MQAc8hoA1xCnBhcQlwYnEIcGNxCHDxY3EGcGDkcQVwZnENcQDqYeEKcOFxCXDiAAMXcGR7IAP0cG
d-UAHUDvFgHuAgATBQYACgIAPyG1EVAAHIAFLxYFAY4BTgQAQAWOAe4GABIFXgD-D94FAc4VAb4F
HgGuBS4F7gGOBU4BfgEFPgURRUEVIWgAHDdlfxaxAJD_IAH_AAX_EQUGAH8LBW4lAQUhcwEfCgIA
gT8Wdh4QFg6nBAAQFwQAEgYIAA5bAg9dABN5xw8WELcOBtoB8AJ3DkcQZg4GNwYQZg5WEGYFVssC
EAWKA4EeEEYFdhBGDgQAD3ICTw_jAh8ChAMAFQFxBw8WtxAOxzYBT9cQHpaIAyzUbxYBLgEuAW4F
LgUuBQYABAIAAQ4A8QABLgUuRQEFIRUBBREFHgUtAOkeBT4BbiVOBW4FAV4FbgIALxGFDwIf8BNv
FgEeRQFuAR4FATVuARUBRW4BJR4lbhEVPgVuARUeBR4BBwBhJQFVkW4BAgAfBQIAAB-1twEd_g0F
PxYFAX4FTgGOBT4FngXuBR4FvhUBzgUB3gXuAgA-EcUR4QItXh8WBg52NAUPNwJLT_8WBe4CAAoP
gQBNDwcBAA_xAi0v5QECAAgf8QQCHiAfFtQCMmUBLgcA0B4FASUBZQEFLgGVAT4KACAutZsC8AZl
EUUhNSFlAWUB5QGlHgURlS4VAZWYAq8ehQEuAR51AQUuewAeMGUBFYECYHUOBU4BdVED8QCFHgEu
AWUBNQEeAXUOFS6PALEVLhFFIUURbgFlAQQAFHUDAJ8BZQFeBQFl8QGSASMBHwVCBgcQ1x0Ffw4n
BhAeRj7VBy0DXQAzZwZXBgABBAAyDxZXcQUDdQU-BR4GdgWULdcQ3goQDgMAEtYDAEAFAA42IApB
AFYOZgUAPw4AViMKIwDlCoIG5yZ3BgcWHowKD_gKOA9CCwH-Ag4VHiYuBg4FHgXmBeYOdg5WWQAh
kPdg9iAFHxYmLvsAAK8AL3bwMgIfD8gKBCAO1gMAsQXWACUeFi4mHgAFEAAuDmYRCg8GBR9h8AE3
Bg53zAoxJwaXZwgiBg5VBw8FAR5fgTcGDxZMAAQPoAJNSOAB5wACABHmAgAgDxY1AtAFAGYFNg4W
AGYOZgBm3wEPNgEfLwDuAgAIH_WIAjMAhwIgNh7eAgLiAg4-Aw9LDBWRDxbHEAcGtxDXiAEAkAHg
Rw5WHhA3HncQFxaXEB4aAA_qDCoKMwXXHhZHDjcQNzYeNxCXFjcFD-UBHw8xAOFUAS8WNmdUBQC7
AgP7AyFnZsMCsgUOFQ5FLhUAZgVmwQIvBWZaBCUUDlEEFAYJAFYupg4ADhsPAAwAHw65ASAPHQYG
UR4GDnYuDAAF9hABGAAPGwIfQQC3BhcEADGnBicEAPYQlwY3AJcPFjcAlw4WFwDmAJYONgCWBTYA
FR5FDgUuBTABTw5m8AH2AYA4lwYnMwGglwYXBg4Alw4GFwwAbycGAKYXBloHPRG3WgcEAgAwDie2
dgSSBSYFHhYeBT4FegQf5loHJYFnDxZnAGcGZ8MCEecKAAEEADF2AOaIAQG-Bw_XASsSAFgEkQ8W
FicWDgYXFn8QBQQAYg5HEHYORgQAnwVGEA42LgUeBkARLANyAMeXFh8WEB4WhwYQBrcEACdnVl4A
QB4mHhDLEg9uACgv8PAxALARATQSAGMQADoBIocGDACxhw43EB4GDkYOJg4YAA8kBokD5AYEAgCP
DxYGB0YnBh64AI4PMQAeAzMJALsFMscOBl4FQQ4nAJaFBAF8BlQeJi5GDrADD3sGKGEe1w4G1xYC
APAFBg7XHtYe1g4F1jUeFh5GDhXWBQ4QAA_1FiRjACcGpwDnAgAADAAhJ7a7AA9vBDAEIAEKUwoB
5QsPFQE0ExYCAHAe1y6WDgYuJwGOBdcFDtce1x4lBw8SASkxJg6mBABeXhUeNg4VAQ_XAnxFpw8W
J_gHAMYAAQwAYg4nAKYOJssAcAVmDiYABR6TEwnOAA_JAR0c8IgBcD4GDoYOBQ6FAQKLAQMDAA_N
ASECngghBjfDAAGvCAAEACION6sIA68IIA5GeQ4PsAhdIwDXHAwBBABxDxaXECYOlgQAEdYGAADu
FwEEAE8OZxBW0wbtFAC_EQH5BQ7MEQ9BFz0PMQD-EkMlAaUBBADAMQABBQEAASUREGUAlhR-ZQBl
AGXwgVEAHCalAVMAwAAxoFUgESUBAFUAdQQAsXABJREwAQAxUBEgBgAv8FBdABzgFSBVIAUBBQAU
AFUAFAAJAPAJcBQAEQAfFA8VXxQPFR8UEAUAHg8VXg0eHQBqHgARACEACwCVEB5wHjAeDV4NBgAS
cAQAgx1wHTAdAF0ABgAv8AKbAByhXxYlET4BXgEFbjsbAP0XwS4FrgEeAb4BBQHOJQIYTwHeFd6Z
GyehPxYRJV4BbgEFXnkb8gmeBT4FrgUuAb4BHgHOARXOJd4V3gEF3gEIHB8BYQAg0CUPFgUeFRE_
ARUOAR7JAJsVARUBjgEFHhXMALAR3hHOEQW_BQ4B7oMAEAWLAK_OAQUuBSFFMRUh5AJ_L-DwxAIo
QRAhBQEZAwoXA7EDEQBBIBEQgRAxAAoATwAB8EBmABz2ACUgJSAlARUAFAAlABQAFQoAESHRAvAJ
MB8UMBUAPgABAB4AIRUAThEeDxUhFQAe3AKBDR4AERANHkADAKEwHR4NMB4NIB4NCAAwEC4A1wIw
IB4QGwAC2gI-IC1w0gIfBFkegBXeEd4R3iXOxxowHgG_CwIA3BoB5wIA8AJuBV4VEQU_bwIPYAAV
EAUZA8cR3gEFziXOARW_AR5UAgIOHM8BPgURFU4FUUURBSGMGSAwDkUBiRnwB04BJR4FLgEeBQ4B
LgFeATVOBR4FHiUGHPABAQUhjgEVIQWONQEVjgUuFdUA4D4FHjEFASUuFS4RFR4F3QIwPgEVBQBQ
TgEVHgHqA_8lAT4FXhUhLgUhdREVEcUCfnQgAaUBABQABQAkHxTfBfEAIB4AJQBlAQAfFQAlAWUQ
DgAwEB7QAgBSHdAU0BQKAB-ANAMeJQUgcQCQEDFwHxQAVSARegUwVQBFbAAABwCAHnABJQEAHhD_
BRAeBAYZQHQADxsKHhANOwAQHz4AQx8V0B4CAA9RAChQXxYFAQXHBRARxgVADgFuAc8RF27_BACR
ApARFQ4VAQU_FRGnHgHUBQAsHhHuBgB-bgFuIUUBVdwFLDE_BU5JEjAOAV6yAhAVxx6AAQ4FDgEF
fgHqI6ABjhEFLgV_AQUBmQAQEZ8FATgAEe4lABAVuBNDDhURBQoATyVBlRE3AyAAkgAgThWTAPAO
HgUeRU4BpT7FLgG1AR4BtRHFAdUB1QE1AeUBdQFmHIBVAX4BZX4BNVgfjz4FIQUhJQElCAZ-IgAf
FwIFLgIUHQIAIPAOBQAfDTwJPVBTFHAUMAQAB6EID2QAHC-wwkQALwLIHsH1DxHVEfUQAfUAAbUR
AL9FAYUBVQF1AXURRb0FH0NvFgVuvwVwbgVeBQFuBTQDjF4BFU4FAQU_yQVhbgUOAU4BywUvBS7M
BSYB2x5gBR4lEQVefwMB3CEAHAPQBR5VXgF1AU6FEQUuASoi-xDVPnUBbmUBboUe5R6FASUudQE1
HhE1ER5VURUeBREFmgIfDzEA--------------------------------0lBtPTh9fQ==
:: gfx/2_chickens.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTI1IDE1OjA3OjUyIixtb2RpZmllZD0iMjAyNS0x
Mi0yOSAxMzo0MToyNCIscmV2aXNpb249M11dbHo0AOIEAAAoNwAA83Z7WzBdPXtibXA9cHh1AEMg
EBAEMAgACMAfGBAIkDcOkAcBBidABgcQCgcRJxAXAAYHBikGJwYANwYPFgcAGJcGDQYACB4GdyYQ
Dg0WZxYNEA0GDRZHFg0gHQYNFicmQB0GDVYNUB0GDQYNBh2AXZAJIAmgCiAKQCxmbGFncz0wLHBh
bl94CADPeT0wLHpvb209OH0skwAMEICQAEFABgcAjgAQJ5gAAI4AAJUA8gMIHgYHBmcNBhAODSZn
FhAdNkeXALCGDTANBg1mDTAKAI4A3w0mDVAKCW0J4AngCiCPADIQcIwAACwBIRiHkAAAGAEAkgAA
GwExdw0GGwEBkQAgNzYMABKWjwARUI0ArwYZDXA9Ch2gCXCLABzwOWAIAAhwCQoAFw8YCCAHUAkH
ARceCDAHAAkABxEnDhAXMAlnAAcmIAgGRyYXIAgeBicWDxYXFhAeDQYXCgYNJgdAHRYHChYnQIQA
oAoJFwYHBhcACQCxAf8ICScmBxAKCU0JNg0gCRBdFh1wXWAN8AugAB7wLdAHDxgHsEegAScBkAcB
BwoHAQeABwYICQgGB3AnDgYOJ1CnMMcglwYXIBcGZwYXMAcWBwYHBgcWB1APFgsA-wAWDXANRg2Q
Ci0KoAkgCVCAACTwJBcIF6BHkGeAZ3AnJidQJ0YnMCdmJyAnJg8WNhcgF4YXMAcOBg4mDgYOB1Ae
Bg4GDgYecAgATx6QCi54ACIfgPgACSBgN-gAMECXBgMAcocWQAZnJkD2ADQGCgb3ABEJ9wBPPbAJ
kHsAHBtw8wAwJkdg2AH-EUdABxYnBjdARldAFg8WJkdAZicGQA6GYA5WCYBekA7gaAAe-x7wYx8W
wA4fFw6gDg0fDw0OkA4sDQ6ADg0cHQ4FcA4cHR4FcA4tLgWABT4FoDVdACkhDg9eACEcFV4Afw4N
FXAeFQ1eAC3-HA-ADgQKDrAOCimQFRoJkAUfFwUJFQ8WcAUfFw8WBR0FcA0PFx0FHQWABT1hACEY
c2EA-wIOKgmQDjoJkA4qGaApBMAEwE4AHRF0TgAQGk0AkYAeKgmADkoJgE0AP_AEsEwAHROEmgBR
kB4aKXBJAI9KCZAEGhmwFEsAHuCBLw_wBCoEoA4KCQoOoOIArwk6CZAZGhmgOaBMAB3Pgi8PsB4K
HqAOKg6QSgAr8AJ1KRAXBmAJBwoZBicGMBcJGggAcCAnOQY3BhAJA-8EGQY3BiAGNxZHBiAWZyZQ
FhcmYGMAHfI7FhbQJsAmIBZgHxJAJlAeDxUgNkAeHQAdFlAJBBkEDR4dQAkEDhQNPg0wCQQuBA4E
Hh0gCRQ_BB4NDg0gCQQOBE4NDh0gJA4EDg0CACYgFAwAX0AeHTEdIQcd-yDwVhbQDxYGDrA_kB8S
BA2QDSQNDxWADSQdDIAkDQQcgBQNBAwNDIAEHQwNHJANPM8CHvAHAw8WUA5gDg8XDhAVAA0OQA4N
HgAVEJgD-yUwDhxwDiAODRzQFZAOgA7QDgXQFRAVQB5gDg0VIA4tQA0eBTAFLjAuBUAlQA4FoA4Q
BfADfgAZW0BABPD-AQAfAEEACy8xMEIA---SAJYDH-B0AC8PhAL--08fODEA----------------
-------------------------------------9dQbT04fX0=
:: gfx/32x32.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTI2IDIwOjI5OjE5Iixtb2RpZmllZD0iMjAyNS0x
Mi0yNiAyMDoyOToxOSIscmV2aXNpb249MF1dbHo0ADkhAACtdgAA8Ax7WzBdPXtibXA9cHh1AEMg
ICAE8P99FzAX8AgFAEQKN-AMAwAVChYA8wH-fSxmbGFncz0wLHBhbl94CADKeT0wLHpvb209NH0s
UwDwE3AyeDLwADJ4MtBSeFKwUnhSkFIRfxgRUnBSEX4RUnBxfnEEAOBQFD8UN38XNz8UFDAUPQoA
ED0JAMITHxMfFj8PHxYTHxMRABMcEADAHD0UEBQ9ExcRHD8PBgAhPTQNABI7DADTHR8XGzF7MRsa
HTQdGgoAcBQwOvsAOnAFANCQOrs6sDq7OtDxAPAABAAzEbIRBQAg8gAEANHQ8gSw8gTwAD0wPfAE
BQAxNDA0BQAfkP8AHC-wOAABmQ-4AAgP9wG4FrD3AJMx0BGyMbDyADQEABA9BADf0LLwBLLwBjTw
DDTwBPgASiUVH-kAKhUd_gAeNRAAAvoAIB8T_wA5NT00DQDwAR0fFx8PMXwRNR8XHTQdGxwLAJAb
HRQwO9w1G3AFAJCQO3w1Fh8WNXAIAOMaNZDROtDROtARkhEVEQYAFLIFADCw8gAUAR8xCAKtJBUR
CAIiFREIAjEVEXAGAGCQOrsaPxYGAII5sLE1GRY1cAYAURGSMTWwBQAh0hEEADOQ8gAFAFTQPTA9
EAYAcTQwNBAV8AAHAB9QEgEcL-B4EwEUUB8UUX5RBgITHQgAQT3-FwAHASH8AP8AwDE8Pw88MT00
PTE8OwgAlh0cOzE7MTscHQoAcBQwPPsAPHAFAI_QPLs8sDy7PPUDDg-jAR0-8P_55QEWWP8XAD8U
ywAyN38P7AExN3w31QDTNx8TFzw3Gxc9ND03GwoAoR0fFxwbEXwbERzaAwUMAEAUMDr83ANP-AA6
MJgCJ-IIfxhSsFJ_UpASHxQXEX8XFxEfFBJwEh0MAGAdEnARHTFnA1AfEzEdEQ0A8QMcPw8cMR0R
UBQdFxMcFzsXPBelAQkNAFgbN3s3GwoAcRAUPfsEPTQFAJAdPxf7ADodNB2VBP0BHRQwWrtacFq7
WpD6BLD6BJ8BD5QGP-EBcLI48ACyONAyMRIRMj8YsAgAcT6QMrEyPnAFADHxBDIEAGP-FAI3HxcH
AFBQdJ8UF5IDFw8KAIpUXxQ-FxcTMQsAUBR-FD8XMgEqET8NAGRwXxR-F58HAHKw-xcAHw-QBgAE
9wAiUZIEACAxsgQA-gPQMfIAsDHyANAfFBRwHRTwAB0HAB9wkwceDwABUjcfDxcBAQQOAAsCAVHf
Fz8P0AUACgABb9BR0rBR0vYAOQb1ARFy8wCBcj6QMnFyPnAFAA-xAVdFAtD9AuwA8AJxktBxktBR
shSwUbIUkHGSPwUAZzywHBTwDAQAHwTgAR4P6wCAQhE0EXIGALfQMT8UsrAxPLLwCuUALwwc0gEy
QZFSPnAFAELxBBIVBQD0AP8UAhc1cP0CFzVQdJ0XEwYAIFRd0gAQEQkAETwIADEUfTzKAAcKAIRw
XTyfDxYfFggAYbC8NTs1cAUAQPEANbAEADNRchEFAAuxAwisAg_6AisfUOgABw-PATYyFRE9CwBB
PRURPcMBgB0VPRxwXxR8CADxBLB8NR8WFnVwfDUbFnVwcTU7lVAFAHNREjEVEfAABwA1MVIRBwCB
0DGSUbAxklHCA14aFPAAGgcAD2gHHh94uAQXMgB-FwYAgFB0fxQfFzE9CACwHTE9UBR8PX8PER0I
AHB7ER1wXH2bBABvsN070N07hAQDfxwUcBwU8AAHAAAfcAwKMEEfGDgeKQg3HjgeKwhiNFF_UTQw
BgCxFF8UEX4RXRQwFF0IAHIQFP0MNP0M8wpDFL0UHPMKAAsAAfMKcxwUfRQcO3AIAI_QO7w7sDu8
O1kHUC-wOOIAKiI0EOIAH1TgACIPzQ0ZD7kBmgLWAEDxANAS1QAABQBhsBQd8gKQBQBBNB3yAAUA
IfACtg0QCrYNH3DCCh7zDTlx8Ahx8AIRHxDcPhFwER7cPhFQER4c1zweETAIAAAQADL3ABwRAAEJ
AIJQER78AB4RcAcAIfAARAAv-z19AB30B0AR8A4R8AwRHxAR8AoRHhHwCBEeHB4GAEgeHBccBgAz
EfAGBwAlHDcGAC8EEQcAGi-wBgYAATQXHB4HAFQIHhweEQYAIxEemAARDKkAHwDgAB30BnZfGFA_
EtBeUD4SsB5YHhAeFzgSkAkAl3AeGDdeWD4SUAgARn4YPjIIAENY-gASBgB0Eh44nhIeMggAtXAS
HjgeEh4SHjKQCgCTsBIeGD4SHjLQCAAx8AASBwASAgcAYAQyHjLwBgUA3whS8ApS8AwS8A4S8IDT
AB1gBFEQGfAGBQAhBJEEAMCQ8QaQ8QZQ8QIVcTAFAFIQ8QYVUQUAYTE3NfEAMAYAhBBRNxURFbEw
BwAiddEEACIVERAAAwgAU3EVERXRBgAl8QwDAERQ8QhwAwDfkPEEsPEE8ACx8ASxsL4AHfIIShbw
DhbwDBc-FvAKFz7wCBYVHhUW8AYHAFIEFj4QNQYApbAeFhAeFR418AAJAFQ1HjUwFQcA4gJV8ApV
8AAXNh5VHhXQBwBzsBcVMFUQNQcAc5AWFXA18AAGACWwHgUAExUFABEeGgABBgBgAjUwNfAEBQAQ
BmsAEAgFAA-7CR3wA7B38Ah38AT3APAA9wCwdzq3cAQAYzdaN1oXGgcAElAHACU5MAgAEDoIABRZ
CAASEAgAFJkHABAaBwA1WRo5CQAQdwcAQzoZHxkJACAeVwgAFloIACMQFwkAFTAJAFYaGVpZeggA
QFAeGRoIABNwCABikB5ZWjk_BgBgsD55PvAABQBfBH7wCH7dAR7Cfhk68AoZOvAIORoXBQCYBh8Z
Hxg-GR8YCgCRHhk6GR4fGfACCQDXHbAaFx4ZGjcaGR4ZkAsAhDodGncaHTlwCAAROQgAFDoIACOQ
GSoAJxcaCwAhsB1UACPwAggAVAYePR4dBgBRFxo58AgFAI86GfAKOhnwfuEAHfUQgh8Z8A4e8AQ6
ED8YEDnwADoQPRA50BkaFx05HRk6sAkAAAUARRkdFxoJALWQHhAdGToXGhkdsAoAltAdGRpXOhkd
sAgANjpXGggAACAAdRc6GR0QHrAKADGQGhdSACU5sAkAAAUARR0XGhkJAILQORA9EDrwAAcAIAQe
sgAfguoAGV8QEATw8DEACx84MQCN8AQgIASQEj8YEvAIEj4S8AQSHjg_kAUCBwBTHjc4PhIHAIPQ
Ehg3OF4SsAcAMx54fgUAMz44ngUAMhL_AAUAYdASvhLwAAUAMjJ_MgUA8QAEcvAIcvAKPxXwDD3w
DDIDACEeEgQALA4eAwAPwAYMHDXDAPQVsHjwCHjwBFg6WPAAWDpYsFg6PxY6WHBYOj46WHAYOj43
PjoYCAC2UDgaHjc6Nx4aODAKALgYGh4XOjg6Fx4aGAwAxRA4Gh4XGngaFx4aeAoAEFgKAEAfGHgd
DQABIQASHQwAxRgdGR4XGb0ZFx4ZPQoAEF0KABB9CgAVfQoAID0QKgCIOT05Fx4ZHTAMAJY9GR43
OTceGT0KAJRQHTk_Nz45HXAIAFJdOT45XQYAYLBdOV3wAAUAbwR98Ah9sDcBHGGQPlA_8AIFAEJe
GT4YBgCCsF4YHlo4PnAHANhQGB4YPhgZGhkYXhgwDABSmD4YPngGAMBQMRg_GB8TGD4YEXALABAd
CgDpUBEdFxE4HRMdOBcRHTANAGY9UR1TPTEIAMEdEzEdUx8cE1wTHRAMAAMLACHzDAQAlxMdEx2T
EVMREwoAdx0THbMcUxwJAAAcACPzBgcAETAHABQEBwAzXRMdAgAYPQwAn1AR-QSQEf0EMDcBHCfw
ODgBMhA_GAYAk9A_GD4ZHjg_kAgAlHA4PhhaGF4YUAgAdXgeGRoZHngIAGNRXhheGDEHAFAwER8T
ETgBAAQARz0QER0NAKg9EVgRExE4MRMdCwCDHTNRUzFTHxwJABMc_wATHAcAABkBQxFTETMIABBT
OwE0HFMcCAAiMx0oAAMHABUQFwEWUyIBUFNQEf0IBAAfECEBHlE4cDjwAAUAoBg-GDA_GPAAGD4H
AAEwB0DwBD54QAf0AHg_0B4YPw44HjgesB4YPQgANRheGAgAUZAeeN5wBABVGDJ_Mj4HAGUSMX4x
Eh4IAHU_GBF_ERg_CABTXhh_GF4GAACRBCQeEgcAMlIeEoUKBgoAEJAKACFysAYAv9AfFbIc8AAc
shxw9AAdULQ40DiQBADzGRhfGFBeGJAYXlBeGPAAnvAGnvAEHj8OWB7wAh49WB7QPhg9GD4YPpAI
AOFwHpjeUB6Y3jAeOP4IEAUAU14yvjI_BgB1PhIxvjESHggAdBI_OL44HhIIABQwxwAlUlAKANCQ
8gLQ8gLwAD8VcDzwWhgPzAAecTh-Fx8W8AYGAOkCHxdfFh8XHxY-Fx8W0A0A8gKeHxcePdCeHR49
sN4dHh0ekAYAgz40Xh0eHT5wCACpUD4UPhQ_HR49HgoAN14UXggAiR4UHT4dFF5UCQDDXhQ_FB8S
HxUfEhQwDwBAHB8VHA0AAQwAGlsKABm_CAAQPjEANxxbHAoAAIAAdR0UHDscFHAKAHFQFF5UfBRw
BgCfkFScFNBUnBSwMAFesB8QET0cEVA_NF4cCQARMCkBODE9MQkAdV4UPhU9FVAJAAIqAQ8LAABH
XhQ_dQgAcl4UPj8SNTsrARE7CQBCvjs-FQgAITo7HwE0O3obCAABJQElG5oIAFMwND5bugYAn1Bb
_gJwW-oCUCEBXSF_XQUAALcBNhR_PQcAsV4UPh8QER0QHBEQDQASHAwAAxABTDEdEDEMAIleFF4V
HRAVMAsARl4UfnUHANC_XxI1OxAeFL5bNTsQFgFC_wAfFQgAIRoQFgERGgIAGToNAFE0Plv6AgUA
jxBb_gYwW-oGNwUd9AqQ1-AC17D3BpD3BnA3HxYWNxY_NxYXUDceCgDzABceHxIeNh49HlYXMBce
HQsAzBAXHh0RHTYdMR0eNg0AiB0xHTZxHTYeCgBWUVaRFj4HAFgeFheRFwkAqhYRHhYeFhdRFxYN
ANkwFx4RHhEeFlcWFxYeDQBxUB4RFhEWFwIAKR5wDQBRFh4WHjYLABeQCwBxtvAEtvAEF1sABQgA
cQYeFx4X8AgGAB9COwEMD-UKHS8xMzIA-----0oA3waXMvcMHxYQ9wweBAAfFgQADAIoAFNe9gI_
FQYAJPcMBAACHAAGEAAPBAAFNDD3DGUGHzGtABaEMPcOHxb3Dh4DAB0WAwAFGwApHvYDAKIV9g4V
HpYeNZ41BgAj1hUCABoeAgAv8DCVAB-UVh8W9wYeVh73Bh5XFgUABJEADJ0ABiIAM1ce9gUAFlYF
AEAV9gYVBQCENT4VHhZelh4IAACpAAQEAAICAAMOAA_xACEx9-8PkQCgBB8WFvcMHhb3DA8A8wOX
9gZX9gpX9nQVfjUeFR52HjUIAHEVHlYeFl7WBgBR9gQeFn4FAEHW-gAVBAAPggAhrx8W9wwQHvcM
EBYEABQTHgQAVBUe9gY_BgAv9wwEABkfMHUCJJAydx8W9wIwdx4FAB4WBQAm9wwDAAYWACR3HgUA
dR5WHpYeFj4IAC-3DAMADA_rACgEOwAPAwAPHfYDAIEfFnZ_Vj4wHgYAOrYe1gQAMRUetgUAL-Ay
lgAd8BgQ-xYMMP4MEF71BL71BJ71CH71CH4V-xUEFX4V-QQVPjU9-xQAPXV3Jqh1HTw1FBUUFTwd
CgBVHDV0NRwIAMU1Ph0cFRQVdBUcHX4KAGE_FR4dHDQLACgVHgwAEDULADFUFRRAAAMKAABCAAA3
ABEUQgADCgABQgB0FBU0GhkaFEUABw8AcjUdHFQVPBlIAAMKAABIAFJUFRQVHIsABAsAA0oANRQV
VI4ABg4AUjUdHJUUzgABCAAfNU4BHgPCATMGFjcFADMEFlcFADQCFncFABEfBgByHncw1xYelwUA
MbcW1wQAAkEAAEIDAgUAQ-cGHjcFADMEHlcFAAZLADMAFpcFABYMAwBBlxb3AAUAD6QCHlz-Fg4R
-gMAERUDAB0REgAPAwAXrxH_DlH1CHH1CDECBx2hFV8WFRH_AhEVXgcAFp4FABQVBQABXwABCwAR
FQUAB3UABAMAIgwVBAAiCjUEADMIFT4FAEIGFV4VBQACMAAzAhWeBQBTABEVfhUHAJ8xlZE1cZWR
NVG-AB2f1f8WABHV-gAROgEMEbAeABEQDAARUgYAAgwAckYV3lURFVEGAA99AB0EjQIPAwAWcH8W
9gA_MH4FAEw2HvcGBQAWNwUAFRYFAAUUAAVGAA4bBQ83AxYCAwDDCh8WMPcKHjD3CB4WBQAPUAML
MgAelwUAVdYeFncWBgAStgQAEhUEADAeVh7vAydWPgoAQ5YV9gAFAB0eBQAPTAUfX-D----zNQBS
HBDhBgaSAeEXHxb3CDAXHvcIMB73CgQALPcMAwBCPvYEPgUAD-AGR4LfFhFeEV4R3gYAXxVeFV4V
BgABDAIABxwAFREGAISVERVRNREVMQgAMRU_FVUABQcAFH4GADFVnhUEADQVEb4FAA8CAAWPMfUC
ERWR9QJbAyBz3xYRPpUR3gUANBURdQYAMzURlQUAMlU_VQUAQjE1fhUFAGcRNT4VPhEHABNVBgCF
tfEEtfEE3hECABEVBAAPAgATL-UyvgAdIBV-VQUhADXgBAXxBGICFX4V-gQFAAB8BGEOFT4V-ggF
AAM3BSQKFUsFL-4OAwAXrxH_DjH1ClH1CjHBBE5APxYWHr4EEj4HAA-MCRcPtQNSjv8W----s-Uw
BwEPIgQYDzwBSA8UBFA-9Q4RAwBDH-EFAx8gPxY-BELVERU_CAAZXgcARj4VEVUHAFMVXhH1BAYA
EH4RAAEFADFe9QgEAEE_lRHVBQCyMZVRdXGVUXVR1RECAAOfAEIGPhUxBQBDBF41EQUAAAUEAgYA
VT71AhFeBgA0ABEVBwAP1gAfMNURNd0DINUR3QNV9QAeFZ4GAAAfBQMGAEMCPhFeBgBT1RF1ET4G
AGT1AB41XhUHAFLVET41XgYAMTGVUQIAWTHeEdURBAAv9QAEAAMDIAAjvhUFAC-xMv0DMQYaCCMW
FwUAAhkABxYIMx5XFgYAUz6WfhY_BgAP0wJHD6gAADHXFrcEAAoOAAUEABAfBQAmHreiCAuqCDQV
PhahCAcLAA_sCKcCBwEPyhIYGR4EAB32BAARFQQAIB52ehEEBwA2th7WBQATHgUAExUFAC-wMM0S
KBQWAwCCVvcAFhc2PjYHAAQWAAY9Eh-21BIkD2kTWAADAJM1PlZeFh4VPlUIABIVrAADIAAyAB62
BQAPmAAi0P_x9rAVPxZWXrYeFT4GABHWVQAHEwFP9gDwMEICIx8QlxImKh72BAATFQQAZFU_Nl5W
PgcABBYABCYAQR7WHrYFAC-wMkcPIC8V-gMAGYPwMncWHvcAMAYABZ4SQlcW9wQFAAZpDRAW2wsd
FuALD7kEHo-w--80dxYfFncAXw95BCAQDn8sP-cOEAMAFB32AwAgHxaGAzIVEB4HAFTWFXYeNgYA
Ix7WBAAhth4FAA-xASIvEP4DAEMR9QMADj4HDyQERjAV9g4jBCJ2PgYAFhXOFgMCAA7cFg8CFSIj
HxZIAhEXsQ4ABQACGQAGfgIGkgJClx62PgUAQnc_9wAFAEI3NvcEBQBVPvcIMD5AAA0DAA_rFTMP
fQgPUz42lx53BgAzd3Y_BQBD9wQ2PgUAHwwDAAIPSQMpDzUA8qQyXxZ21xYQXnbXQggHBAAWDgMA
BBgGBQQAIdfWBAAm9g4DAHUVHjUelV41CAAy1hXWBAAEJQQCEAAPxQYvBAQABI0ADBAADBgAQl72
Bh4FAAQSAB8VBAAEGh4EAA9fAiQfELcJLAGEDxReBwAGGgAfFQQABBseBAAPtAAhEPCYAyw3EAUA
PQYWVwUANAQWdwUAER8GABEeBQAjNjcGAAMRAjQEHnYFABMVBQB1NT6VHhVeFQgAAxICBiICAgQA
L-AyMgOJALAEANkBOAQWV3UBGhYEAFYEFjcWHgcAADAkBgcAJBZXBgAg9gYgAAMGAAumCxGWngsf
lqQLRBMI5AYfFgMACgDkBjVX9gjiBgOLCqNWFT42PhV_FT41CAAUFd0GAiYAD6ILKbLXHxbXENce
1xDXFgQALPcOAwAEGgAFBAAh9gAEAAJ6AgRKAhsetwgPbAI0Bd4DCJAHlDZXNh4WNzYwHgkAB18a
DwUAAgR4F072AB6WBQATFQUAdR52XhU_Fj4IAA__HDkFvgAGAwBCBDY-FnAHUz429wIWBgA-FvcI
BQAJIde2BAAFkwAFmwAzPlY_BgAAbB8T1gYADrsAD_4DIw81AJMfMFgEGAbcHAehGRcMAwAGFgAH
BQATHgUAdT4WHpYeVh4IAC-3DAMAFB8Q4ABTDhUBD00KJA8DAARgHxYWF5ZXLAMDCAAPuBIfD8wA
Ig82AYIsDhADAAWMCDMKHhYFAAfmByIeVwUAEvaiBgQHABYOAwAAlBAklh4HAAdBBQIEAAJdBS-w
MNsJKBQ_AwAAuCMfNgMAASIWHiMAFvYDANIeFfYMNfYMdT42PpYeBgARNRIAJBUeIwAAJgAP-iQm
EBD_JDQQVxYFAC-3DgMAAwYiADFX9ggEACb2DgMAD4oGRA7pAQ-XDxkBbRIP0wFRALcBHzYDAAEV
HiMABn8lFF4TAAAJAnMV9ww19wwV9wEIGgADZQAP1gFeAM0mDAUAU741PnYeBgADNgEGRgEO3AEP
LwSAIQYf3QsZHucLBgUAFw4DAAcbAAU1BDIGHlYFAAYUAVNWFdYeVgYAIBU_jB4EBwAPIgEDD2gC
IAJtJw9jAhaCfhYe9gIeFV4HABIeVwIsFR5pAg8EAAIPbgImCSINBTcNFw4DAAYWAAcFABMeBQAI
RA0OTg0xHpYeVAEGCQAPfgJrAiYBDYoSBwUAER8GAH0e9wQwVh72BQACricGEAAE2CUFBAASHgQA
ELZGCg9KCj8fMDUAtBkQMhsFTBsIAwAPWBsNDwIkbR8wNQAY8AMNAfAOAQcB8AwBIAHwCgEHIAcH
ABAgEQAQBxsAP-D-FXcBIg81ALxfVRH1BhEFAAW1cRARFREQEVUxMFEKAEHVENURBAATEQoAAgIA
APsYD3wAHQhrAA4FABEQAEZzBrVQMVUREAYAOxD1AAUA8QLwABFVMfAEEVUxcBEQcbAxMAYAF1AM
AD-w-3GZAB1iNVC1UBURBgCJFRA0ELUQNBAJACbwAAgA_BAxED8UHxW-FB8VPxQwERA_HxW_HT4w
FRA_Hb4dPhARCQBfEDEQURALABEQMHQ7EnAFAAA_AA8GAAEt8AAFAEM98AA9BQA-EL0QBgAAH-Ck
AR5xvxZVMX4RvgUAMhEV3gUABjQqBuAkAPUpEREFAAAJKgIFAAQgKhFVAwAF6yQDBAARNQMAD94q
PHB-FjFVvhF_BQAz3hEVBQAl-gKTJSQEFbMAMQYVXq0qBa4AYj4R-goRNQQAAbIAA6IAKREVBAAu
DhEDAA_vACayVR8WFT41MX4RVR4IAEA1HhE_YwEFCAAgETVoAQMHAI8VPjX_BDU_NXABDwDFADEx
-gwDAFAKUf4KMXkmIh4RBgADZwEGqisGFgEFGCzPFV4VUZVxNZGVcTVRvwSHDjUAD3gELgA4SAHu
BCUxcAoAD-YEBnE2MRCRUDFQBgBhMPECMHEQBQABEAAkEBEIAC-w-xkCH1JQVVBVEQYAnzUQNBBV
EDQQNQoACxFRiQRQcD8UcDGGBMdwPnA1EH4QERA_EFEJAEaeMT4dBwAQPpoERx0_EDELAEcwHT6Q
AwBTcD0_HXAHAFk_HVA_HQgAVjBeEB0_CAA2UD4wBwATPZQEB5kEJFBdBQAPiwQfI-8WbAMIAwAz
Ff4OowME7gIBXAQCcgQTNRADBZwuFQjyAhEG8gIBwAQHzwQA3gQSFQUAUTUxFX4RBgAO2wMPrwAq
EhWiACQVEbAAA1gEJQpVuQMgETXSAxIVBQAfBqYDAhKeBQAAkCsREQUAY34VMTWeFQcAr7GVMRXx
AJUxFVHEJyEgHpXCJwAEAAMKAGSeEVU_FV4HAHU_FR4RXhG_CAAgdZ7wJxGVBgABfytCERURNQgA
EFG7BBBxBQBgURX_AnUxBQBwETX_AhVeVQUAEDVqARJ_BgCDFT5xFRFVXjUHADBeMTWDACVeFQkA
MH4RNQUAAwcAVZ4RNT4RBwBjvhFVEX4VBgBRNVFeFREGAGBR9QAxNXEFAB8xjgSHEFB3BAEFAD8Q
NBAGAAMkPxR-CSdQPgoAU1UQ1REQBwCBPxUQVRHVMD0GAAEUAAQGACvwDAMAET0DABc0AwAcPh4A
HwpTBSAkFVAFAAm8AAMGAGAwcfAAPxQGABA_zQkmFRAHACAQlb4AAAcAET0GAAITABA_2gkVEQcA
EDDMCQMGAADeCROQBgAPzwARHxDOAB0l8EpMAFQ08Aw-FE0AMz7wDBVJHz4DAAQPjQBAUL8WFREV
fwkDBwAhMd4EAESeER4RBgAAaRsi3hUGAA8YCANBnhXeNS8EkzE1HjURFX41UQgAFTHULwqWCQMK
LxIVswQU3gIAAkwvj1GVEbVxlRG1ngk9Yn4VnhV_FQYAAF4EE75uBAEIAABTBBQ_BwARHswIOQAR
NQkARP4CMRUIABBeFgAlFREIAAARARIxBQARBOMIAgYABXwAAqIFAD4AeDUeFV4VHjUMACMxFQoA
FlUKAH_R9QSx9QQxYQUhAAABIRU_BwBEnjURFQYAAUYFAwYAMPUGfjk4UApeEfUIBAAkET4FAGEx
9Qwx9QoFLRMMBgAQdUUtEXUNAFAOEfUAEZIsEdUGABC1bzUBBQAT1QQAEHUsMSR_FQgAcVEVUVUR
VZEGAA-oCYgZEIUDHz6RAwsfPQMACRRMCQBPDD3wSi4PZxB3PA4bcAUABkkOE3BHDg9dASEWN1EA
D1sAOQNeAggDAEFOEfUOjwIgDDEPABFQFQAQEKkCEDUFACb1DgMAQpUR9QIFABC1ogIBBQBB9QAx
lQUAH1FiCSMi3xbVMwO8AwhkCVTeFb4VEQUAETEEAATADgAmCTEVfnUGAA9wCRRk3hUeEZ4RBgAE
cgkiFV5zCS8VXnQJLAFgMDAVPlXSNAEIAACDCgAXCQIHAAAJNRY_BwAwFT61BAAQvkIBAQUAQJ71
AjEEAABMMTECETUGACAVUSA0Igx_DQQAPzBA1RH_AF4wEAIQAHACPvUOPvUMIDEiVV4FAFEAEXU_
EQYAUTF1MT61BQBAsTU_FdUAAQcAD9cAHg7pAw81AP----------------9-UD0xM319
:: gfx/3_dung_objects.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTI1IDE1OjEyOjUyIixtb2RpZmllZD0iMjAyNS0x
Mi0yOCAyMjozODowMiIscmV2aXNpb249OF1dbHo0AFQiAADHZAAA9gx7WzBdPXtibXA9cHh1AEMg
GBgE8ObPIKAOpA4EAGcfFAQ9FB0RAAAEABOtBAAnrxUNAPMCrQ5ALGZsYWdzPTAscGFuX3gIAMt5
PTAsem9vbT0zfSxuAPsEt68gwA40DxQ0DsAOhA7ADjQNNAYAH4QaAABAPQ8VPQcAEAwGAFWMDsAO
jQQAH1CCAB0B8ABuBBZEFgQOCABvDxQWTRYNGQAABAgAUA0fHU0cIQBRDRwNJg0KALEPFR8NDxUs
Cx8NCxgAUwsMAQwLJAAlCywKABAtCgAfQK4AZhVNrAART7AAB5UADwoAAA-ZASYQFa8BE4YEAFE0
DTQesO4BNw8dDgkAIIYMBQAgDxIUAKANNAsOsA4-FA06CAAzOg062gEVigQAD_IBHvAI-xn-IABw
DiQPFGQNJHAOZA1kcA4kDSQHAKAtDxUtDC0MLXAOBwCQbXAObQwtDA0UDwATbQgAFS0SAEItDF0M
IgBPLXD_AIYAHnAR-yABYA8VhwCgDiQPIGAOZA5kDREAIA4kCQAiDC4CAAMKAGNuDWAMFE4RAEQU
DgxuCQADJQAjHB4lABJuEAA--QFgkgAdibpPIPADDiQOBQA1HxQEDAAGBQAlBB0LAAYFABotDwA-
JA6AggAdINI-ggDwAQ8UJE7ADh1kDrAOFC8VDTQIADAcLQwaAlAUDC0cFAgAsC0sFA6gDhQMHSwk
CADwAhxkDqAOdC0OoA40bQ6gDl0soAQyHRwdCAAvbB2NBCNxwC8goC5AHmoAQA4QHjQIALAPFB5U
DqAOLTQfFRgA0w00DSwUDA6QDgwUTQwJAEAcPRQNCQAyNBwdCQAiZAwIADI9JA0JACCdDJcAISxN
BwAhTD0NAG9dDqAOTaCjAB3xCokvICAu4A4fFA4ADhQO4A4dHiQOsD4dDkS0ADEdJA_mAFA0DBQM
DQkAUBRMHQwUggAkFDwJADUsHRwJAHEdDpAOHDQ8BwARdAYAID00PAEhDB2AAQAJACBc0AUAn_AO
HRw94A5NkLAAHTbOzyA1BkMUDxUfBAABnQARDQIAAmYBQRQMFAwLABQMCgAENgBwrA6gDhxtHAYA
EQ0CAAEKADVMDRwYAB_s6wEfY7xvIKBeVGIAGESUABUflQAhDSSKADSQDg2VAAELABB0BwAQpAUA
IERcBgAwTD0cBwArHD2bAAASAAAIAG8tXA6gDkzqAR7yAI8vIPACLhQO4C5EDrAuVJ8ANEQNH50A
EByWAA_nAAgyFAxECQAQVJ8AMB1ETAYAMRQsLQ4AIhwtrQBEDRwNPAkAIhwtCQCvLSzgDkzwAg4c
wLMAHB_QUAQBSg8UBA0SAPACJA7wAg4NDxUNDA0O8AEODSQHAFIeJB7wAhsAH00WAAADbQQPBQAK
H05-BB3QgA8gDxQvFQ8UDyDwAYYEC4kAPx0EHYsABxokBQAfDeYAAAMqAA_1ADvA8P8DTyDwAg5E
DvAALwUABQQSBMcA9wYEDtAODxUULRQNDrAOHQ8UBCkEDB2SAjAsRCwOAEcUKRQcCABADQxkDDEA
vxxEHA7QDg1MDQ5gkwApJAQPlQASPZIAMQ0MPZEAI00ZjgAiLSyOAEIUDQQJkQBSGQwJBBwKADIE
DASVACNUDZYALwwNlwAm0QJvIPAADmQO0A4UTxRHBhFvRgNBBA8UbzABcKAOBA1vFQ0JACAUbBoA
UQwUTRQMgABAFCkUDAEJIB1ktQBADA1kDaUInx1EHQ7QDgxNDI4AIKAgHyDQHlAOBA6wFQMxDkAO
iwAAewlCIA4MDY0AORw_DI4AQy0cDQSQADIZHASRAD9EDQSTADSg7y8g0C4wDhQOwFEGEDAIAAKZ
AoAPFU6wLg0MVJEJ8AkpJA6wDiQpFA0MHqAODUQcDRQOwCQOHTTtAf8CHRQdwC4QDD3ADh0OIC3Q
LeAVAR4gMl98A8AEDxQUDQQO4A5EDRSuAWANRA7QDnT4ATAEDRRbA3HQDh0PFR0M6gCwDQwdDA0M
DtAOHD6yAlUdDhAOHQgAH2CCACQxVA7gcQAArwQkJB1_ABBUegARfVcDH11yADcQFQkKAI8KESQO
CoAkDmAOZA0kDQgAICQNFAABCwAhLQwCAAMKAJNtDmAOTRQMFA0SAB8NDAAEAFgIAjIAATwAP-4B
IJ8AHWSK3yCQDsQDAHQfFAQtFA00DwDExJAODxUdFA0UHQQdEQBAxJAOzQMAQx4sjqBAAgIFAB9w
ewAdY4DvIIDUDgMAMDQPFGYAJB8VEQCE1A6AHVQdBC0NAEHUDoDdAwAgniybBQh6AA_nCB4g-wSo
CBS0AwBUDxQEHXQNAEG0oA69AwC-HxWeoA4dDvAEDh3rCh9j_N8gkMQOAwAD3AAkDxURAEHEDpDN
AwAirhxgAAFlAA-HAB9QYh8gIB6GBTAOIA59BTEUHhDfA1AUDxQEHroDUA5EDhQNEQAgDUQHAA1g
AxPgXwMPvAEek-9lPyDwAh40DnIFMlQfFMADAMsDEGRiAJANJD0O0A5tDxXFAz8tHhzJDSAv-zIz
AB0VnGwDAVoDAmMDA20DE6RzA1GkDmAO5AoAJGQNIgAXZAgAY0QPHSYMBBsARgQGLQYMAFIEDQQG
RAwAQw8NJgsZAAHDAxAKCwBBLQptCpkDTwotCm2PAyISi1UJ8BEPFD7QDnQNPpAOhC0PFZAOHQQt
BA0cLZAODQykoB40DQ8AELBHBFCQLg0EPRkA8BOEDC2QDlQtPpAOJF0OwA5dLhAekA4tDB4QLhSQ
HiwOEA5ErgMFBwAyDCQNCQA-DQwtpAAd8AvIPyDwBC8UDxV-ILC0DqAPFLQOkNQOgI0PFa4D8Bh9
DA0kDQ6AbmQOkC6UDoAOlC0OgHRdDoBEXRwegBRdHgwdDpBNLgC3Az8dLjC_AyKQDT8goI40oA6E
vwUBsgNSLxUdJD2vDVEtoA6UHhUAsE1koA6dFKAOHC5tyQMwEE4dBwAvYB5wAB1h5J8gkD6EtgMA
yQMQdNEDkRVtDA6QPQwtBPMNcT0_RA6QPiBgA4AOkCROTQ6QdAQAkC4cDpAtNA0OAN4DEn0HAD8u
TfBNEB4ZcbUGQwRfFASpBhEdAgAPCAAAAt8DU9AOAlQC3gYEBAACEgAQcpYDH1LlBjYf6aEAHgyp
ACMdDAgALz4djwAvcHEfIPAFDhRXBQ8FAAtwHxRe4A4dRBIBKh1UBQACFQAQUgUAP0IPFSkBBA-U
BB87Yz8gggAFCwAEBQBSAw4PDR8IAC8dFB8DIBB33QYEbQgioA4ABQAIAABGEQD0BAQGAAQaAB_k
UQ8fkf_TTyDgTiQO4GkAAQcAoBQkDgBOgA5kDgAcEgBdAAMKAAISAA8LBR5R-8GfINAsEAMmCgII
ABdEDgAPfwEfIMFvqQIAVQAA7A0ARABREC6wDkRfERGwEAAAaREfMFgAHRG-cQJhBA7QLiAOnwAg
DhDmCgAKABk_7wIB8QIACQAgHCRgAicCZJoDEWQSAGAkMg7QDmKaAzAMIh5yAj8cHgAEAyGy7h8g
8AYOBA7wAB6UADAEDiDqCAAOCLEOIA4dDsAOBA0uAAkAB58AD54DBCAsHX4SES4GAAHIBAQIAA86
CB4ZopwDIQMOiwExAw4UUQ8xFA8VBwAQDAYAIB0M6QmhHQwULuAOHQw0ApsDOgwOwAYAMRIkAggA
gFIO4A4cDiIMmgAeLm4IDx4QERAdGxAAdgMDfgMUDaYACawDHx0FACEfoo8AHDBQDyCrEgLKCAW9
AxWkCgAIBgAVpNEDGaQOAA-5AwEGFAABuAMBCQAQDAgAIG0MXxUCSAxAoA4sTqsPXS0OIA4tCAAf
QMsAHwUUBAElBAQfBCAeDQkANGQeDRAANiQOkAgAUg8VBA0ECwASDAoAACUACQsAIh0OOwBmHQQN
BA4NIQARDjYAMg0MJAkAAB8AFA0TAAUJAB8MCQAGUAQNBAwtCwAkHC0IABA8BwAhDE4OABEMBgEA
XQkPDwEiwHAPIBQPFEQPINAORPwCBNIEAtgEGXQKABF06gQdRA4ACAYAF3QcBQISAAUOACIPFQkA
BVwHLwxNyAY0AsUAMhQPIDgFMA8UBLEUAkUFAVwVEB7bAGDADg0OBA2JDGDQHh0eFA2bAwAHADCQ
LhAYAAD0EAFFBAkKABXwBwBxBA0ODRQOsKQEEQ2fBTEeHQ5dEkIUHhQNCQAxDQ4U6AxBDRQORAcA
BPwABwQBHwwEAUPwKPC5PyDwAD4CJE6gDhIEAjQiDnA_AhQCRBIOcA4UDgIUAlQPFQ5wDiQCBBIE
LxQkDnAONBIkLRQIAJACJB00DoAOdB20AvEFFAKUDpAOEiQCBAI0Ag6ADgI0ElQHAJAPFWQOgA40
AgwHAAAfAAAIAD9EAmRzAh5C8J7PIBkEIEQCOhgkNAILFwAEAIcEAoQOoA4ClBMADwQAAg8pCCMU
VJINADINQg0EDxUzDXAUBAYsBgQMDQBTRAYEDAQMAIQkDAQPHSYLRKMNIwxkFwA3JAxkCAARZK0D
DyAAAwMaAEIPFSQMlQ1RLApsCiwIADAsCmyVDS-wO8UAHRdsVw4H9A0oDCR9EQCbEWUPDS8dDw2q
EVIPHSwLTQsAIQsNBAAAGQBfTQ8NKwrCEQQhDu0OAHmtDmAOrQwtGgAECgAv8FO-AB0hiy9zB4Ae
8AMONB4wHgcCIT4ScwIUZNMR8AfEkA6UEgSQDkQiRJAOMoSQDgK0kA4CYA0ADACQPXSgDh0EDUQi
tRRgNFKgDiSCdA1PIh4iDowAHcSIbyCwThI0DoAuEoTYEfAAJB8UBB1UDoAUXUQCDoAU7Q60HQQC
BA6ARB0UHSQmABBUAAPwECQSZBIOgCJkMg6ADxVkEgwiDoAMRDIsDpAMAhQSHhKYBU5CDgAeVg4P
CRMcRBIEAoQMAAsDABHCAwBwIg8VHiIuAhUHcQAuIA6gDi80CB8sBxMsAgMAdMQCDoC0AgQPALGE
AjQOgHQCRA6A0gMA0hIuIh4PFSIOgB4gLgAFEwR_AA-3AB3xDjAPIAQCJAJkAg5wDgI0AnQOcA50
HxQ0DnAOZC00qwQgFB2OA3ICNAIkLRQCCgD5DRQ9FBIOUA5EAhQtFAIUDlAOtAIkDlAONAJEHTQI
AFA0Ag8VJCsAwjQMQgxCDlAOMgwiLggAfy4QDiIu8MsXCSMMBAA5VAI0CgACBgCAog6gDlIPFTJR
F0ciLiINyggQLwMLAOMIESwIAC-wzYgAHLLwWk8gwF4NLx0NXhgECXcEEAsLACEsCwIAAQoAE2wI
ADMsC2wIAAIaADtsCywaAAIqABHsDABVrA5gDqwgABksCgAPBQQfETzEBBPkWgVhPxQEHRQtjxgC
EQBwhA8dJg8NBAoAMAYkBggAtx0kDQQdBh0PFQYMFgAGKABjLQQNBH0MPwAEBAAS7QQAL-4BoQAf
b---Io8gYCUUUEP-kY8gsQ494A5kBAAPgwAfE5P_DQEoDLAQPsAOJC4kDsAOJAoJAAkAIxQvCQAw
DxQU7goPaggemLP-IAJQDvQADgUAaR8UhA0ELRMAAQUAFf0FAEAdvxUdBwARvAYAOQydDAgAFLQG
AA_aDx4Qs0ABKHSOdQAwfxRUTAJQUA59LERXACQspBoAIKRNKwRgrQ5QDq0scgAgXXwGABfcmQA-
TB1EiwAmHyMaAQNJBA2kDRMADxoBIwUiAA9CAT2QJS8gkC5gDiQurQAARQBARC4QDswBIJQuBgCQ
DxUdRB0kHQ5gEiMgRA35AxA0XyIALhxhUA5UDF0MNQBAVAwtDHkFQD1UHCTvAEFdNBwUkwBQDE0U
HD0JAEAsTRw9ywMwPC08TgAwDRSMXwBADA0kbB8AEAwhIBEUEgBiHUwdJAwdCgAxDSQcRgAhbBSx
AUEdXB00CAA-HB106wAfMHAPIGoDFg9yAyQkDXgDBgoADwQADQIqAANrEgAFCQQGABNtBAAMFAAA
CgAPyQMdF3AXBCYkDQYAGWQKAAgEAAIyHCENNGsMJQ1kBQABCSQACAARHRkAAbgAMNAOPSgkDKUA
DBAAD4oNIASOAAwEAAPLAAa-AA9AAQQIEAAGFgAfbRQABA9eASUQYAkCEBUEKBEgGwUQJJEaUiQP
FQ0koRoSDAkAIw0UCQAxJAw0BwAAoB0QsLAYMyQNDAkAASsgQg0UDQwTACE9DMsiEk0HABGNNx8x
TQxNSB8VLQgAED00ACMOfQYAINAOEgAEBgAM3AAfcKEFMgC6FGAPFS00HQSdAzY0DaQGABAMBgBA
LQytDFgDlAytHA5QDs0MHZ4EIK0MngMgnQw6BTCNDF1WBT8cTQxmBB9wpm8gUD5gDpEFACcEAAgA
QDQOIC4IAFBELj8UHwwjERWpAFA0PR8VHSQAsB0kDRwdVA5QDm2ENgBRDQyEDQyxACBULaUAAPQM
EU2pAEA9DD0coAAAkwwQHKMAIi0cEQBRPQwtLE0JBiI9DA8AH7DVBTIgDxUmDCl0HRUAFfTSBUEt
DxW9TQEQzacAOAwNDA4AFN0mACX9AFkBAQsANb0MLXsBIN0MpwEv3RxoAR8RC9QXoCQecD5QDkQe
IC5JAWAfFR8UJC5KAUFEDR8VUwE0pC0cswASTQACK21EpQAgHSzcKGlQDg08TTwIAEIsXTwd0QUh
LC0YAA0oAAMYABGtBgAQfU8pAAoDP-ACLdEAIC--M3UkChENFAAACQBBDxREDQkAgQ0PFR0PHQ8V
DgAQHe8lEAY1BO8mPQ7wAE0MDfACDC0MgIcAORTgEgABgwAQ4GImIS0MCQAhDE3KAyDwAPYDD3oA
JgPTCSAAHicYIQ4ASRcAfgAvHg8GARkQFgUBLxYMBgErFDbKF0MBLgAOBQExDgAOQiMQFDMoYQ4N
BC8VBP0AIxwUBQEjFA0JAAAWAQ8MASof1E0bAQIiFxA9OCc-BB0EBwAHIh8VCAARHAcAEDQFABI9
BQAPZAUeJP9SiQAAbycgoH6pJDA0HxRYCyAEP_0aAAkAAB0CEBSjAQNHMA8mMCQw-6wv0wMQJmwA
MAYBBgcAAQwAIi8dciIPxQEfEcPFASYGLlEAIR8dBwA-DQENTwAgEasaAwPFKAD3ABEECAAlLQTD
KA9sAiMRq-gAIQ8UzQwyBA8VAQMA_AIHWgAvDxVbACERkp8nA68DMARPFb8CJgRNBgAAoyJP8AAM
TY0iIBSUNiEBWAEAWgBBHhAOHyYEMQQuHV0AATEWIfAA0RovDHAQAiQB5ikgBA9tAQPzKS8vFBEC
KycELlIAIR8UBwAAPgUfDmABJiAdRmABMAZBBgYAIU8NBwAQTAYALw1GYAEmkZUvIPADHg8dFgQC
MBYRBg0FUQYRHw0BXwAgLCZfAH8mHQzwAQwteRMeIP8tiC8wYA4UDBcWDggAMB8UrrQMUR0PFY0M
CQATDAgAJ64dcRAoHQweAA_JDR4OPxAPMwBCIKxfrwMCNwXAAR4UHfAAHgYHFA8VRwGvJw8dDfAB
DhcMwFcAHsD2HyDwAU4EPsAONwZVKQ-pBCARltkCEQd5AhAHZQYwAg4HZAWQAQ4HDiTwAQ4Gxwpv
8AIOFB2g4wIfAVwAICY_5gAgATY0AiAmAUMCL25gdAFRcBkfIAAeAB5AGoAPFB4NHg0OAGYCIR4N
AgACagISDSgaAA0AMR0eBwIAA3QCcw0HHQcdBw1cAgkOACEeBgIAD4YCOB9xFSICATweIR8VCwBR
PvABDi2XASEcDQcAKBQMBwAfHQcACBctBgAABBsDBwAfcKUAOgG_H0ANDA0uIQQhFA0tBjEcBwwI
ADcUBxQHABMdBwAfBqsASDr-HS_sACIEDwcAFA6oExENBgAoBA0WAAUFAA-qAh8RmSEFALgAQR40
8AAEADAkDxQGAAA7Ax8NKS0fEmOzGQCfACEHFJwDAZQHA6QDBgcAEQ0HAF8GFPAFFLYAH5CvHyDw
BB4PEgG4AGA9DuAeFAGKBBA0giEf0KMDURFm0gkgDxLnAGAPDw8SDw-lChAtKgQpHQ4HACIPHwgA
EgwHAA8rBR8RfG8HMA8SHv0BIA8fNgEiLw80GQcFAF8CDh8fHHwHIBFkcAIgHx-JABAd0AA0AS4N
0QBfAA4cDSwHAAAvDiwxGiQl-2XMABUDNwEvAD4wAQkAFgAvAw7ZECAi-wXaABIPQAAAliMz8Dce
tQFFBQ4MDRgAEC0_AW8vH-AEK7CdAR8SLwgCFQFSBBEBmgMcFAUAD5oBHx_UWwAMLwUesQgfJZYf
VAAD_AAwBAENEgoBBAA-BA4UnwIf8AhoLyDQbh8fDrAeBC00DR5wLgRdFA8UHUsg-whtFAwekBRd
JA7ABAwtNPAABAxE8AI0wMoBJAEGHiEvH5kFIQQdaCFkDxQELB7gDgAhBD3rDjENBC1rDhA9vSEQ
TegO-wEETQQMHsAOFC00DuAcVA5ggQAkACUDQQEuDxQIAAG4NBAccAAQHboiEBwKCxAtMzNAHRQL
TW85AA4AQU0EDoCXAGA9BA0eYB6ZAAAyDGBgDiQdRC27Bz-EwEQPAR4R6RgCAIUAEAOhIgBpJgAG
NkMeHxQUqg4jAQ4DARBN7w8kBF0GAFDADgQMTWAO3xQMLRQMDuBEHATwAzSaAh7wFNYC8AYCDxnw
BQIe8AQCHgLwAwIu8AQ_AvACAk4C8AECDhouBgAQOo4A_AUKFwoO8AICDhcOAvADDyAUDfAEDQUA
DxcDHyV9H2AGCwUAEAHaAwErAz8FDQEcAzRxDvADJA7wBG8DDx4EH-AA3i8g8AE_AR8SDuAONB0B
BgAP7AYfYBUvIGA_kMsREU7nJRAenRsAJh4gJA7wHgCCFsEPFTQMDR6wDh00DA1dECAOEBonEDQ3
DTAONA0MAmAkECQO8AUEAB8UAQMfcesvIBAu8ABPEhAfTgABcAFQHS7wAC6ZF6HALh0MNB6gDk00
1DlALQ40HmYCMTQMHoYAACAlABgAETQqJTEkDnAgAADwMSGAJBsAXxAOFPAAIwUgEusKAyMdLgUI
wBYPDQ8SHR7ADkYNHHo2QQ1GDQxnQHEdFh0PDQAm4zz0BQsNJgwADRYNDrANJgwgLfAFHeA_MREQ
CwYAHwsUDyAR7CEE8QINHx0O4D48HsAODxIcDhwNG3wAUBwLDSYLzTrwIRwbVhwLDnAOLA1mCw0L
gA4cBg2GDoAODQt2DBYOkA0LFg0mDBssDqAMBgwNDCYNLFY4EDYTDyAcJq4GPwINLJgAHnLODyAG
DhAOBAAvoA4MAAUQD0gmEQ0EAG_gLhAuEC4rAAcIDAAfDTYAMh9ACy0fAW4BUBkOEC7gBgBxDh8Z
DtAuIPkDHy7dBR9gew8g8AcO4xIAGAgQFggCMAYeBgAEEBYHAN8ADhYONg7QDhYOAC4WPAYgwdkP
IBYOIA4GDtAOJgIBMdAOBloAn_APFSYNBg0GDVQAHhO7Ywsg4C5FAzHQDh9DA5ANDsAtEA4PFS0B
BhAsLxvxAgwdNAweoB4tNB0cDoAOPTQMCABCHQ40DJYoIjQMyyghNC2ZKiI0Do8DAKADBAoAAvUq
AB4IDxUDHzK6LyCbBSACLgktgB8VJC0ewA4dHgiALB6wDiQMFExCOgCzBBAs2QQRDjNFQRQeDA3e
BFEeHA40DvgEgg4UHjQOkBQOgQRANA6gLvEAESQdAAC6DCQUDAYGH5CkACGAAC4ADi8dPrBtChAf
QgQAtgMQDgoAECaWJUAcJgwm_zPQDg8NNg02Gw6ADgYNhgcAsWYNJgwOkA4WDTYLWwSADQYLJg0M
PQxkAaALLQsMLQwLDQ5whA-wAAsmGw0mDoAMDQwLNgwNJgUczyYLDC0L0A4tC-AELVkGHhG8tQ0Q
JukBgkYNDsA_Jg8dtwCBDR8dDQw2DxLoATAcZhyAAEAtC2YthwDAG2YLHQ6AHgscJgwd8UVQFhwN
DCZ5ASA2DW0EYIAOLBYLLBpGYIAOTAssLo89khwOIA4cDsANHGwkPwQLHEcpHzH_LyAcBBYuBgA-
8CsuEwAKDxgEJROUGAQABQBgLvACLh8ZIgEQGRkEEgESAA-DBx8Q2EIFMAYOBk0WMhYeFhAEAAQA
MOAPFb0DXwAdBg1QCA0iA2wEAF4SEB5jAPACFg7QDlYOFg6wDhYOBh4mDgZcAiAeNg4Akg5wDhYO
Fi4GHj4EPwAOBo4DH8D-1w8gHxMPID8ZDyDBRlETDjkOFAgAMAkvDwoAnw8VEw05DRQNUFoAIWAU
Dh8TDjJELWUODh8RDjQKADAELw9bABAfBh1PEQ8VNF8AIDRjXyCCGQ8FAAEQMgUAMgIvHwwADygO
HxF7XwAlPxHiGTAPEz0xAhEMDQAQPAUAEgxeAB88-wUgEmKkCBAavQwiPS6pHwAEAP8DEz0PEw7g
DjMdDA7wAjPwBhOADSYjKmkOBAAhbxlhAB9guBEkMh8PLgcBQQEODx8HAAHmQiQ9DAYAIAMMsgAv
AxzICh9wNT8g8AEuJEkAFUQFABBUUQMhDxIpHRINBgARJK8DEi1mDSINHA4AH5CVAiGAEw4PEw4S
Dh-vAlEfGg4PETAGCQwAgQ8VHxoPFQ8RcTAP_wIjUCIOIy8Te0BQDi8aLxEJADAvGgMJAM8PFSQv
Gg8VLxEPFVAUGSRALw8OLb0NUC0PHy0EwA0vLQwIAANPIgwiBEQXIBB9lAEwPi8PPiKQDx8tDxEO
wA4MCgARDAkAHAsIACEvEwkAHzr_AR8RTPIEIx8PfR1QAQ49Dx-cCiA9DOEAEAPdMP8F4AMMTQ8a
DvAAAz0L8AMDHQvwBRv4AR8RY2AcEE9ZEmQOCU0JDuAGACdPHw0ACRkALxkJMAMgvWVfIOA_Lw8E
DsAengEA1QBTwA4EDxIRABQLGQAhLTsHAB8rQAEfHE5AARNdSQQwXQ8f6wnfPRzwARwdHPADPPAF
HC4DIvAIHxkPIA8SDyADHxoPINAOGQ4EDj8aDsAJACAPFQsAz7APFRkNBA0ADR8aAysDI0E-Ew8g
rwsQsHAFIBAOCQAyDS8PCgCPDxU9DBAMGQxaAB-4B3VfIEAukA4-Dw5ADh0uYA49DkAOPQ4IADMw
Dk0IADM9DnAIAD-wBR0vOR8u-3iIAcBALmAObQ4wDgYPHQbMKBFQKB-AcD1gDg8NAQwOgB1wrS0P
agAeERpqAAAiFQP-E1AdDnAucAYAAwQAYmAOHZAODQcAMAYND04jIR2QfABCQA4doH0AAQoAfywO
QA4N8AdpDB8h-5IcBzEvDw8AB0AfDw8fkABXAg4NEg0HADEdDx8IAC8tDJcIIBGujDQRH2MAEAAO
AiANDAkAMQwNEl4TEhwHAB8sMgMfEXlbH4I-Dz7gDg8fP7sAABk6IR8STzUwLRIdSjUAaEqP0A58
DvADPA7UAiIgLx9MNjAzDrCtBQIJAAEHHxMAMwN-LQwADD8aDFwAInAfHw8gAg4TXAkQsHQCEAS7
BisfEQ0AQA8VHw90OF8fGg0fEZkDIPIb1A8gDx8SDg8g8AINDhIPDw1QDQ4SDg1QDQwOHA1QDRwO
DA1QDxUcDgwLEwAPywIfIcF-4R8jHz-mAWAPDw8fEg1LAgXhAR9cugkgFWaXFQOxExNNQwISHUIC
ESw9Ea8SDRwO4A5cDvAEshghGkoXCScCDhUJJg8fHAkAqAgBLgovBRyGDh8g-3nLCSpjDgQAEG8h
CiJvHwoAD3keIQ8zAP---0xfEBAE8PAxAAsfODEA----------------BVBtPTh9fQ==
:: gfx/4_tbj2_16x16b.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTI4IDIyOjM1OjM5Iixtb2RpZmllZD0iMjAyNS0x
Mi0zMSAxODo0MjozNiIscmV2aXNpb249NV1dbHo0AOpRAACJkQAA8xR7WzBdPXtibXA9cHh1AEMg
EBAE8PAsZmxhZ3M9MCxwYW5feAgAynk9MCx6b29tPTl9LDEA8BYGDxYVRg4VNg4FDxUFBj4FDQUG
LhUNBQ5FDQUOJR0lTSUtDjYOIgACHAAjPgUcANNFDRVNJU01VhVGDgUNHAAnFQ0bABEmNgAkFi42
ADEGDjUcAH8FHj0lTSUNpwA0MhUNFakAUB0BHSUtcQAyDQYNrQDBFh4NDgUNHiUNBQEGKADwAw4F
LREGFR0BHQ4lJg0WFRYNFrsAMR4GDZ4AYA0eFQ0OJQwA8QgOBQElDRUtAQ0lDQEtJg4VBg0WDQ4G
BcsARRYODQ7NAAF9ACEePXwAD9EALRIO0QDwP30OJR0FHVEdDh0WHQEPEzMMAR0FDgYODQEMIwwT
DAENDgUOBQ0BDAMMAwwjAQ0OFR0BEwxDAQ0VDgUdAwwjHAMBDQYOBQ4NAQMcAwwODTEAIxUOMABA
DQEMAbEAAQ8AwBMcAwEtBg4dExwzASoBUAEjDCMMPQARFR8A-wAzDAENHi0BLAMMAxwBDQXdADni
DXENDh0WDQESPxgSAQ3dADACDAgCABQC4AAwAggcEQAC4QBiDAgMGAwY5ABkGAwIHAIM5QAADQAz
Dg0C5QBjAiwCDQEC4wABUgAhEgzkAAA-AGAcAQ0_DQEKADAMAgHrAQAiACEcCA0AXy0BEjwS5gAg
YB8WJU4VTuMA8BMeNQ01DhUNRVcVHSU3BgcGFx0uNwYONgcFHhUHBgcGB0YHLQLwCAcGBzYeFg0V
HQeWHRUmLgYuFh4FDaYHGgBgFi4GLgYHugD-A5YHHR4NF2YHHR4FHXcdDkWNJS8DIfAPBdYFJp8W
Rg6VDjYFnxUFFh4dfxQdPg0cHgQOBA4cAAHxCAweNB4MDRUWDQwOBA40DgwNFg4GDQwUCwAwDgYV
CwAyJA4EIgAAIQATBCIAcwQOFAoJCgQlAEMkDhwJJQBlJA4EDgwOJgA0BA4kSgAgTgRqAA-CABzE
2B8Y2B4YvhIYPjc_BQBAHxYfFwgAUQEFDxYPCgAwMQIuBgDzABIeEhg_Yg4SGG4yDhIYvgMATx7S
HtJ2ABzA3xwT3hMesx8THrMdAwCCMz0zHR4jDTEGAHENIx0eMwUhBwAyDxYlCACxFy8WHRMdHjMH
LxcIABUxBgBPE90T3YAAHP8vwB8S8AkPFYAFDvAHBQ7QDkAOMA8WBcAOBQ8SDsAeUA4QDxbwCA8S
DmAPFgVALkANBQ4QDvASDXAecA0PEgBtABz-XAAfERAPE4ADABOADpAvEaAdHgMdIA0ADRANAAET
DgMNEAMOAANAIw4NEBMADiAOAAEjASADEA1AIfABHUAdAA0wDSMgDRMOEzATMAMeA6ATDiMwHTAD
DjMgDQMOAyABMwEQDQMOEzAxMCMQwAId8BQDDxMAAw4BDgADDhEOEAEDAQAOEQAPEQ4QDgEADgEO
MRAeEB4A8AcBDQFADhABDgEOEAMBAAENEA4QMQ4AEgAhAwApAHAREAMQEQ4ARABBDhABDQYA8A0O
MAEAAQ4DEAEQDhANABEALhABMBMAEQ4AAQ4w9ADQQAEeIA4DAA4BAANADj4AAXQAsQMOEA4ADhEO
IR4AegAADAAAeQBAAQAODZcAfw4RAyEAAQ7oAByxQA8cIAFwASADMANUAPABQA8TAAEAE2AOUAMN
AAEAAxkAEACVASABENIAAK8AgAPwAAMADhAOwADxKwABEA0AExADIANAAQANAxANAAMADSAOIAED
UAEQA2ABEA4wDQABIAFAAyABIAMgAyANAAMwAxADIAFNAAA_AE8BDbANOQId8Ak-FiYONg4WLiY_
Bg4mHgYONh5GLiYOVg4OAPEGFi4GDhYuRi52DgYOBh4WDgYuti4WDAACEAD-GhYeFh62DjYOBg4W
PkYONi4FDjYONh4FDjYeNg5WPnYOBl4WDgY_Ng5WlAAc8AEfEg8WFj4GFR8StgUtDiYVsQfwCl4W
JS6mPhYVFh4WBUYOBh1GBQ4mFTYOhh2qABANkADwACYephU2FSYNJg4VJhUdNtYA4AUtDjYVVj4d
FgUN9gIVTgi-Ng4GHRYFHQ4mFSaVABzwCvYeDxaGHpYOJh72BQ72Ag4mHtYeFg72Eh4uAa8mHvYc
DmYOJg52VgAcYgEAERARAAYA8CMhEBEgEQARADEQMSAhADEQQRAREEEgIRAREGFQISCBEEEgYSBR
IDEQASBBMBEAMSAhICAAkhEQERBREBEQIUIAQBARADFOAAASAAAIAA_QABywHCcMHxAsHkwXLB4G
APAbHB4sLkwHDAcuLD4sFxwuPA4MDhwXDAcMLnwnHAcuTA4cNxwufDcsHpwXGwDQLA48BwwHnB4c
BxwHDAIAYA48DhwXbBgAr0ccDoxHHA4sDkyRAByD8EMWUBZABhUDAJEHFUAGBRYHBhUJABMPFwBS
QQYVMAEYAJEGFREAEQYFDkEEAK8eQQYeIQDRQHEwdwAc0hAHBR8VMAcVDjAHBR4IADIVNwUQACkO
QAgADxgAE59ABwVQBwUO8EKJABzwBoAPFgbADhYFoA4WDgWQDhYOJXAOJgUA-xoWDhYlUA4WDjYV
QA5mJUAOVkUwDkZVIA5GDlUQDkZ1AA5GhRDFMJXwBHEAT-8JETUQDkYFMSUADkYVMSUQZTEVMFUx
BfADegAc8SZAAk8YgGIOYBIFUg5AEgUPFgVSDiASBS0FUg4AEgUdDxUdBVIOEB0sHUUwHSwtBRwF
MB0vFwgAEX0NAKArLQUdBTAdIS01BQABEwANBwA-HQUQlgAcNAYFEAMAdgAPFQYFBgAEAFAeBgUG
JQIANB62BRoF8hVuAAY1HgUuIRAWZQ4FLhAGJTYVDgUeEBYFBjEGFS4QBgUGUQURAGERDhEOBgUT
AEURDgEeFgAjAR4WACIBHhYA7wA2XlYOFQYBTgYOFQ4FwAAc8ApQKgmABwAKCR8PCglgBwUKCQEO
DxcBCglQDAAzHg0OCgAxDRQNCgBgAAoJHRlgTAPwBxUHBgQPFAcMDxUQBgUmFwYFBAwKDAsEC8EX
NgAHOhUGASUWBQAVAJIQCQQQNQAEDAkLAP8NPwwQBAoLUBgPEAAYkAgDEAMIkBQQFIAUDBAEHIkD
HfI6UA4IDxgwHxlQDhgfGBAPGQoHDTAYPxYPGAANCQoNMAgMAQ8XDxYBDBAdUAwfFx8WDBAPFGAc
HxcMEAwLDxZACHwWMAhcGB8UMIcM4AIQBQ8VMAgMABgsEA8ECwBhLAgMAgwCDQDyCSAGCxwYDBIQ
BQQgFgwoDCIQDwQEECwIDBQA-wUADAMFDAgCHBIFAwAFBBAlQiUABV0DHfANNrAWFQagBgUGFQ8W
kCUGFQ6QDxUVBhUOQBUgDQgAUiAFBg0FCwDwGRAFHQYwDQEFBjUNAQZQDREGFQ0BgA0BFQ0BoA0F
HRWQBQ0BDSVgFQ0sCSE1MDgAUAENBhUwNwCfFQ0GQAUGQBUGLQId8DgwBg8WBgUOgBYORQ5QBh51
QAYONYAGDiUPEpAGDhUdBYAOJQAVDnAlIA8VDQ5gDhUwDA0OYBVADA0OUA4FUAwdUAVgLNAcDQMA
PyzQHH0AHPkaEB8WEA4mHlAVEG5ABg4FAQ5VDjAlAYUgFTARECUgFTAODxIwBYAODdADACEPFQcA
EAwDAD8NDFDxAB3xDlVgJQYPFmUgFRYuVQEQBRY_RREQBQYeBgUOFQEVCwBBFQ4FEQoAG04bACIW
DhsAoSAFBj41ETAFBg4bAPABBRFABQYVDgUxUAUGLiURYCgAIBGAKwBPsAUBcKAAHORgByoJoAop
sAoJ0BoHCgsA8BcKCbAJChkKCbAZwAcaCZAHCllgCglQCglQCRAHEAkQCVAJIAoJIBIArwApCgAK
CWApECl5Ax2Q8A0G0AcfFrAG8g-wDJAGHgAVUA4GAA4FDhVwFQ4VEAWAJXAHFg4lDtcGMBAlAI8H
-wkwFXAGUA5wBlAFcA4FMBWAFRAVoAUOFZD0AB3wFhOQHxMAEw8cAwATQAMOAw8TAw4jDhMgAw5T
HSMNEA0jHQMNAR3gDGADAQ0BLRFUCwESALAtAw4NAB0DDgMdI64M-yoNAA0zDQMdAR0TDRANEw0B
DSENEw0wDQEdIQ0AHTAtABEfFQEAAVANIDwBsAUMcAUwJYAVAEUABSCwAByQIB8TEB4DDmAO5gwA
twDwDA5ADgMNAw4BDSMuIA4NIx4TDgENAw4gDhMOAQsA8Q8jDgAODQMeAw0DHjMeDSMOEx4BDhMO
AA4jLgMOIR7RDAExACABDgUAICABDQDwAw0DDg0jDgEQAR4jHiMeARAOEyUAIB4DCwDxBgMNEw4h
Lg8VIA4jDhEeESwABQAOAywAbxAMFSAOwM8AHP8r8BYmFYA2BR8WBWA2PgVQNj4VUEYuFVBGHkUw
Jj4BBRYOBSAFHiUBBRYeBSBFARUeJTAlEVWQATXwI2kAHUAXJgWQaQDwAnAOBQYOBS4FUA4WFS4V
QA4mYxJwQA42BR4VAXIIIAUedwASMHYAIQUOdwD-AC4VMCURNQEFkAEVAQXwInsAHPEKCQQPEpAO
BBkEDxUBBQYFNgUBDQQZBA0BdQgANQ6QDgYAbw0BBRYVFiAACy8FJiAACj4mFQYgAB8JsgAcl-kA
9AAPEh8VHwQAIw8S6gszERAVAgAvBQYDAAABFwADHgALBQAOAwATFQIAAlgAcBEADh8VHh0CAF8O
9AD5AGgBI-MOCRQOkA4ULgEVJgUGBQEuEBF1ETAVcBUwBQZwBQYGABUVBQBEBQZwFQ8A8QAVMBEF
JgUGFREQLgF1AS5IAB8JQQEikbA5gCk0YBkkDzkB8AlAGRQuDxURQAkUDQ4wFTAJBB0BQAUGMAmw
AUBABQYgCQAhJTAJAPICDhAFBgUwBQYACQQOMAUGBSALAGBABQYFEBUKAMFQJQABBQkEDg1gJRFB
AFEWQAUBHUIAQCYVAQ2wAE8wRQENsgAe4zkqGXAZEQoBCSAFQAkhCADxHREqCSAPFTAPGXkKCQoJ
BxBOOT4XAA4FDxcVDhkOHRUOCQAFMAUeBTAFDiARxgH1AwUQAR8VATABHAEgAQwNBQwBEAcAFBUG
ADEgARwiAG9AEVAR8BSnABzzAfAFBwkPGQWgFw4FEBFwCQ5xAGAVDQoOBQDDFfAKAVAJDg8XAAEN
DAUNAVAKDgwQAR0BIAkgGTEA0jBpDgVgChEKKQ4FYDoSADEKEQpGAAAlACQhCUUAYxAZEQkODEYA
JBBJIQAgIC4zAA_zAB3hErkgGR8ZGR4ZHhkQGhECAAUIACEZEQIAMRAZGgIA8AgADhkOCQ45DgkO
GR4JThlOCQ4AHh8XBbcY8AseEA4FIQUeBSEFDiABFQ8VARUBFQwBMAEFDVkBAAYAzzABLAEQASwB
QCEwIVcGHfAMUB8ZgAkaOR5QGRopHgUhIAkOIQoeBQEvFQEQCwAAVAFgAQUNDxUBqgAgHgV7ABcQ
KwBEGR4FQAgAAxcAAigAFCxAABINqQAADQAnHg0-ABAwdgAvsB6rCB3yPEAXBgcWgAZVDxaAXpAP
GRkdDxSQDRkdDJAGNQaQBi8cDwwOkAcfHA8MDxAPHJAHCw8MCwoOkAcqDxAOkAcKCwoIDpAHCAoL
CA6QBg4AzwYIChgOoA4YDsAeYIwAHPEEDxLfDx8SDw8JDnkOCQ4fEikECQIAgDkNDxUJBAlkDAD-
LRxUHVQcXQcKXQwPGUkLCgkLSXsZazwdDBsMHUxdHF0MDVQdVB0EOTQ5BB00WTQNDD0EOQQ9LD00
PVx9PI8AHODwZwfQBw8WBbAHBg4VkDcJADwJYEVQNmVAJo4E7x8VJVAWAAQfEgAVkAQd7QAdH3Bd
ABk5wBQNAwBfBB3ABB02Cx3yAVA3kHdQNxpXMBcqFyoHCiAHAEAZEBcaCAAiKQAIADFJFwoPADAK
GTcHAFAaCQ8ZJwkAUyoJDgAHCQDAEAoJKik6CQ4gDgkKCADPQA4pKhkeUB45HpA_lgAdgBCXQAcG
lyAHxAzwCBdmBxAHHgYHdgcgFwAHFk4GB1CWUEY_BgDzBSY_JlAHdgdQBxZuUAcGh0AHFgcGAgBF
MAcGDgIAT0Ce8AGCABzwLDAKAA4HDgIACmAZBxgvGBlgBygdDg1gDigdHg0CYAItCBcCUAcKDxUO
DQgdAgwKByAHChkMMgwZCgcAHgH-GnALCSoJC5ALCQoZsCkKsAoZGpAaCQAJGgdQBxoJIAsJGicq
CQtQC1kL1REe8CJADxUVLoAHDhUuB3AFDhUuBXAHBScVB4AHAAUABQdwBwUBByAVB0AHBQEXAAEQ
FQcgCgAAWhbQFQcQBwEXECIQAQUHABUA-yMSLxgiFRcBAhcNCA04DQgFFwENB20oBRcFHRg9Bx0C
BQcAFw8OHUgXAgcQBwUHnAcgt3ERHfAFMAUWBQYlUAUGbxYlIAVeBS4lED4GEWAFDhUPEwAIAPAW
BQEOBS4VDQAFDhEFDhURBQ5FDgEGAQUBBQEGASUNJREVAQUBFa8OgA4BpQ0lDrUBJgBwFRFFAdUR
JQgA8AAR1REVDSUNNQ0VEQAtBR2rGy8FEdsIHfMBMA8VXxIPFWAODxIfFg8SDwQAwA5QDR8WDQwN
DC1AAQcAkE0OATABDg0MXQgA8AUeLR4NHgEOEA4RfhE8IR4VHiENHJgMgAUOIQ0BDQ4N8wtQER4R
DQ4NAPMBHgEtES0BHQ4dDgENHB0cDQsA-whcDQENHgEeAQ4NPB0BHgEAMQ5NDiEgsWYBHfECYA8S
BrAIDxgEBgewDgkWB7AEAP9AABawBAAWAAeQDxQABwYABgcQBCkEEA0XEAYHID0EAA0HEAYHMAQN
BB0EDQAEKSQQDQQNBA0ZBE0gXQQNGRQwDTQZNA0wAi1UHUACfQJgcpgHHfACEBYnZjCvFwZQBAYF
BAYFFHBSD3cGBQ4EcA4HCQAfBwkAGR8GCQADA2IAb1AWVzYwvj0BHvEWBwnAChAKoDkPGQSAGRoZ
DgRgGRcaCR4EUAkKFwopDgRQCSoJChAAMwcKCREA-xYZLgRAKQoJChkeFDBpHiQgCQo3Oj4ADipJ
PiQOCimOFABOhHAu9AQd-zIgvxYAXgUOBQ5FHqUuJS4VPxU1Pj1VHxIFDiUuFTxFHCU9BQ0MRT11
DRxVLBU9LAV9MD0QEdAd0C3QDQXQFdAVUDcCHvAiFoAHMAYFMAZABg4QDg8VEA4GUA4FDTUOBQ5g
DQUXDhUNcAUXFg4VUAcVByYOFR4HEGQh8AAOJg4VDQVQFS4lcA5VDmAxAEANBQ5QQwD-AA0QDgZA
BjAOBTAHgAfwGZAAHNBnBmcGB1YPFgdmB1YFBQBgDgdWBWYFDQAiVg4VACBWBTcV7iUmBQYlJwZn
BjcmDgdWAwAXBQkAnwUHJjUGHkUGLo0AHEDnBgfGSAYVtQUAMRVnBjYgchUnBgcWDxYMACAXBhoB
AgsAE0YJAC8HVgkABkoGXgcVVgAvx-aZBh3gpwZH1hcmdQcmBxYlNyXyBiUVd5kAIQYXCwAQBQsA
QQcGFwUNADIXBgcCABQFHAAVRhkAEDYlFATLACQWDuMAMhYOBqoAQAclFxZlACAWB3IATyZ39gRJ
AR-wBQa3BgUHFpcGDxYFByZ3Bg4VBzZXKiJABQdGNwgAQRUHVhcQAEEOBQd2CAAxFQd2DwBTDgUH
VhUSACNGNRIAITZVEAAhJnUOACAWlVwBX7UOBQblmgAfL9YFAwAUD10AHvAy8BMvGCAeAlAOKA4A
DgcYAjAOCBcuKB4CIA4IFz4IHhIgDih_AiACDhhOAg4SMAIOGA4CDgIOElACDggeAg4ScAIGAK_Q
Eg4SsCLQAvAYfgAc8RaQIQAJkEEJQKEggQUxAKEFIQARFxVxACEXBQEFURAhNWEQIQUBDAD-AjEF
AQVhENEQ0SCxMLFAkXBRRgQdkDAnCB8YEmAnL90XMRJQNwgA8BMCUAcPDicIDxgIDgJABw8OBw0H
HQINCA4CMAcIDQcdCA0CDABxFwgHDQgNCAwA8hcHDRcIBwgOAg0OAjANCA0XCB4CDQgCMAcYBy4I
AhgCMA0OGAcOCEQA-xAIDhgNCB4YDgJAAg4YHRgOAlACHhgdCA4CUBJeEoAywgAdn-DOGsAaB8AK
FzgAHf8TbQnwAAmwCfABCRqwCSqACQAqF3AJEBoXCoAJGgcKF5AaN1IAHf8eXAkqkBkKEAqAOidw
KkdwGieQCQonoAoAFyAaUAkKAAcgKlAKABcQOlAaFxA6XQAd8BMeGoAZABqQCRqgCdAJ0AkK0AkK
8A0KcBcKIAkKYAcKCTAJBgCfwAcJUAlgCmAJbBQe8A0XCRqwGQoHoA8ZDxgfGQ8YoA4JGgkODxlQ
CgcOTAfRCQ4JQBoNCjcKDRkwGQgAMxpACRoAQQcKUA0vAO_gDh0ODaAHChmwGgnwF4MAHeAZDxmQ
GgAfGAAZYAkKB_4PMRpQGVgAcAcKQA8ZAA6ZAfMACQ5gDgkKJxoJDlAOCRonEACRBxoJDgANQAoH
LwAgGVAFAM8OBwoJYBkAHgAakA3PBh7wCGAC0AIPGAKwAg4PGQ4CkAIODQkNDgJwCAAQCgoAEFAK
ABAqCgAQMAoAMBoHGgwAERAMABcnDAAlBxokABUqOAAVCkwAEg1cABAOaQBfAtAC8Ag0AR0fB6gA
ETUKBwqGACcKJwwALwcKlAAND78EIBAgnwHwBSlgCSoJFA8SQAcAGQcKKRQOAAcA-RxQBxopFA4K
GRIQCwAyEBkQIADwCRAJAAkAGSoZFA4ACRAJEBkqFA4QBCAZADsAQBSABA5gGf8DsBoZwAQO0BmQ
GicqGUAZOjkUMAof8AsG0AcGwBcGDxawFwYOcAggFwYOIAgwDxggBw8mQCAPGDAwDQAbEbASDhAH
MAcABgUcHw0AMAAHMGoeQA8QFQ0OAPAQBiAnBhUHDgULDicANw4FBwYeCw43Fi4XBl4WQBcWDtgN
-wQXFRYFBlAHBhUQFRZwBgUQBQZArwAckPA0MYABDxBsHn0YMQxnHIUYMQx3DAgAf3wOAXAx8FYy
Ah7xAQHQAQ8QAbABDgwOsA4MBwwFAI8BoAwXDAGQAQYAAhOgBQARBzIAEA48AE8B0AGAegAdNBIO
AgIANVABAgIAUDAPFQ8S0yoBAgAAWSzxEQENDxINHEUcDQwFDB0MDWwdAQ0BAK1ABgUNAAUAAYAV
BwAykAUNBgCfwAYFDcAFDfAekAAc8AdQBhcGsAYXBqAPFQYXBg6ADgUGFwYFFAvwGQY3BgUOQA4F
BlcGBQ4gDgUGdwYFDgAOBQaXBgUOFrcW9xAWtxYOBbYVAG_1DiC_8AILAR1gBz8VoA41dAAXNnIA
ERVxACAARm8AgNcGBXcmN1YncgBhFwYgFQYnABwgBwaQAGM3FgcWBTChABNAPwARYE0AX4AONQ4g
Qg8fAvwAKnAOCAAPDAEGER4IANAeFQaXBhUWNwYVBjcWFQrfBvcGFrcWFbYVHrUeEBcBIMAGPxWQ
HjUeYA4VNhV1AFAWNxYFDugAMwc2B38AQAcWEBYMABAQDAA-BjAGDAACAyQAFSA6ABMwTAARQFoA
j2AeNR6QPvAGvBEfDykCDTMnFieEACAXBi0AAjcCIicGvwEADABkBwYFHgUGngACLAABRAAApAB-
DmAOUA7wRJgAHBBQNgH-ISUuYA5lHkAOhR4gDhUWVS4QDhUWZR4ADrU_tT61TpU_AA6VLhAedT4g
LjVOQJ5gftYTH-AI8AYxgCE-EyFAER4zHhEgAR4TPxwTHgEYKlEdNx0DDjAdMA13DV4qCggAJQEA
JACREAEeEz0THgEgRQCPQCE_IYAx8BaKABzwCGARsFGAET8TEWARDjMOEUABHgM-HAMe4BEzAw03
rB1BAw1XDXEADwoACRUgMgCRMAEeAz0DHgFAUwCPYBE_EYBRsBECFh0AnyRACikKAJgPYQUACikK
EAoAQQopCiAJAEEpCiAKCQBRGQogCgkKAFEJCiAKGQoAQQogCikJADIgCikmAA9MADYPKAcd8Ajn
BQfVAQcFIQU3BSEFAQcFEScPFiYHEQsA8AEBByYHDiYHAQUBBxU2Dgc2EgByBQcmHgUmDgsAcBYe
BR4GHhULAHAGHgcGBS4XKwBzBg4HJicOBwsAEUYgAGEBBg4FNh5LACAFET8EEi5jAFEhBQcFF3kA
T9UBBeFBMB4x1g4BAgATAAQAIQYOkxQjBQAEAAARAAB1AAAlABAHBgBCBgUBBVMNIAEF0RNEAQ4A
Bj8AKAYOOwA0AAUWNgACQAABPAAUAUAAMx4BBToAEAcIADYGDhE5AAA6HwJvAAECABYFOwAAAgAS
IXcAA1cACHcAAggALwb_FxUd8wCWDxdPFgblDnVhBiUHBjXxAIElFkUhBQEOheMAIR6FYwBDFQ8S
ddQAQh0FDVVzACEtBbYzAs8AUAVdBQ0OjQCCABUtBwYFHQ7IACAFLcIrEwUxAJ8lHQYXNgHt8QCx
AR6IPxefFvUA8QCXAQAIAARXAQAGAAGOAQJcAQIIAAEXAQUEABcVlgFWBwEOIQU9ACgRB5QBKQAO
OABaBQAFDgECABsFAgBf9gD-EgDWAB7yCw8WHxdfFg8XXxblDmF1HgEHAQcANQcGDxIVMQFxADUW
DRUOAHMAMTUdJdAAQQGVDgWDACGVEQ4AEAE0C0EHDmUNqAAgAAUKAAExADABDiWHAREVSQC-DgUd
Fi0FZn0F7fGOEh3xHFAykBI4ElASGD4YEjACCB45HggCIAIIDhk6GQ4IAhACCA4JCjcKCQ4IAgAM
ABBXDAAfEgoACicCADYAFRBMABMgXgARMGwAX1ASOBKQ6w8f8AYHErASGBJwEhgeGBJQAggeGR4I
AkBjABAaYwAzMAIIkA4CxQAIhQAEDAAXICQAFTA6ABNATAARUFoAj3ASGBKwEvAHngAcQUBqcAoM
JsAaUAoJCjkKCRowCpmQBf9JHxk5HhkKEBkOBwYOGQ4GBw4ZEAkOBxE5EQcOCQAZCgYRChkKEQYK
CQ4pKjkqLmkeKQ4HGg45QgkOBw8PDw4KLhkKKAkKDgodCk4JOg46EJ4qEC8UTnBMoKAAHPAPUAcK
0AoJ0A4CwD6gDjgCgA5YAmAOCFIIAkAOCAJRHAGwDhgCEQcKEQ4YAhALACsKCQsAEyApAP8BQA4I
XggCYA5YAoAOOAKgMiUHHfAjMHxQHC8QHC4cIAweFgEeAQcGHgwQDA4XFhEXFg4MAAwOBgcRBhEH
ERYOHA4WEAYRBhAKAPABRhFGDhwONgEeATYODC4WASsy8AUWLgFOMU4RPlE_IQ4BHjweAQ4RALcr
EBwKAJ8QQT5BILFQcTCfACBAHxA8Hp8AUREOHA4RngAxMR4xnAD3AAEHFjEHFgEOHA4nFhEnFggA
AbYAAAUA-yAODB4WEQYRFhEGHgEeJgEeASYeIU4RTjE_MT4RABEeEQ8OCBEeERAxDgENCAEeIaQA
IvAAfxhQLg8ODg0ODT4gDgIuCADwJQIOEAIPFQJ_AgwCAA4CAQwSPhIMAQIeAhEcAh4CHBECHgYX
ARwSHAEXBh4IFxEyERcIDgKME-AVDhIOCA0YDhIuCA4iHgguIi4CEQI_Ag4iDgIOCBEILgIOEgkK
tQ2hGC4CDiIPGRkCDh8AnxALGaILEBuCK7sAKdRODQ4NXhAOAp4CDgAOvgAfHr0AEhESvAATIrsA
gB4CEQIILiJOsgDhEgASDgIuGC4CCgkAIg6vAN8ZDxkJC5IZCwAZG3IbDQkd8CIAI3AjICMAMwAj
QB8TEx4THmAIDw4_DQhgMx4zUJNQARMyEwFgEQIYAhFQAyAxIAMgvTVgEyAOAxAz_jT-Ch5THmAO
Az4DDoBecBMBPgETQBMOADEADhOIAB3-ABATcBMwE3ATQBMAMwATUIwAAhNzigD-G4ADMQNwMx4z
QAMeAz4DHgMQEw4AfgAOEwADIAE_ASADQBMxE2ATDjAOEy0OHcBwU4BzYDMRExEAEyAHAPABAw8T
EwAjDlMeAA4DABMOD540MAYgE-oo8AgNBAcgBxAjAA4TDg0EUBMOEA4DHh0wE4EpQB4NBCB-AKAD
Hh0EECMOEA4TCQCADmMuHQQgDgMCAEMuHRQwCABPUE40MCwGHmFTMBMgcxCeAAGuABAOoAAACgCA
IBMOEw5TDiC5KQSuABEerQBGBBAHIKYAETCmAEEQEw5ApgAhACO4AGAdBAAOcy6sAAGmAEM_HRQg
CAA-QF40TAEd8CFgEqASEBKgGBAIAsACGLAYCQgCkAgZCAkIYAIIKQoJKAIwAhkKCSoJCAkIMAgJ
KgexE0MICQIQDADxAgcKCRgQCSonCgcaGQgQCRpHIAAQMAkAEBkxAO8aFyoJCFAICTopcAhJCH0S
HfAdIA8TAw8RsB8TEy8RcBMPE0MPEWAjDxMzDh8RQCMOIw4jDTAzDgMOMw4wQy7aOAAeAfAAIx4j
MB5jDhMwDnMeA0AuciufcC4jHuAe4B7w7wId8xQwNw8WB3AXUQ4HQAeRBzAHARcRIBEOIAcRF1AR
BxAHIXABDgYANQ4RkAUA-weAAQ4gDhFwDjAOIVABDkAeIRABHnBeYw4ewFAPFhYOoA4HJgWADt0M
8ApgBV4lQLUgDiY_Bh4lAA4GBwYOPxUHBh4lCgBhHSINBwYOCwCgDQIIDw4SBxYOFQ4AMRIMCAwA
UQ4WDg1CCQD-CSYHDSIXBg4lHiZHFg41HnYONQAFjiUwtR0BHWBQBcAPFweLIfIGYB4-FQENFVAO
DQ8YBwgsDQVQBQ0MCQDwA51gET0RcAU_JUAHDi01LQcOAI8-ET2WPwDiP8kXLgUNFR0VDRUHLhUJ
APACAA1VDQAVDQANBQB9AAUNIA3nOU8NARANpwApQA8VAT2nAFEvGAgHDKcAEiwJAA_nAG-wDPAC
LlAOUCgOEB6AGCAe8AwuAB4AHiAeAA4YPggA-wYQKC6gKB5gDhAuGA6QDkgO0BgO0BjrLB6QgAkg
GSApIAkKSiSDCQAJKgkACQoIAHA6GQoZKgkgDADwDhkqCUAJGgkQCRoJYBkwGWAZwAkaCTAZQAkK
GQAZOgAQQBwAQRkqCVA6AEAqCTAJOgAwGgkwHAAgKUA9GT8J0AmwDB3wC1A1kBU-FhVQFQ42LhUw
BQ4XRh4FIAUOJ1YeuRYwF2YegAw0ph4VBAAwHoYuEgAQhh8A-wUeZi4FIAUuJj4FMBV_FVAVPhWQ
Nd0LHeBgCQjACSiwCRgPGLA1sKEXEKBtEyEFkAYAEIDVEzEOFWBWA2A1cCYOFZDOMUCABQEWBA3-
AmAlAQYRJVA1AAE1UCUQAQAl8zYe8TBgCtAKBwrACgcKcBoQCicKEBoQChcqJyoXCgAKNwonCjcK
EAqnCjAKhwpQCmcKcApHCnAKZwpQCjcKNwowCjcmAFEQCjcKIAwArwcqQCoHChAagBqKAh1gQGdQ
pzAXOCfwAQYeFwYHIAcODxIOFg4dDiYKDvEXDQENFg0RDQ4WBwAHDRENFjENFg4AByEmQQYeAAch
DgYHQQceAAd6EIEGByEHBh4QBy4OEAZSICAOIJ0lIQYHAgAgDjBbJwFxJ1EOQFaQBzIAf6AOBw4H
8AnBJB8AwhcSsMcXAAQAEJAFAAA3OOAOHxdwDxJFHg8XIB8SEFIQoiUHBg8XAA0-FQ1gEFAWHi0M
TQkAgBUOAA0MHQUNgxDwDQUNFQAdDG0FDQUQDTwNLC0FIC0MADwdBQAODxcnAH8QLC0VHXBtggMe
IOAH-RkAlygAoykxBaAHqClBBg4lgFYC8AQHBg5FYAcGDlVQBwYOZUAHBg51iCj-BYUgBwYOlRAH
Bg6lAAcGDrUHBg7FeQAcEQF0IhARwwIA7gwfNQQAAyMORQQAMDUPFQYAHw0FAAIfHgQACx8GBAAE
bw41HRE1HYc2HWAPFeAFDtDKARDApQEQsI8FYKAlDQUOkDckEICZRmBwVQ0FDmCaEPACUHUNBQ5A
hQ0FDjCVDQUOIKVKQRC1RRI-xQ0FxT8d8ALwA4dQBw8cFw4HHgwBBzAHDu48ZA4MEQwHEAwAYD8Q
DgcAB7gn8AFhDQEABx4MBx0RHQEMDgEQHgDwAAcNAQ0MAQcOATAHDA4cHQoAUFAMFwwNCQD-BHAM
Fw0MDgGQDAcMDQGwDA0B8CefABzwBTA6gEoJSjAaCR8QGgkKCUoAGQEOKR_RCRoeCRoECREetx7w
AQ4BOQQRCgkaCR4RCRQZFAkqMPAnChEEGRRJAlkUABQqMioUIBp5KhAaCQQKNAoECRoAGgkUCiAK
ABQJKgkEIAoACjAECRoJkAoA5SZPCjAasKcAHJDABQawBQYHBaBzGBGQuBjQcAUWFwYFYAUWJxYF
UEsa8AMFQAUWN2YFAAanBgUABRAFRiclABgGBgAiFwaCBQEGAG8GBZAFBgWKAB3wJTCnMAdGTxYF
ARAHNl4VAQAHJm4lAVcWFwY1AQdOFS41AQc_FS5FAQcuFS5VAQceFS4lASVjSFAuNQElAQcAEA4I
ADAFLjVJSEABBi41-DcA9gH-ATUOJQEFARAGDjUONREgJYEqDB3yE2AXwDegFxYXgBcGHxYGF2AX
Bj4GF0AXBl4GFyAXBn4GFxAGAFHeYDWwPjgECwUAT8AHBWB0AB-wCwcVB6AHBRAFB4AHBTAFB2AH
BVAFB0AHBXAF9CsRkOUrP7AFByoAFw_DAB0QGOAj8DwIDiAOCCAIbggQAh4ALgIOMh4QIg6SMA4S
DxIHDB0HDA0CEAgOEh0cFRwdAB4CLXUNABIADQUdVR0wDQUPFg0fFSUtQAUPFh8VXQUIAPAIDxVt
BUAVAV0VMBsFYQUwGwARMBEwGxAGAG8LIB8UMBqZCR9gHxgIEBgOqgCRMAIeAAhuCDASqAB2MAIO
kgAILqkAcAAOAgASDQWrAF8wLXUNMKcAEd9ACwVhBUAbETARQBsAoAAhQDAYoBiyIvAXaCAOCAAO
AihOCCAeAgiOQC5yDjCyAD8WDxIVBwwVBwwFDR8WJR2dAP8UBQ0LBSAtVR0LBSA9NS1QjWARXXBx
cDEQEYAREBGQHxQQGiCoDR5hGAUPFgBYBwDyDhAIAgUOCH8YDgAIHQUODXIOAB0ABQ6CDjAFDgIF
iwDwDA4wDxIlHBUcFTArhUArVRtAOzUbYItwa4BRkIMABAQAD4sAIvUHKA8YEAgeQBh_KCAuQg4Q
HhAegiAfFk8CUQU-FgUCBwH-KBULBRANBQsNdTAVCx1VDTAlO00wDVU9QA8VjTEADxQfFT2BDxQA
HxVRMBEgGlGAGiARkBogHxRBIR7QBA8WBZAYEA4VUA8UENMm8h0NAA4PEiAhDxQQDQANDxI1ADEg
AggMVRFACA0MZQFADSxFDgUBMAgCHwwMNQoA-y0MCwwlDA4FIQAPFQ0SLAUcDgUxCh0CDBscDhUA
IQAdEgwLHBUMAAoRAAINIkwAGhEQUhwAGhAfFBBCEBqwAB7kU1WAdWACFQ8VVUAPGAJRCTJFQB8N
APYDBR8SNTAfGAIvEg8VHxIlERAvJQD-DB8SFSEALxgCHxIPFU8SMQIPGDIfEmUBAFIOZRgYHbDw
EQ8YCNACHhAYLiUW8AFOIjAIDghOQhAeAi4yPxYFHg3wHhItRTAOAh0lBwwvEgARAAsCJRsMJQsA
IVslBwwLAA8UEUslCwwbAAoAETsVOykBn6sACgEgW0AK0IwAHfARIQ8YCCBYQAIeAA5oUAIOOA4I
HgggGB4YbhAILgguQh75A-8SLnIPEjAeIm0wDhJNBwwtIA0CFY8WACENpQ8UMY0QC0BdqTEeIPAj
AwHwBh5IEkAYADguEjAeAhhOIkAITkJAHgcV-yYSFQ0fFgARDkINBQcPDA0VDxQRDgIVDxYdBR8M
HQAPFAABHSUfFk0gAS01TBAPFBE9ZRALMIYAH-ACMEYFDxVwBg8WJR4FDxVQBg5QOGMFDUAGBVAH
AGAGBQ1ABQ0OAHAgxgUdNg4VyguAHg0FDSYOBRHrHLEGDQUdFg4FMQYuBRYAMDEWHhIAQh4FERYS
ABQFEgADIwAAfRwRNgoAPyB_PREFHlAmBQ8VkC0sER66ADAOBRCxABBgjB6PHWAGBdAFDbCoAHHx
APAFrxUgHqUQDsUQDkUPFmkQ4AAOVQYVBg0FBgUADkUNCQAAAwCQAA5VDQYFDQYNCwAyJQ0WCwAA
DQBSNR0WFQYuABAduiQQJSAA4DYdNQAONS1lAA4lRg1FGwAhRR4YAC81DpMPHfEU8AD-FQD1Ag8W
FR4VDmUOBgUeBhUGDhUGFR4GLgYeBh4FBhUgNQIHSgQGAAYOAGEuBl4GfgaxMwHWPQAKAN8eFQ4V
LiUO9Rv-FQDwkQAfoK8VQKUeIMUOEMU2TQD1AEAVDVUOhUUBJAEACwAAHQEgHQaJMAIMAAAZAAHr
HCEGBQIAIA0GGwAAAA4gBgUxAEE1DRUdIAAwRQ0mCB3-AGUdRQ4AHjVGDRUOEA5FLTcBH2AgnxUw
HpV1AfAGDlEOJR4lLxYWLSUeRQ0WDUUeRR0GBgBgPUUeVR1VBAAAawAgHTVAOhCejCNRtQ4QDiWI
AFAQDjU9NQ4AMB0mDQ4AXxUdFj0VjAAecVAYPxhgDgIWLiAOQAkAcGIgHgIeAh8QBzAMIA62CJAN
FRwVDEASDxYIB-8ZAhULHRsVHTAdFRsVPUAdNT1gfTARABFdASAPFMEAGgAhYCEKwBHwERpBHpAY
oB4AAg4AGD5HCcICGC4SDjAiGB5SQD6MADBAHhKYB-8eDTACDQ8WBR1FDTANCxUtJR0wDRWNQBUL
bWAVCxEtgBUhDYBRgA8UQZAKIBHg3gYe8AFQKC8YUA4SKB4SDkASGC5CLAkRLoAA-y0NEB4CAB4S
DRUcDRAOAhANLxYNRVALJR0lDVAVfQtAFQtdG1AVUUARAIEgDxRBMCEgCgAhUBHQEeAa8AELASUh
KC4LAQCOAIEwIigeQkBOAqcIIUAuRwoB_Uj-Eg1VQB0FCy01QB0VC11QHRUbPWAdJS2QMaAxsCHQ
EeAfFOcSHfASMEgvGDAOECgeQiAeAC4SXxcfFhAiDR8XbQUeAA8SHQUdTwb-KBUQDhAPEhUMJQ8M
JTABTDUHCx0QAVwlCwwdrxUcQBGMQDFcQHFgIRAhcA8UARAhgAoQChHACrDPJh-wF6AfFBAfFaAR
EA4wAg8YQBEQHiACDRANEEEeIAIAAg0PFABRDjACfkD-QFUNGAARABFFHxYNKDFFHAUPEg0YMUUM
BRsdCDA1HAUrDQgwCxUcBTsNCBAMBRscBQsPDAcbDQgADCULHCsKCxINDBUQKwoHKyIVMCsKGxKv
BR7xGBAfGEBIQB4QeA5AHngeAD5obhAuKE4CMCJOMhAfFi8Scg0AHxYFLT4BAm8LQAUABS0NDP8Q
CwUQBR0vFV0LBSAqbQAVACp9EAUqMQBBEBpRAEEACokAHfMOAB8Y0B4QeDAumDAOaD4IMEhuEB4Y
TkIQToIwLxJiC0ENIC8WNA3-GhAbFR8VDTUtEAsFDRqNEAsFGo0RAAsaEAFdIQAaDxRBQBEACgAJ
QUAZWAQd8AUfEBB8MC4sXgxADgyODCDOED4VB9Y08A4NFRAeNR0VHRUwBQ2VMBUNRR8VFTAlPRsl
MAUARZ5I8gsADhULRQxgDhteYBsOMB5QGx4wHkAbAB4wHqgND5kBHfAHQFZwFlEWQAaRBSAGsQUQ
BrEFAAbRBQMAM1EQUQUA-wfRFdEFAAWxBRAFsQUgBZEFQBVRFXBVPQQdkTAXFpAHBgUgFgEPwAZQ
BgAXQAZABgUAFzBCJAaQBABwB0AGcAdQBiQAYGAWIAUHBh4LYHAWBwYQAQoAH9AGAAIPyywewRcK
UAoXMBcaMBoXMIMXEED1R-8BCvA2CgnAKgmwFxqwFwrwG1cAHHAADxU1TxYlzDdQJR8WJh0CByE1
TX4GNjYNRZMGIg02kwYQXQ4AIgUNHAA1JV0lBgAEFAAiBX27BhE2SwAjJU0wABQtPgAPWwcd8AtA
XxVATg8WRU4VDg2FDiUODRVeJQ4VDhUOUYJJYA4NBQ5xDq0IDwYACCMOBS8A-wIVDiVeJQ4lDpUO
FU5VTkBeQC0BH8AlPxZFDxUAHjUfFlXZCCA9NQUS8AENRQ5FHlUedR4VHkUNBQ01BgDQHQYNhQ0G
LQYNdR0GHRQAIDUNCQjyBxUeJQ01HlUeRQ4VLUUONQ4lPSUOFR6zCT9VLSUgAR5BAN8VEHsI40U-
FkUe1R4VnhU_lS4AuAEAXQiCFX4VDhAudS4OAEC1DgAOjQiANR0WHTUeRU2YAD8WHUUsFR7-OwUf
GBgeAA8WBVAOWA4NBUAOeA4FMA4IDmgOBTA_WB4wXigeAjACjgIFMAUSXgIVMCVSJRB-FRJMQBUS
BRIFgAUSBRKQIcAR0B8U1S8dEEB6AHCADlgOYA54ZRAAdABQFRAFPlgYGgB3ACoFIHgAsCBvFRJN
QCUSBRKAfQAA9hAv8CV1ABwA6BDwA2hABQ4AWC8YMBUofSAVDggdYn4AIg0CggVRIAgVDgJvETAg
CA3gKPIOIB0LBRtlMA8VATs1GyAaEXswCkFLFSAhEAE7JSBGB48JQZAJMaAJ4I0AHPEMGNAIDxgA
DgigPiAFDxZwDgIYEAUNYAUNKA4ACABRCB4CDxIKACAOEp8GcAVgBQ0CJRwHAP8oBwwFHxQFDxJg
BQ0cFREbQA8UBQ0LJREbADEKFQ0bIRtBAAsVGxErEUA7IQshQA8VK0FQGQArIW4UHcAAGNAPGBjA
DgAesDikACBQCJYAEhA2DkIeAgUACgAAvgaQBQ1QAgUNJRwVBwDwAAwfFBUPEgVQCwUNDAURKwgA
EhUHAIEbESsAERAPFJ8AMEEKAKAAABEAjxUrUUAZEBsxFgkd8AcYAFhgCA8YKB4YDmAobkAYLlJA
CB4SGQrwDxVAMi0cFUA9BQ8WHSVPFT0VDxY9HxUPFgUPFU0VPwcA8gEVEE1VUAFdAXCBYBEwMVAR
AgBvYB8UUBsghwAgMA8YOIYALxh_hgAGMD8VAAkA8BFNDxUfFg8VAC0lLxYdABsgHVUdYAFtcHFw
ETAhYBFAEQQAX3AfFEAakRYdEBDOE-IGOAAFDkAIBQ4IPxgIBQ4wGAUOHRIdCQAgBwyTACAFDqla
AOIC8AgOQA2VUAt1C1AbBQs1G1ArBQsVK2B7cOsC8AQhYAoAcUAKECEgEUAKACEwETAKmxEQQAgA
PwlwGe0HHRQYmgAkMBiaACNADZoAJkANmgATUJkAH1CYAAOySyFgCoFACiARIBGcACAwCiMRb0AZ
IAoQCdcoHVD2APAiBgkIgPAlDxVADvAnmlkfAQNNHkBAAh8Y9zbwIxgeEnAOFxgeAmACCBcYLgJQ
Djg_AlAeGE4CUAJ_AmACXgJwEj4SkDLAHxXQEtAOAuAOAgAPokcd8AYwYWARZREwARUmASYVASAB
BRYXBRccGfECAQUWJwUnFgUBAAEFBjcFNwYKAAYUAJABBQYXARUGBSEWABNnKAAUhyYAIwYnRAAC
TgATIGAAjzARZRFgYfAFjgggEC9hB3AQDhUPFkY11wYxHWUAEg_gRQAOFQ0WHRUNNTURIQUGsx0Q
DlUHA_YPASAAAD8RAQIAABsAMwUGHQwAEVVYEQElABBVeBExBgUNiBFvxSAepUCulhAe0ABfFQBO
IC41HjUuJQ7GByA1DmgWMA4FLQoAQC0FDgVvYgCGEgIVABEFBwBhBQ4VHQ4mb2IwDjUOjwABPAAA
gTYDRQAGBgAhJR4GAAEMABEFaQBfAF4ATiBQAR9QRTYPFhWyCNBVHxY1DgBVDUYVDgB1aQgwRR02
BBEAJwEgBR0gEQCbVBEWGC4hDQYCABEFJRECDgBBBQYNRQwAAgMAEg0xAFANBhUGRVsRAAIAvzUO
ELUeEKUOMK7w9R0fUEVPFjUf-gEgFg4IAPAAXjUdRRYeRQ0ADbUNEA21cSPzDx11HQUdJX0lHdUd
RQ4GDlUttR0ALXUtEA0VfRUNECgAIBANHAAfNQtdHmAABR8WEDjcB-ACHxYIPxgiDiAPFQAFDxYe
chAJAADmRQJqDRANEAAQDiJREBw6EDAPFQgNABFlFwARCPsZEFUMAPANEE01HRALEK0QCyBtIRAL
MD1RAAtADREwEWAhMKgFfx8UUCHAARpYBx3wGJAoAAjADxgYcB44DnAeaFB_KDAuDxIVEh4IDjAt
RQIuMC1VIjAtH-IBUSUNMC0FCgDQFQ0gAT0FHxY1DSAhLQ8a-wcwQS0FHCBBACEQFR8VDxQxIBFQ
G2AbDgsd-y7wFQ8Z4AmgDiAKoAmQDjAKkAmwDhAKgA4QCbAJEAowDjAOEApgCTAJMA5ACjAKMAkg
DqAKIAkgTxVgCnBdbQAd8QwYEHgwDxgIABh_IB4ILlIeMLIQCA41DxEPHBUFADMQCACFDvAQTxZV
DCBVDA8VRQwQRQtVAAUgJRtFYAUbRQFgG3FAG4oGcBsRUBEgGwCyBz9AGpCKABwwMHgwfgkEiQBH
IA6yMIgAISAOhwDgDxYACADFDBAFTFUABRCOAPANJUBFC0VQJRsBJYAbMYAbACGAGxAxYBsQQVAb
IPgaHzCHAB7aQAgAGH8YIAhOUh4QHoUAEQiFACsQGA0BJUUQDQHAcBtRYBshEBFQGw8UFQdvGwAK
QBHQhgAeANwJkMAPEhUPFiAeYGkyUBAuAB8R7huADgAOPxEIAiDvDmAlDg8RMxIXA-8mHxIlMw8T
AwwDEB8VLxIzDAAMAAMAHR8VUwwAAw0ADYMcMBMcMyxAAwwQXFAD4BMQA7Aj8BxKQx6gFQ8WsA8S
JQ8WL18SADBT8AsFDxYTPggCAE8VDxJjEg4ADoMfEwMNIy1DDXlhEZ0iY-8ADTA9UAMN0AMN0BMg
A6AzSw8ewPAHLxGgbnAeUx5AHvIdIRMz4jAgAyUMADADHQN3ABETlwARHdVVMAATLzkBEB3CYTAD
ABOnABAVGGLyAA4QAx0ADxUvEhABQAMNIGoboHADDTAcgAPgAyATAQ9DEh7-EjY3oAc-FgeAB14H
cH5wDxJeDXAPFQ0_DQxwHD0ccHyAXBENHvAOFhdGRwYFBiEFIQVRDxYHESUBdQ4HAQUHBgFFBwbx
NgD5VDFFBgULAHAhRSEFDgbVAwARBwMAAAwABy0AFgctADIHAQUuAH8RNSFFDgXu6gAd8AQSpwYw
hxYFMDdGJTAXBhcmBWAXfSIwcBcmgyKBFzYXBgVQFxaRIiBAF34iAAoAEDDmEQDECAAJAM8wBRYH
BTAGFUA18BJ_ABwgBxa1OPAODgYuBQblByUBtSEGRQ4BNT41AQ4VMQ5VAQ41HgGOTP8pAQ5VAQYl
DhEOZQEGNR4BZQEHVTE1AQdVAQYeMQUGRQEONS4FDkUBhQY1AQ51AQc1AYUBJTFFEQV4Fh3wDDAV
MAUBcBUXBhUBcAUHFgURkAYFIQWABwYhJeEbQTAOBXCxOTFwBg4GABIFEgCQETWABQYhFXAlEjgw
gEUBilUSDtdZAQUADyUEHf8HELcgF5YXABe2Jwa-FgYXHpAeFw6wDgQADR8Hvi0eYvA0d2AXDH5i
IwdACgDxBywHMAesMAcMHxAHLB4cMAcMERcMDhEJAP8PBxwOEQcMMAcMEBccEAcMMBxwBwwwLA4w
BxxQLjAu0CkeEBDBZcAzIDMQAwBTAEMPEzkzMfEWIDkTECMwKSQTEBMwGTQTcAkPGU8UA3ApLgkF
cFklUCkECSQVQKJS-wskFTAZdBUwHxlOJBUwWTQVMCkECTQlQEkUJfYJHYBQIzATIBMAUz8y0Q8T
kw5DDlMuAA4zLjNgMJATDhMuMB4FMy53WvAKEw4FMwUOMx4TDgQFExUOMw4AHgQZFQQVDpQw-xYA
Dxk-FBQVHjAPGS8UKSQFDiAZRAU9FRAJJAkPGW0FIGRFQASFnQAd8BTwORrAChnACR8ZGmAaEAkK
CBkKMAoAGQoAOgkwChkOGQA6QCs3YAkgGgADUJUscg8TABNACQrpW2FwAyATDYAFAE8NIAMNRggd
UJAKCQqwPScQoAUAQDAuCCBAN-ALMB4IHhAZChkwDgg_AAMpAzAOCB4YECNACAKzN-AIA1ADAggC
AxADAANgIyAfEwMwAyANQA0RAAAFAAC1ZwcLAGIAExANAwALACEDDQwAMQADDQ0AAJNpXwAdIAMA
LC4e8AsZ2hkaFzopigcaCSoJqgkqCUoZOgkqCToJGIdGECnyRQAKAPAPWgc6GSoHaglKB3oJCDoH
SgcqCboHShkqGVoHGgkIJAAwugkYOAB-FyoZ_gIHOoYAHP8w_gQJigk6CQoJOhlaCSoJGgkKGUoZ
ChkaGQgJWik6GboH_gAH6geKF4oHCcoHihmKGRoJCAk6CVoHChmqB-oMbgAcURoZBBoJAwAxOQQp
AgAhCSQCACP0AwkAUFQPEiQOAgA2CQQeAwAYLgsAAQIAFAQCACUeAQMAIg4hAgAf8MwEHT--ElCa
AAgf-oYSHfAZKZo5CrkKGQoUfxQUCgkkniQJChl_GQoZChkOUA4ZCikUcBQZJA5wDhgAEXAYAB9w
FgAPD9MAHbEVAC8SbxUvEh8VT9Qj8AcfFf8SAmVuJS8WlR1FfmUODxUOTD4VB2j-Cz4sfmweFS0l
bpVOHRVeRQ0VHmweJR68HvwAdAAe8AYKbxJPFU8SLxU-Ei8VLxIVvhUfFRWyJpElHhX_AT8VLiy3
F-8ZFS4VTiw_HD4lbhUeFS0FDhwFDQUuHRVeHA4VHiwOLBX_ASwOLC78CstNIKAPFgfWDgcWFQ5G
GSIHCQB6LkYuBg4H1gMADygACC8G7n8_HjEGLiZGa9AFDlYuFi4FDhYOVi4VHBARNvYAURYeFR4m
xDNAFg4VFmxr0A5GDhY_Jg4GDlYVDiaba7EOBi4mThYOZgVeBsRrkAY_Fg4GDhVGHqtzQB5GFTb8
TgBAACEFRmYAbwYOJgUmDpQ0HWEWHxZ1HiZDGADWIRB2gVWADrYOFdYV1hUIAAAEAFAudi4V3j5x
-wi_BS0VfhUdDi11LQ4GDr0eFr52LgYeNnMAHPADABcMVwwHLxAAF7weBywuHAcsXmoBCADxAhwB
BwwuHCcMDgccAQccDhwnFQAACACQJwwHAQcsBwwHCgCwDAEHbCcsHgcMBzwOACIuFwcAADMAAhQI
QQwuDAGwLZEsDgwuDA4BDA7dLQANAN8eAQweDG4MHhEAHB6R1gId8ChQOJAoGihQKBofFhooMAga
HhceGgggGAoOFxoXDgoYEAgKDgcaGBoHDgoIABgKDgcKOAoHDgooCgBADxg4DQ0AwAgNCQ4HCV0J
Bw4JLQoAED0KACAdABYA-xcZHRkHDgkNEB0JDhcZFw4JHSANGR4XHhkNMC0ZHhktUC0ZLZA9UHcn
HxIVxVYjTxbNVgDfEIEUBQQvFgQFFEFGUhQFFA0UDADyCzVENQ4APmU_AB4KCW4KCR4AAc8SAQAO
DKUMKQAVRDMAAB1WDkEADxoABx-uuQBQ8AUONQQlBDUOAF4JGl4AAU8SCQoJTL4AMzUsNcAAPwQl
BMIAVv8sDxZHkAU_F4APEjUOF3ANRQ4XYA1VDhdQDWUOF0ANdQ4XMA2FHTANdR1ADWUdUA1VHWAN
RR1wbYBd8BpqABzwFlAPFySgDjkEgA5ZBHAEWQ8UcAkEOQQPFXAECTQPFA8VcCkPFgQCK4FwBAkP
FgQNBBUARAkNCQ0WAB4NFQAxFB0UEgAxFAkUEADPDxQkLA8VgEwLoBwbhgIe8AIrBNAJcAQJMAkP
FJAECRAEDktqIRkU53RwBAkwFB4fFb498AAEHgQABBAUDh0ULg8WFCAfAPALHgQODAQJEBkcFA4E
CQ4MCRQZNAkMFAlEDgA8ADAJFA4CABAAuV8QFBMAvwAOBA5QDgQQDiAOhgkd-xJAR6AnBieAJwAG
J3AnwCeQV4BncHdwBlcGgAY3BqA28EpQAByIMGeAZ4AHQAcEAP8HUDdAB0BHEDdANwYAR1AmEDcG
sCbwRqkAHfAAoyDDEEMPEx8SDxMTHgMQMzsgLxI8PFAAMw4NDipn8AIODQAjDgMtBAUdBA0OIw4D
DtECEQTZAiEzDgoA8AAFNAUjDgMFBAV0Mw0EBYRPPfAABTQFJAUEEw4dBAV0DxYjCABwBAwEDBQM
BNg88AEdJAwUBQQMEw4dNCwUDAQDHwA-FCwEL18dkPMtDxMjDkMeI4Y2AKoAEAO0DGAeDQ4DBR0O
ACENIxQAAqwAABhnMR0ODbAAggQdDhMdBA00CwARA9AAIYQNhgDCBVQNDh10BQQPFhQdsgCHJAwE
DEQcBAwCAB-8KSsd0aNAwyADHxMTDh8SDkOcPRAtnDwQEMxb8QMDLQ4NDjMADg0EHQUELQMOIwAz
BAG2AFEOAw4jBacA8AQFBA4zdAUEBQMOI4QFBA0zBAUkGQBhDQ4TDxZ00QABXgERDNIAoSMMBAUU
DCQdDgMXAJAsNB0OEzwELBQcAB8DxgoecAQFHhUuBS6JGAAEAAKOADAVBCUBBSAkBTQBIjQVCADw
CgQFVAVEBUQFpAVEBTQFFAWEBXQFZAVEBST7BJEVBAU0FQQFFEU_AP8AFQQlHgUOVR4VbgUOBU4F
QEgecP8SBxUuBT6XAEAVDjVejQAxNS4VjQASVYsAY0QlNAUUHqMAQR4EBR4xAbAehAUERRQFZAU_
FZYAMAQVTo4AYAUUFT4FHgoAjyUuBT4VHhXukgAfYPBCE8AzsOYBEJA5dlADICMwDmZBIEMw9w1A
Ex4DcIFA7xAOA2ATHjADcAPgA_AO0CAd-wDwtDcgJzAGVwBHECanhjcwCR3wDZAPEQM-E2AOIw4z
UAMOAx4jHkAOAw8RDgEDLg2PdrATAQ4DLRMwAw0eAT0DoDAOEw0BDiMeAzCTavAKPg0TMA0OAwEO
LSMwEw0OAUMOQCMBDhMuUDYA-wEeE2ADAQ5DcAEOI4AuwA7gmQAc8AIwOaApBBmgGQQpoBkPFBmg
CcsFIRAZ-WWACQQAGQQJADlDZxAkCgBBGQQZBCEAUAQOGRAZdXqgFA4ZICkEHgQuCRgG8gI0HiQJ
UAk0DhQJgAkUDtAOBAMAH2Dbcx5hCglACgcKuTxgCRoJIBkEqWhwEAQZQARKGbFG0G8WGUAKHhYB
Jg4JMAoDROIXFg4JIAoOBicBJwYOBAoA8QY3DgkgCQ4BFzEHAQ4EIAkOBhcGATYKABSHBgD-BjAE
DicBJw4JMBkEbgkUIAkQCVQQBHMGHvACHiAegC4JHghQLggOKhgeIAiKMPAXCQoJCC4IEEgeCB44
IBEIHggPEwgeCAEgAQ0HARgNAw0YBwENEB3fehARghBwEQ0jDxwDLGAXoNMAAw0DDUMBIwGyEGEN
UwwjDAMTACCjEAYAU5MQLQMNAgBfHSABnRD7Mh4BsADwBgAeCGAeCB4JDhgeMBgeCCoILgggOKk4
4A44ICEuCC4IERABDxMBtAAABACgHQAdASgBAwEYEaMAchMhIxEjDxyWABAMpQBAASMBI7YAADp-
AZwAJaMApwBPIyABvdQDHfAdMAgACMAfGBAIkDcOkAcBBidABgcQCgcRJxAXAAYHBikGJwYANwYP
FgcAGJc9HvITCB4GdyYQDg0WZxYNEA0GDRZHFg0gHQYNFicmQB0GDVYNUGYezx2AXZAKIAqgCiAK
QJMALRCAkABBQAYHAI4AECeYAACOAACVAPIDCB4GBwZnDQYQDg0mZxYQHTZHlwCxhg0wDQYNZg0w
CgCxHc8mDVAKCW0J4AngCiCPADIQcIwAACwBIRiHkAAAGAEAkgAAGwExdw0GGwEBkQAgNzYMABKW
jwARUI0ArwYZDXA9Ch2gCXAlWh7wCxbQJsAmIBZgHxJAJlAeDxUgNkAeHQAdFlAJVm3gHh1ACQQO
FA0_DTAJBC4QCrAdIAkUPgQeDQ4NIFEEUE4NDh0g1H4SDQIAJiAUDABvQB4dMR0w5QIe8ToYMBhw
CB8YEB4IkD6QHjgeYA4IHw4YDhgOUA4IHQguCA5ADjhuMA4IEj4SHjAOAhE_EQIOMB4IAT4BCB4w
Lgg_CC4wAn4CDgIwKkgAxl0QQAoAbzJgDxVSDI8AHvQrIhhgGEAILxggLghwTpAOHw4oDmAeCB0I
HggeMA5IbhAOGL4ALhJeEh4AHgIRXhECDgACHhheGA4CEH8AfyJAgnAfFTCfdR7yBDAYEBiQDxgI
EA4IoB4ADsAOGA6AAIFwDh0YDhhwOEQ5oGAYHgg_UAIOEV5-XZAIAW4CMBIOCG4PWlUCbhIwEoUA
AgoAfyJgcpASABJCAx0h8BoVJzBQGBBLJfANDggeSIAOKC4IYA4oTmAYblCuMAIOEY4gEggBjiZb
VAIIjgIQegBGAg4iIIYAH5LRFh5gBD8XDxaAQIAAjnbAHxcPFmBODxcOHVBuZQIwQB4UK0tQHiAe
BB6WAkAdDiAejhSwHQ4gDgQNHg0ELiQJAEAuBB4Eww5QDxIEEA6sFEAEDC8VCwBwXgQMKwQQHiIA
QAwrDARHAP8CDQQMGwwEIAQuJDwEQCRMBFCyAD9xDxABHQwBELQAQBEdERCzAEMeBR0FtAAECwBR
LgQeNSCvAEAfEhUbrgBBGx8VG64AMRs6C6wAzwtKCxAUHitaCyArilsBPzA_LTCkADE_HTCiAIMP
EAENAAwBAKYAEBFofwGnABAuyFkBWQEgPjWnAFAvEhUbAKcAQXsPFQCnABEKAgCPGhQeK4oAK6pU
Bh7wKBI4EmAiOCJAIgE-GAEiMDE_MSAEHxQXPxcXHxQEEAQdAw8TDxYfDw8WAw8THQQABB0DBwEM
Hw8GAPAWHRQNDxcPDxE7EQsPFw0EEBp7GkAaWxpgcXABUgFwcmCScB0QHUV5DxQDHh8ElgBFDpQA
DykBaBBQkwDPEVByFFByHWBSoBSQkwA3KwUPlAAjFQ2TACAPE5QAFBWTADE8ARWTAIAbbBULQBs8
FTmH-wJAYRpgAUIBBQFgUgEFAVByETQBawCHdPABEB8XewUBQBpbCh8WUFEVCTt--wZCERVQYgEV
QHIBFWAdEB0AFWAUEBQJdx8v8BSmAAFgDxQhPiENpAAhfxeaAPgLERwfDxwRHRQNDBsRGxEbDA0E
EBx7HEAcWxxaAg8iAR0v8GQjAQMTfyEBMhc-D38AYBcPEwcfDwYAAxkBQA8TAT8FACEPD8ABXxx-
DxwQnwEi8AU-GCJAAg8UBwE-FwcBDxQCMAEOESUC9yEPExEOASAEDgcDDQcfDwcdBw4EEAQODBc8
FwwOBAAEHpweFA4fF3wbDgQQK1wrQJv3Az8eEB4vAiLwDlIYYBIRAgESHxhAElESHjCREjCPFBcP
FyA0TxQHLALwAw8gJC8UHxcHAxEPDyAEPxQfF6gA8BQBHw8wLxQ-F08PUH8XDw9gcXAhQnARUmAR
cmAPFAQwDQRwDQYAD6EIHh8EkAAgOQ8PB5EAMm8XH5EAP2AhYo4AKgIdARAyiwAvMTIbASH-CI8X
YHFwMUJgIVIEQDFCHxRQDQTQDQSQFQEeD4gAMqEBFAEyYBEfFFLAhgAPDQEo8AZBIh4wkQIFMI8U
BxUgNE0HAxUgJC2AAGEBFSAEPRx9APIIFTAtHE8PBg8WUFwVGxUwcRVQITIBFVAjAh8NlAEnGyCH
AA8MARExBQEdCgHwCg0FHQxQPBUPFgY1MDEVG0UgIQIRBQFwESJ4BTERQiEtAkAKBHAKBgAPVwQe
HxS7AgDAfxQ-FyA0PxQPFxEdjgDpHT8PAQ0wLxQ9Tw9QbRylAkALBHALBgAfMPEFJ0MPGBgO0AQA
SwXSFBAELxQBPgEtBAAE3cIEQgRdBAx8BqcMBD0EDBtAG1wbRQQPqAckL-AEhAAPHySCAAgOKAgP
AwFc-wRwcWACAVIBUAQNgkAUDXKAUsAUhwEKUG09OX19
:: gfx/doriancey.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTI4IDIyOjMyOjEyIixtb2RpZmllZD0iMjAyNS0x
Mi0yOCAyMjozMzoyNiIscmV2aXNpb249MV1dbHo0ALtPAABujwAA8yF7WzBdPXtibXA9cHh1AEMg
EBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMp5PTAsem9vbT04fSw_AGAPFgUfEk8F
AMQ-FgUPEg8VDxIPFjUJACElHwkA8QkFTg8VDgUuHS5NLi1PFgUeTAUeDDUODQ4FACEFTgQAsx5N
Lk0_XB5MBQ4NHAAnHg0bABEsNgAkHCU2ADEMBT4cAHMOFT0uTS4NtgAfMbYAOlEeDxUeDbgAMh0B
HboAQhwNDA29APAUHBUNBQ4NFS4NDgEMBR4NHg0FDi0RDB4dAR0FLiwNHB4cDRzLADEVDA2uAGAN
FR4NBS4MAPEIBQ4BLg0eLQENLg0BLSwFHgwNHA0FDA7bAEUcBQ0F3QAAVQAA3wAAfQAP4QA18EoF
Dg8WJR4PFQ59BS4dDh1RHQUdHxYdAQ8TMwwBHQ4FDxYFDQEMIwwTDAENBQ4FDg0BDAMMAwwjAQ0F
Hh0BEwxDAQ0eBQ4dAwwjHAMBDQsFDgUNAQMcAwwLDTEAIx4FMABADQEMAb0AAQ8A8AYTHAMBLQsF
HRMcMwENGxUNASMMIww9ABEeHwD_ATMMAQ0VLQEsAwwDHAENDg2AAg-pADAwDXEN6QCDDQESPxgS
AQ3pAJQCDxgIDAgMCALtADACCBwRAALuAGIMCAwYDBjxAKEYDAgcAgwBDQ8W8wAADgAzCw0C8wBj
AiwCDQEC8QAQAlEAIRIM8gAAQAASHPQAAAsAIwwC9gAgAgxoABEC_AA-EjwS9gA4CsAC8BEuVx4f
FS43BgcGFx0vFjcFDQUmBw0ODBUHBgcGBwU2B4wC8AUNBwYHNhUWDR4dB5YNLgwWJQYlFoQCMAyW
B9QCABAAIAYHtwLhDZYHHRwNF2YHDRwVHXekAhqNfQMPvQAV8BUA3xYALpVOtT4FnxUFHhUdfxQd
NQ0cFQQFBAUcDTUNDBU0FQwvA3AMBQQFNAUMgQExDQwUCwAwBQ4VCwAyJAUEIgAAIQATBCIAcwQF
FAoJCgQlAEMkBRwJJQBlJAUEBQwFJgA0BAUkSgAgRQRqAA9bAxzE2B8Y2B4YvhIYPjc_BQBAHxYf
FwgAUQEFDxYPCgAwMQIuBgDzABIeEhg_Yg4SGG4yDhIYvgMATx7SHtI1ARzA3xwT3hMesx8THrMd
AwCCMz0zHR4jDTEGAHENIx0eMwUhBwAyDxYlCACxFy8WHRMdHjMHLxcIABUxBgBPE90T3YAAHP8v
wB8S8AkPFYAFDvAHBQ7QDkAOMA8WBcAOBQ8SDsAeUA4QDxbwCA8SDmAPFgVALkANBQ4QDvASDXAe
cA0PEgBtABz-XAAfERAPE4ADABOADpAvEaAdHgMdIA0ADRANAAETDgMNEAMOAANAIw4NEBMADiAO
AAEjASADEA1AIfABHUAdAA0wDSMgDRMOEzATMAMeA6ATDiMwHTADDjMgDQMOAyABMwEQDQMOEzAx
MCMQvQId8BQDDxMAAw4BDgADDhEOEAEDAQAOEQAPEQ4QDgEADgEOMRAeEB4A8AcBDQFADhABDgEO
EAMBAAENEA4QMQ4AEgAhAwApAHAREAMQEQ4ARABBDhABDQYA8A0OMAEAAQ4DEAEQDhANABEALhAB
MBMAEQ4AAQ4w9ADQQAEeIA4DAA4BAANADj4AAXQAsQMOEA4ADhEOIR4AegAADAAAeQBAAQAODZcA
fw4RAyEAAQ7oAByxQA8cIAFwASADMANUAPABQA8TAAEAE2AOUAMNAAEAAxkAEACVASABENIAAK8A
gAPwAAMADhAOwADxKwABEA0AExADIANAAQANAxANAAMADSAOIAEDUAEQA2ABEA4wDQABIAFAAyAB
IAMgAyANAAMwAxADIAFNAAA_AE8BDbANOQId8Ak-FiYONg4WLiY_Bg4mHgYONh5GLiYOVg4OAPEG
Fi4GDhYuRi52DgYOBh4WDgYuti4WDAACEAD-GRYeFh62DjYOBg4WPkYONi4FDjYONh4FDjYeNg5W
PnYOBl4WDgY_Ng4iCR3wHh8SDxYWPgYVHxK2BS0OJhUOBgUWXhYlLqY_FhUWHhYFRg4GHUYFDiYV
Ng6GHaoAEA2QAPAAJh6mFTYVJg0mDhUmFR021gDwAgUtDjYVVj4dFgUN9gIVDQYNrQCPHRYFHQ4m
FSaVABzwCvYeDxaGHpYOJh72BQ72Ag4mHtYeFg72Eh4uAa8mHvYcDmYOJg52VgAcYgEAERARAAYA
8CMhEBEgEQARADEQMSAhADEQQRAREEEgIRAREGFQISCBEEEgYSBRIDEQASBBMBEAMSAhICAAkhEQ
ERBREBEQIUIAQBARADFOAAASAAAIAA_QABywHCcMHxAsHkwXLB4GAPAbHB4sLkwHDAcuLD4sFxwu
PA4MDhwXDAcMLnwnHAcuTA4cNxwufDcsHpwXGwDQLA48BwwHnB4cBxwHDAIAYA48DhwXbBgAr0cc
DoxHHA4sDkyRAByD8EMWUBZABhUDAJEHFUAGBRYHBhUJABMPFwBiQQYVASABGQAADgAiBQ4EAK8e
QQYeIQDRQHEwdgAc0hAHBR8VMAcVDjAHBR4IADIVNwUQACkOQAgADxgAE89ABwVQBwUO8AIB8C_M
ABzwBoAPFgbADhYFoA4WDgWQDhYOJXAOJgUA-xoWDhYlUA4WDjYVQA5mJUAOVkUwDkZVIA5GDlUQ
DkZ1AA5GhRDFMJXwBHEAT-8JETUQDkYFMSUADkYVMSUQZTEVMFUxBfADegAc4EACTxiAYg5gEgVS
DkAScwrxFFIOIBIFLQVSDgASBR0PFR0FUg4QHSwdRTAdLC0FHAUwHS8XCAARfQ0AoCstBR0FMB0h
LTUFAAETAA0HAD8dBRCWABw0BgUQAwB2AA8VBgUGAAQAQB4GBQbxCUQlHrYFHAXyFW4ABjUeBS4h
EBZlDgUuEAYlNhUOBR4QFgUGMQYVLhAGBQZRBREAYREOEQ4GBRMARREOAR4WACMBHhYAIgEeFgDv
ADZeVg4VBgFOBg4VDgXAAByz8Fcq0ArgCuAK8Fc6AB8yOgAUP-8Y8GwAHPANNrAWFQagBgUGFQ8W
kCUGFQ6QDxUVBhUOQBUgDQgAUiAFBg0FCwDwGRAFHQYwDQEFBjUNAQZQDREGFQ0BgA0BFQ0BoA0F
HRWQBQ0BDSVgFQ0NCCE1MDgAUAENBhUwNwCfFQ0GQAUGQBUGDAEd8DgwBg8WBgUOgBYORQ5QBh51
QAYONYAGDiUPEpAGDhUdBYAOJQAVDnAlIA8VDQ5gDhUwDA0OYBVADA0OUA4FUAwdUAVgLNAcDQMA
PyzQHH0AHPkaEB8WEA4mHlAVEG5ABg4FAQ5VDjAlAYUgFTARECUgFTAODxIwBYAODdADACEPFQcA
EAwDAD8NDFDxAB3xDlVgJQYPFmUgFRYuVQEQBRY_RREQBQYeBgUOFQEVCwBBFQ4FEQoAG04bACIW
DhsAoSAFBj41ETAFBg4bAPABBRFABQYVDgUxUAUGLiURYCgAIBGAKwBPsAUBcKAAHORgByoJoAop
sAoJ0BoHCgsA8BcKCbAJChkKCbAZwAcaCZAHCllgCglQCglQCRAHEAkQCVAJIAoJIBIArwApCgAK
CWApECnkBR3wGfANBtAHHxawBgUOBQaQBh4AFVAOBgAOBQ4VcBUOFRAFgCVwBxYOJQ65BTAQJQBw
Bv8JMBVwBlAOcAZQBXAOBTAVgBUQFaAFDhWQ9AAd8BYTkB8TABMPHAMAE0ADDgMPEwMOIw4TIAMO
Ux0jDRANIx0DDQEdwQtgAwENAS0RNQoBEgCwLQMODQAdAw4DHSOPC-8qDQANMw0DHQEdEw0QDRMN
AQ0hDRMNMA0BHSENAB0wLQARHxUBAAFQDSA8AbAFDHAFMCWAFQBFAAUgsAAckCAfExAeAw5gDscL
ALcA8AwOQA4DDQMOAQ0jLiAODSMeEw4BDQMOIA4TDgELAPEPIw4ADg0DHgMNAx4zHg0jDhMeAQ4T
DgAOIy4DDiEesgsBMQAgAQ4FACAgAQ0A8AMNAw4NIw4BEAEeIx4jHgEQDhMlACAeAwsA8QYDDRMO
IS4PFSAOIw4RHhEsAAUADgMsAG8QDBUgDsDPABz-K-AWJhWANgUfFgVgNj4FUDY_FVBGLhVQRh5F
MCY_AQUWDgUgBR4lAQUWHgUgRQEVHiUwJRFVkAE18CNpAB1AFyYFkGkA8ARwDgUGDgUuBVAOFhUu
FUAOJgUGBwBQNgUeFQFRByAFHncAEjB2ACEFDncA-wAuFTAlETUBBZABFQEF8CJ7ABzxCgkEDxKQ
DgQZBA8VAQUGBTYFAQ0EGQQNAXUIADUOkA4GAG8NAQUWFRYgAAsvBSYgAAo_JhUGIAAfCbIAHJf5
APQADxIfFR8EACMPEssKMxEQFQIALwUGAwAAARcAAx4ACwUADgMAExUCAAJYAHARAA4fFR4dAgBf
DvQA_QBoASPzDgkUDpAOFC4BFSYFBgUBLhARdREwFXAVMAUGcAUGBgAVFQUARAUGcBUPAPEAFTAR
BSYFBhUREC4BdQEuSAAfCUEBIpGwOYApNGAZJA85AfAJQBkULg8VEUAJFA0OMBUwCQQdAUAFBjAJ
sAFAQAUGIAkAISUwCQDyAg4QBQYFMAUGAAkEDjAFBgUgCwBgQAUGBRAVCgDBUCUAAQUJBA4NYCUR
QQBRFkAFAR1CAEAmFQENsABPMEUBDbIAHuM5KhlwGREKAQkgBUAJIQgA8R0RKgkgDxUwDxl5CgkK
CQcQTjk_FwAOBQ8XFQ4ZDh0VDgkABTAFHgUwBQ4gEcYB9QMFEAEfFQEwARwBIAEMDQUMARAHABQV
BgAxIAEcIgBvQBFQEfAUpwAc8wHwBQcJDxkFoBcOBRARcAkOcQDwFBUNCg4FAAENFQ0BUAkODxcA
AQ0MBQ0BUAoODBABHQEgCSAZMQDSMGkOBWAKEQopDgVgOhIAMQoRCkYAACUAJCEJRQBjEBkRCQ4M
RgAkEEkhACAgLjMAD7MAHeESuSAZHxkZHhkeGRAaEQIABQgAIRkRAgAxEBkaAgDwJgAOGQ4JDjkO
CQ4ZHglOGU4JDgAeHxcFPgUNBR4QDgUhBR4FIQUOIAEVDxUBFQEVDAEwAQUNWQEABgDPMAEsARAB
LAFAITAhVwYd8AxQHxmACRo5HlAZGikeBSEgCQ4hCh4FAS8VARALAABUAWABBQ0PFQGqACAeBXsA
FxArAEQZHgVACAADFwACKAAULEAAEg2pAAANACceDT8AEDB2AC_wHqsIHfI8QBcGBxaABlUPFoBe
kA8ZGR0PFJANGR0MkAY1BpAGLxwPDA6QBx8cDwwPEA8ckAcLDwwLCg6QByoPEA6QBwoLCggOkAcI
CgsIDpAGDgDPBggKGA6gDhgOwB5gjAAc8QQPEt8PHxIPDwkOeQ4JDh8SKQQJAgCAOQ0PFQkECWQM
AP8tHFQdVBxdBwpdDA8ZSQsKCQtJexlrPB0MGwwdTF0cXQwNVB1UHQQ5NDkEHTRZNA0MPQQ5BD0s
PTQ9XH08jwAc4PBnB9AHDxYFsAcGDhWQNwkAPAlgRVA2ZUAmjgT-AB8VJVAWAAQfEgAVkAQdYCQK
Hg9dABg5wBQNAwA-BB3AcgAf8gFQN5B3UDcaVzAXKhcqBwogBwBAGRAXGggAIikACAAxSRcKDwAw
Chk3BwBQGgkPFCcJAFMqCQ4ABwkAwBAKCSopOgkOIA4JCggAz0AOKSoZHlAeOR6QPswLHYAQl0AH
BpcgB8QM8AgXZgcQBx4GB3YHIBcABxZOBgdQllBGPgYA8wUmPiZQB3YHUAcWblAHBodABxYHBgIA
RTAHBg4CAE9AnvABggAc8CwwCgAOBw4CAApgGQcYLxgZYAcoHQ4NYA4oHR4NAmACLQgXAlAHCg8V
Dg0IHQIMCgcgBwoZDDIMGQoHAB4B-xpwCwkqCQuQCwkKGbApCrAKGRqQGgkACRoHUAcaCSALCRon
KgkLUAtZC7QQHvAiQA8VFS6ABw4VLgdwBQ4VLgVwBwUnFQeABwAFAAUHcAcFAQcgFQdABwUBFwAB
EBUHIAoAADsV0BUHEAcBFxAiEAEFBwAVAP8jEi8YIhUXAQIXDQgNOA0IBRcBDQdtKAUXBR0YPQcd
AgUHABcPDh1IFwIHEAcFB5wHILdQEB3wBTAFFgUGJVAFBm8WJSAFXgUuJRA_5Q9gBQ4VDxMACADw
FgUBDgUuFQ0ABQ4RBQ4VEQUORQ4BBgEFAQUBBgElDSURFQEFARWvDoAOAaUNJQ61ASYAcBURRQHV
ESUIAP8GEdURFQ0lDTUNFREALQUdFQ0FDQUR2wgd0DAPFV8SDxVgDg8SHxYlGwIEAMAOUA0fFg0M
DQwtQAEHAJBNDgEwAQ4NDF0IAPAFHi0eDR4BDhAOEX4RPCEeFR4hDRyYDEAFDiENtRsA8wtQER4R
DQ4NAPMBHgEtES0BHQ4dDgENHB0cDQsA-whcDQENHgEeAQ4NPB0BHgEAMQ5NDiEgsWYBHfECYA8S
BrAIDxgEBgewDgkWB7AEAP9AABawBAAWAAeQDxQABwYABgcQBCkEEA0XEAYHID0EAA0HEAYHMAQN
BB0EDQAEKSQQDQQNBA0ZBE0gXQQNGRQwDTQZNA0wAi1UHUACfQJgcpgHHfACIBYnZjCvFwZQBAYF
BAYFFHBSD3cGBQ4EcA4HCQAfBwkAGR8GCQADA2IAf1AWVzYwvgByBR7xFQnAChAKoDkPGQSAGRoZ
DgRgGRcaCR4EUAkKFwopDgRQCSoJChAAMwcKCREA-xYZLgRAKQoJChkeFDBpHiQgCQo3Oj4ADipJ
PiQOCimOFABOhHAu9AQdUCC-FgBebB7-KEUepS4lLhU-FTU_PVUfEgUOJS4VPEUcJT0FDQxFPXUN
HFUsFT0sBX0wPRAR0B3QLdANBdAV0BVwAB3wJvAIDxaABzAGBTAGQAYOEA4PFRAOBlAOBQ01DgUO
YA0FFw4VDXAFFxYOFVAHFQcmDhUeBxAOhCDgJg4VDQVQFS4lcA5VDmAxAEANBQ5QQwD-AA0QDgZA
BjAOBTAHgAfwCJEAHNBnBmcGB1YPFgdmB1YFBQBgDgdWBWYFDQAiVg4VACBWBRcU7iUmBQYlJwZn
BjcmDgdWAwAXBQkAnwUHJjUGHkUGLo0AHEDnBgfGSQYVtQUAMRVnBh4fchUnBgcWDxYMACAXBhoB
AgsAE0YJAC8HVgkABkoGXgcVVgAvx-aaBh3gpwZH1hcmdQcmBxYlNyXzBiUVd5kAIQYXCwAQBQsA
QQcGFwUNADIXBgcCABQFHAAVRhkAEDYmFATLACQWDuMAMhYOBqoAQAclFxZlACAWB3IATyZ39gRJ
AR-wDQa3BgUHFpcGDxYFByZ3Bg4VBzZXBg4FDgUHRjcIAEEVB1YXEABBDgUHdggAMRUHdg8AUw4F
B1YVEgAjRjUSACE2VRAAISZ1DgAgFpVcAV_1DgUG5ZoAHy-WBQMAFA9dAB7wMvATLxggHgJQDigO
AA4HGAIwDggXLigeAiAOCBc_CB4SIA4ofgIgAg4YTgIOEjACDhgOAg4CDhJQAg4IHgIOEnACBgCv
kBIOErAi0ALwGH4AHPEWkCEACZBBCUChIIEFMQChBSEAERcVcQAhFwUBBVEQITVhECEFAQwA-wIx
BQEFYRDRENEgsTCxQJFwUUcEHfEBMCcIHxgSYCcvDggPGBJQNwgA8BMCUAcPDicIDxgIDgJABw8O
Bw0HHQINCA4CMAcIDQcdCA0CDABxFwgHDQgNCAwA8hcHDRcIBwgOAg0OAjANCA0XCB4CDQgCMAcY
By4IAhgCMA0OGAcOCEQA-xAIDhgNCB4YDgJAAg4YHRgOAlACHhgdCA4CUBJeEoAyCQUej84awBoH
wAoXOAAd-xNtCfAACbAJ8AEJGrAJKoAJACoXcAkQGhcKgAkaBwoXkBo3UgAd-x5cCSqQGQoQCoA6
J3AqR3AaJ5AJCiegCgAXIBpQCQoAByAqUAoAFxA6UBoXEDpdAB3wEx4agBkAGpAJGqAJ0AnQCQrQ
CQrwDQpwFwogCQpgBwoJMAkGAJ-ABwlQCWAKYAltFB7wDRcJGrAZCgegDxkPGB8ZDxigDgkaCQ4P
GVAKBw5NB9EJDglAGg0KNwoNGTAZCAAzGkAJGgBBBwpQDS8A76AOHQ4NoAcKGbAaCfAXgwAd4BkP
GZAaAB8YABlgCQoH7w8xGlAZWABwBwpADxkADpkB8wAJDmAOCQonGgkOUA4JGicQAJEHGgkOAA1A
CgcvACAZUAUA7w4HCglgGQAeABqQDfAZjQAc8AhwAtACDxgCsAIODxkOApACDg0JDQ4CcAgAEAoK
ABBQCgAQKgoAEDAKADAaBxoMABEQDAAXJwwAJQcaJAAVKjgAFQpMABINXAAQDmkAXwLQAvAHNAEd
HwioABE1CgcKhgAnCicMAC8HCpQAEB8XlAAcECCfAfAOKWAJKgkUDxJABwAZBwopFA4ABwAHAAoJ
BxopFA4LGRIQCwAyEBkQIADwAhAJAAkAGSoZFA4ACRAJEBkqEwBAIAkOADwAUA4JgAQOYxn-A7Aa
GcAEDtAZkBonKhlAGTo5HnALHvAMBwbQBwbAFwYPFrAXBg5wCCAXBg4gCDAPGCAH8yRAIA8YMDMN
AB4RsBIOEAcwBwAGBRwfDQAwAAcwTB1ADxAVDQ4A8BAGICcGFQcOBQsOJwA3DgUHBh4LDjcWLhcG
XhZAFxYO2w3-BBcVFgUGUAcGFRAVFnAGBRAFBkCvAByQ8EQxgAEPEGwegBgxDGcciBgxDHcMCAB-
fA4BcDHwRlMAHfECCAHQAQ8QAbABDgwOsA4MBwwFAI8BoAwXDAGQAQYAAhOgBQARBzIAEA48AC8B
0EUbHkTwEg4CAgA1UAECAgARMN4oMRUFBgIAEA0-DvEQDQ8SDRxFHA0MBQwdDA1sHQENAQCtQAYF
DQAFAAGAFQcAMpAFDQYAn8AGBQ3ABQ3wHpAAHPAHUAYXBrAGFwagDxUGFwYOgA4FBhcGBRYL8BkG
NwYFDkAOBQZXBgUOIA4FBncGBQ4ADgUGlwYFDha3FvcQFrcWDgW2FQBvtQ4gvvACCwEdYAc-FaAO
NXQAFzZyABEVcQAgAEZvAIDXBgV3JjdWJ3IAYRcGIBUGJwMcIAcGkABjNxYHFgUwoQATQD8AEWBN
AF_ADjUOIEUPHwL8ACpwDggADwwBBhEeCADQHhUGlwYVFjcGFQY3FhcK3wb3Bha3FhW2FR61HhAX
ASDABj8VkB41HmAOFTYVdQBQFjcWBQ7oADMHNgd-AEAHFhAWDAAQEAwAPwYwBgwAAgMkABUgOgAT
MEwAEUBaAI9gHjUekD7wBr8RHw8pAg0zJxYnhAAgFwYtAAI3AiInBr8BAAwAZAcGBR4FBp4AAiwA
AUQAAKQAfw5gDlAO8ESYABwQUDYB-yElLmAOZR5ADoUeIA4VFlUuEA4VFmUeAA61PrU_tU6VPgAO
lS4QHnU_IC41TkCeYH7ZEx-wCPAGMYAhPxMhQBEeMx4RIAEeEz8cEx4B-ChRHTcdAw4zHTANdw1C
KQoIACUBACQAkRABHhM9Ex4BIEUAj0AhPiGAMfAWigAc8AhgEbBRgBE-ExFgEQ4zDhFAAR4DPxwD
HuMRMwMNN68dQQMNVw1xAA8KAAkVIDIAkTABHgM9Ax4BQFMAj2ARPhGAUbARkxUdAIEjQAopCgCa
D2EFAAopChAKAEEKKQogCQBBKQogCgkAURkKIAoJCgBRCQogChkKAEEKIAopCQAyIAopJgAPTAA2
DygHHfAI5wUH1QEHBSEFNwUhBQEHBREnDxYmBxELAPABAQcmBw4mBwEFAQcVNg4HNhIAcgUHJh4F
Jg4LAHAWHgUeBh4VCwBwBh4HBgUuFysAcwYOByYnDgcLABFGIABhAQYOBTYeSwAgBRE-BBIuYwBR
IQUHBRd5AE-VAQXhuwAcUR8W1g4BAgATAAQAIQYOlhQjBQAEAAARAAB1AAAlABAHBgBCBgUBBVUN
IAEF1BNEAQ4ABj8AKAYOOwA0AAUWNgACQAABPAAUAUAAMx4BBToAEAcIADYGDhE5AAA9HwJvAAEC
ABYFOwAAAgASIXcAA1cACHcAAggALwb_HhMd8wCWDxdPFgblDnVhBiUHBjXxAIElFkUhBQEOheMA
IR6FYwBDFQ8SddQAQh0FDVVzACAtBZAVAwkBUAVdBQ0OjQCCABUtBwYFHQ7IACAFLaYqEwUxAJ8l
HQYXNgHt8QCxAR6IPxefFvUA8QCXAQAIAARXAQAGAAGOAQJcAQIIAAEXAQUEABcVlgFWBwEOIQU9
ACgRB5QBKQAOOABaBQAFDgECABsFAgBf9gD-EgDWAB7yCw8WHxdfFg8XXxblDmF1HgEHAQcANQcG
DxIVMQFxADUWDRUOAHMAMTUdJdAAQQGVDgWDACGVEQ4AEAE2C0EHDmUNqAAgAAUKAAExADABDiWH
AREVSQC-DgUdFi0FZn0F7fGQEh3xHFAykBI4ElASGD4YEjACCB45HggCIAIIDhk6GQ4IAhACCA4J
CjcKCQ4IAgAMABBXDAAfEgoACicCADYAFRBMABMgXgARMGwAX1ASOBKQ7Q8f8AYHErASGBJwEhge
GBJQAggeGR4IAkBjABAaYwAzMAIIkg4CxQAIhQAEDAAXICQAFTA6ABNATAARUFoAbnASGBKwEo0N
D4coDw8yAE7wIzB8UBwvEBwuHCAMHhYBHgEHBh4MEAwOFxYRFxYODAAMDgYHEQYRBxEWDhwOFhAG
EQYQCgDwAUYRRg4cDjYBHgE2DgwuFgFJMPAFFi4BTjFOET5RPiEOAR48HgEOEQDTKRAcCgCfEEE_
QSCxUHEwnwAgQB8QPB6fAFERDhwOEZ4AMTEeMZwA9wABBxYxBxYBDhwOJxYRJxYIAAG2AAAFAP8g
DgweFhEGERYRBh4BHiYBHgEmHiFOEU4xPjE_EQARHhEPDggRHhEQMQ4BDQgBHiGkACJgfxhQLg8O
_jRAPiAOArs38CY_Ag4QAg8VAn4CDAIADgIBDBI_EgwBAh4CERwCHgIcEQIeBhcBHBIcARcGHggX
ETIRFwgOAsgS8BUOEg4IDRgOEi4IDiIeCC4iLgIRAj4CDiIOAg4IEQguAg4SCQrvDKEYLgIOIg8Z
GQIOHwCfEAsZogsQG4IruwAp1E4NDg1eEA4CngIOAA6_AB8evQASERK8ABMiuwCAHgIRAgguIk6y
AOESABIOAi4YLgIKCQAiDq8A3xkPGQkLkhkLABkbchtHCB3wIgAjcCMgIwAzACNAHxMTHhMeYAgP
Dj4NCGAzHjNQk1ABEzITAWARAhgCEVADIDEgAyDbM2ATIA4DEDMYM-8KHlMeYA4DPgMOgF5wEwE_
ARNAEw4AMQAOE4gAHf8AEBNwEzATcBNAEwAzABNQjAACE3OKAP8bgAMxA3AzHjNAAx4DPgMeAxAT
DgB_AA4TAAMgAT4BIANAEzETYBMOMA4TZw0dwHBTgHNgMxETEQATIAcA8AEDDxMTACMOUx4ADgMA
Ew4PvDIwBiATNyjwCA0EByAHECMADhMODQRQEw4QDgMeHTATvihAHg0EIH8AoAMeHQQQIw4QDhMJ
AIAOYy4dBCAOAwIAQy4dFDAIAE9QTjQwZgUeYVMwEyBzEJ4AAa4AEA6gAAAKAIAgEw4TDlMOIPYo
BK4AER6tAEYEEAcgpgARMKYAQRATDkCmACEAI7gAYB0EAA5zLqwAAaYAQz4dFCAIAD9AXjRMAR3w
IWASoBIQEqAYEAgCwAIYsBgJCAKQCBkICQhgAggpCgkoAjACGQoJKgkICQgwCAkqB_0SQwgJAhAM
APECBwoJGBAJKicKBxoZCBAJGkcgABAwCQAQGTEA7xoXKgkIUAgJOilwCEkItxEd8B0gDxMDDxGw
HxMTLxFwEw8TQw8RYCMPEzMOHxFAIw4jDiMNMDMOAw4zDjBDLvg2AB4B8AAjHiMwHmMOEzAOcx4D
QC6vKp9wLiMe4B7gHvDvAh3zFDA3DxYHcBdRDgdAB5EHMAcBFxEgEQ4gBxEXUBEHEAchcAEOBgA1
DhGQBQD-CYABDiAOEXAOMA4hUAEOQB4hEAEecF7wFtYGTmBQBcAPFwdaIPIGYB4-FQENFVAODQ8Y
BwgsDQVQBQ0MCQDwDZ1gET0RcAU_JUAHDi01LQcOAB4VDQ49Dg0eFQ2zPckXLgUNFR0VDRUHLhUJ
APACAA1VDQAVDQANBQB9AAUNIA2XN18NARANEKcAKEAPFQE9pwBRLxgIBwynABIsCQAPpwBv8Azw
Ai5QDlAoDhAegBggHvAMLgAeAB4gHgAOGD4IAP8GECguoCgeYA4QLhgOkA5IDtAYDtAYuisekIAJ
IBkgKSAJChkjgwkACSoJAAkKCABwOhkKGSoJIAwA8A4ZKglACRoJEAkaCWAZMBlgGcAJGgkwGUAJ
ChkAGToAEEAcAEEZKglQOgBAKgkwCToAMBoJMBwAIClACxg-CdAJfAsd8AtQNZAVPxYVUBUONi4V
MAUOF0YeBSAFDidWHoUVMBdmHkwLNKYeFQQAMB6GLhIAEIYfAP8FHmYuBSAFLiY_BTAVfhVQFT4V
kDWpCh3gYAkIwAkosAkYDxiwNbBtFhCgORIhBZAGABCAoRLgDhVgFQYHBg41cCYOFZCdMECABQEW
0Av-AmAlAQYRJVA1AAE1UCUQAQAloTQe8TBgCtAKBwrACgcKcBoQCicKEBoQChcqJyoXCgAKNwon
CjcKEAqnCjAKhwpQCmcKcApHCnAKZwpQCjcKNwowCjcmAFEQCjcKIAwArwcqQCoHChAagBoxAx5Q
Z1CnMBcHJvABBh4XBgcgBw4PEg4WDh0OJtYM8RcNAQ0WDRENDhYHAAcNEQ0WMQ0WDgAHISZBBh4A
ByEOBgdBBx4AB0YPgQYHIQcGHhAH_gwQBiAfIA4gbCQhBgcCACAOMComAUAmUQ5AVpAHMgBPoA4H
DsggHyFgD2M-ErCTFgAEABCQBQAA5TXgDh8XcA8SRR4PFxAvEhAeD5IlBwYPFwBPFQ0rD1AWHh0c
TQkAcBUODRwdBQ1ND-8VBQ0VLQxtBQ0FEEwNLC0FIB0cADwdBQAODxcODRwQLC0VHXBtfQMeIOAH
xBgAYScAbSgxBaAHcihBBg4lgFEC8AQHBg5FYAcGDlVQBwYOZUAHBg51Uif-BYUgBwYOlRAHBg6l
AAcGDrUHBg7FeQAcEQE9IRARvgIAewwfNQQAAyMORQQAMDUPFQYAHw0FAAIfHgQACx8GBAAEbw41
HRE1HVE1HWAPFeAFDtDFARDAoQEQsIoFYKAlDQUOkAAjsIBFDQUOcFUNBQ5gYQ-wAlB1DQUOQIUN
BQ4wlQ0FDiCl9T4QtQwRP8UNBXA9HfAC8AOHUAcPHBcOBx4MAQcwBw6ZOmQODBEMBxAMAGA-EA4H
AAeCJvABYQ0BAAceDAcdER0BDA4BEB4A8AAHDQENDAEHDgEwBwwOHB0KAFBQDBcMDQkA-wRwDBcN
DA4BkAwHDA0BsAwNAfAnnwAc8AUwOoBKCUowGgkfEBoJCglKABkBDvIdkQkaHgkaBAkRHoAd8AEO
ATkEEQoJGgkeEQkUGRQJ9C7wJwoRBBkUSQJZFAAUKjIqFCAaeSoQGgkECjQKBAkaABoJFAogCgAU
CSoJBCAKAAowBAkaCZAKAK8lTwowGrCnAByQwAUGsAUGBwWgOhcRkH8X0HAFFhcGBWAFFicWBVAS
GfADBUAFFjdmBQAGpwYFAAUQBUYnJQAYBgYAIhcGfQUBBgBvBgWQBQYFigAd8CgwpzAHRk8WBQEQ
BzZeFQEAByZuJQFXFhcGNQEHThUuNQEHPhUuRQEHLhUuVQEHHhUuJQElAQYOGgAgJQEHABAOCABQ
BS41DgUZACAuNcY2APYB-wE1DiUBBQEQBg41DjURICWBtwsd8hNgF8A3oBcWF4AXBh8WBhdgFwY_
BhdAFwZeBhcgFwZ_BhcQBgBR3mA1sD44BAsFAE-ABwVgdAAf8AsHFQegBwUQBQeABwUwBQdgBwVQ
BQdABwVwBb4qEZCvKj_wBQcqABcPgwAdEBipIvA8CA4gDgggCG4IEAIeAC4CDjIeECIOkjAOEg8S
BwwdBwwNAhAIDhIdHBUcHQAeAi11DQASAA0FHVUdMA0FDxYNHxUlLUAFDxYfFV0FCADwCA8VbQVA
FQFdFTAbBWEFMBsAETARMBsQBgBvCyAfFDAalAkfYB8YCBAYDqoAkTACHgAIbggwEqgAdjACDpIA
CC6pAHAADgIAEg0FqwBfMC11DTCnABHfQAsFYQVAGxEwEUAbAKAAIUAwGKAYeyHwF2ggDggADgIo
TgggHgIIjkAucg4wsgA-Fg8SFQcMFQcMBQ0fFiUdnQD-FAUNCwUgLVUdCwUgPTUtUI1gEV1wcXAx
EBGAERARkB8UEBogNQ0eYRgFDxYAWAcA8g4QCAIFDgh-GA4ACB0FDg1yDgAdAAUOgg4wBQ4CBYsA
8AwOMA8SJRwVHBUwK4VAK1UbQDs1G2CLcGuAUZCDAAQEAA_LACL1BygPGBAIHkAYfiggLkIOEB4Q
HoIgHxZPAlEFPxYFAgcB-ygVCwUQDQULDXUwFQsdVQ0wJTtNMA1VPUAPFY0xAA8UHxU9gQ8UAB8V
UTARIBpRgBogEZAaIB8UCCAeABpIkJAYEA4VUA8UEJwl8h0NAA4PEiAhDxQQDQANDxI1ADEgAggM
VRFACA0MZQFADSxFDgUBMAgCHwwMNQoA-y0MCwwlDA4FIQAPFQ0SLAUcDgUxCh0CDBscDhUAIQAd
EgwLHBUMAAoRAAINIkwAGhEQUhwAGhAfFBBCEBqwAB7kU1WAdWACFQ8VVUAPGAJMCTJFQB8NAPYD
BR8SNTAfGAIvEg8VHxIlERAvJQCAHxIVIQAvGALtSP8ATxIxAg8YMh8SZQEAUg5l3xYd8BDwEQ8Y
CNACHhAYLgJgDghOIjAIDghOQhAeAi4yPxYFGQ3wHhItRTAOAh0lBwwvEgARAAsCJRsMJQsAIVsl
BwwLAA8UEUslCwwbAAoAETsVOykBn6sACgEgW0AK0IwAHfARIQ8YCCBYQAIeAA5oUAIOOA4IHggg
GB4YbhAILgguQh75A-8SLnIPEjAeIm0wDhJNBwwtIA0CFY8WACENpQ8UMY0QC0BdczAeIPAjAwHw
Bh5IEkAYADguEjAeAhhOIkAITkJAHpQU-yYSFQ0fFgARDkINBQcPDA0VDxQRDgIVDxYdBR8MHQAP
FAABHSUfFk0gAS01TBAPFBE9ZRALMIYAH-ACMEYFDxVwBg8WJR4FDxVQBg4aN2MFDUAGBVAHAGAG
BQ1ABQ0OAHAgxgUdNg4VxQuAHg0FDSYOBRGyG7EGDQUdFg4FMQYuBRYAMDEWHhIAQh4FERYSABQF
EgADIwAARBsRNgoAPyB_PREFHlAmBQ8VkPYqER66ADAOBRCxABBgUx2PHWAGBdAFDbCoAHHxAPAF
rxUgHqUQDsUQDkUPFmQQ4AAOVQYVBg0FBgUADkUNCQAAAwCQAA5VDQYFDQYNCwAyJQ0WCwAADQBS
NR0WFQYuABAdgSMQJSAA4DYdNQAONS1lAA4lRg1FGwAhRR4YAC81Do4PHfEU8AD-FQD1Ag8WFR4V
DmUOBgUeBhUGDhUGFR4GLgYeBh4FBhXqMwKyRwQGAAYOAGEuBl4GfgZ7MgGgPAAKAN8eFQ4VLiUO
9Rv-FQDwkQAfoK8VQKUeIMUOEMXhSgD1AEAVDVUOLkMBJAEACwAAHQEgHQZSLwIMAAAZAAGyGyEG
BQIAIA0GGwAA-A0gBgUxAEE1DRUdIAAwRQ0mzxv-AGUdRQ4AHjVGDRUOEA5FLTcBH2AgnxUwHpV1
AfAGDlEOJR4lLxYWLSUeRQ0WDUUeRR0GBgBgPUUeVR1VBAAAawAgHTUKORCeUyJRtQ4QDiWIAFAQ
DjU9NQ4AMB0mDQ4AXxUdFj0VjAAecVAYPxhgDgLfLCAOQAkAcGIgHgIeAh8QBzAMIA62CJANFRwV
DEASDxYIB-8ZAhULHRsVHTAdFRsVPUAdNT1gfTARABFdASAPFMEAGgAhYCEKwBHwEeQ-HpAYoB4A
Ag4AGD5HCcICGC4SDjAiGB5SQD6MADBAHhKYBzANMALUT-8XHUUNMA0LFS0lHTANFY1AFQttYBUL
ES2AFSENgFGADxRBkAogEeDeBh7wAVAoLxhQDhIoHhIOQBIYLkIsCREugAD-LQ0QHgIAHhINFRwN
EA4CEA0vFg1FUAslHSUNUBV9C0AVC10bUBVRQBEAgSAPFEEwISAKACFQEdAR4BrwAQsBJSEoLgsB
AI4AgTAiKB5CQE4CpwghQC5HCgGiRv8SDVVAHQULLTVAHRULXVAdFRs9YB0lLZAxoDGwIdAR4B8U
4hId8BIwSC8YMA4QKB5CIB4ALhJfFx8WECINHxdtBR4ADxIdBR1PBv8oFRAOEA8SFQwlDwwlMAFM
NQcLHRABXCULDB2vFRxAEYxAMVxAcWAhECFwDxQBECGAChAKEcAKsJYlH-AXoB8UEB8VoBEQDjAC
DxhAERAeIAINEA0QQR4gAgACDQ8UAFEOMAJIP-9AVQ0YABEAEUUfFg0oMUUcBQ8SDRgxRQwFGx0I
MDUcBSsNCDALFRwFOw0IEAwFGxwFCw8MBxsNCAAMJQscKwoLEg0MFRArCgcrIhUwKwobEq8FHvEY
EB8YQEhAHhB4DkAeeB4APmhuEC4oTgIwIk4yEB8WLxJyDQAfFgUtPgECbwtABQAFLQ0M-xALBRAF
HS8VXQsFICptABUAKn0QBSoxAEEQGlEAQQAKiQAd8w4AHxjQHhB4MC6YMA5oPggwSG4QHhhOQhBO
gjAvEmILQQ0gLxY0Df8aEBsVHxUNNS0QCwUNGo0QCwUajREACxoQAV0hABoPFEFAEQAKAAlBQBlY
BB3wBR8QEHwwLixeDEAODI4MIM4QPhUHnzPwDg0VEB41HRUdFTAFDZUwFQ1FHxUVMCU9GyUwBQBF
aEfyCwAOFQtFDGAOG15gGw4wHlAbHjAeQBsAHjAeqA0PmQEd8AdAVnAWURZABpEFIAaxBRAGsQUA
BtEFAwAzURBRBQD-B9EV0QUABbEFEAWxBSAFkQVAFVEVcFU9BB2RMBcWkAcGBSAWAQ-ABlAGABdA
BkAGBQAX_kAkBpAEAHAHQAZwB1AGJABgYBYgBQcGHgtgcBYHBhABCgAf0AYAAg_SKx7BFwpQChcw
FxowGhcwfhcQQL9G-wEK8DYKCcAqCbAXGrAXCvAbVwAccAAPFTVPFiWVNlAlHxYmHQIHITVNfgY2
Ng1FkwYiDTaTBhBdDgAiBQ0cADUlXSUGAAQUACIFfbsGETZLACMlTTAAFC0_AA9bBx3wC0BfFUBO
DxZFThUODYUOJQ4NFV4lDhUOFQ5RTEhgDg0FDnEOrQgPBgAIIw4FLwD-AhUOJV4lDiUOlQ4VTlVO
QF5ALQEfwCU-FkUPFQAeNR8WVdkIID01BRLwAQ1FDkUeVR51HhUeRQ0FDTUGANAdBg2FDQYtBg11
HQYdFAAgNQ0JCPIHFR4lDTUeVR5FDhUtRQ41DiU9JQ4VHrMJP1UtJSABHkEA3xUQewjjRT8WRR7V
HhWeFT6VLgC4AQBdCIIVfhUOEC51Lg4AQLUOAA6NCIA1HRYdNR5FTZgAPxYdRSwVHv88BR8YGB4A
DxYFUA5YDg0FQA54DgUwDggOaA4FMD5YHjBeKB4CMAKOAgUwBRJeAhUwJVIlEH8VEkxAFRIFEgWA
BRIFEpAhwBHQHxSAewAcEEB6AHCADlgOYA54ZRAAdABQFRAFPlgTGgB3ACoFIHgAsCBvFRJNQCUS
BRKAfQAA9hAv8CV1ABwA6BDwA2hABQ4AWC8YMBUofSAVDggdYn4AIg0CggVRIAgVDgJvETAgCA2n
J-IOIB0LBRtlMA8VATs1GyAaEXswCkFLFSAhEAE7JSBGB48JQZAJMaAJ4I0AHPEMGNAIDxgADgig
PiAFDxZwDgIYEAUNYAUNKA4ACABRCB4CDxIKACAOEp8GcAVgBQ0CJRwHAP8oBwwFHxQFDxJgBQ0c
FREbQA8UBQ0LJREbADEKFQ0bIRtBAAsVGxErEUA7IQshQA8VK0FQGQArIW4UHcAAGNAPGBjADgAe
sDikACBQCJYAEhA2DkIeAgUACgAAvgaQBQ1QAgUNJRwVBwAwDB8UNlmAUAsFDQwFESsIABIVBwCB
GxErABEQDxSfADBBCgCgAAARAI8VK1FAGRAbMRYJHfAHGABYYAgPGCgeGA5gKG5AGC5SQAgeEhkK
8A4VQDItHBVAPQUPFh0lTxU9FQ8WPR8VDxYFDxVNFexZ8gIVFRBNVVABXQFwgWARMDFQEQIAb2Af
FFAbIIcAIDAPGDiGAC8YfoYABjA-FQAJAPARTQ8VHxYPFQAtJS8WHQAbIB1VHWABbXBxcBEwIWAR
QBEEAF9wHxRAGpEWHRAQzhPyBjgABQ5ACAUOCD8YCAUOMBgFDh0SHQkAIAcMkwAgBQ5UWADiAvAI
DkANlVALdQtQGwULNRtQKwULFStge3DrAvAEIWAKAHFAChAhIBFACgAhMBEwCpsREEAIAD8JcBnt
Bx0UGJoAJDAYmgAjQA2aACZADZoAE1CZAB9QmAADskshYAqBQAogESARnAAgMAojEX9AGSAKEAmg
lAAcUPYA8CIGCQiA8CUPFUAO8CdFVx8BzUseQEACHxjANfAjGB4ScA4XGB4CYAIIFxguAlAOOD4C
UB4YTgJQAn4CYAJeAnASPhKQMsAfFdAS0A4C4A4CAA-SMx3AMGFgEWURMAEVJgEm3FRQBRYXBRcc
GfECAQUWJwUnFgUBAAEFBjcFNwYKAAYUAJABBQYXARUGBSEWABNnKAAUhyYAIwYnRAACTgATIGAA
jzARZRFgYfAFjgggEC9hB3AQDhUPFkY11wYxHWUAEg_gRQAOFQ0WHRUNNTURACkRQA0VAA5VBwPm
DwEgAAA-EQECAAAbADMFBh0MABFVWBEBJQAQVXgRQAYFDRCIEW-FIB6lQK6WEB7gAF8VAE4gLjUe
NR4AJQ7HBzAAJQ5qFuAOBS0ONQ4FLQUOBSYOFQY0Eg0VABEFBwBgBQ4VHQ4m_FxAFQ41DpEAAT0A
AEo1AQkAFzUGACElHgYAAQwAEQBrAF8QXgBOIFIBH1BFNg8WFbQIQFUfFjX_ByANRs0sEGVtCEAO
NR02CREgDiUUASEdNfcyQAUGFRYXETEODQYCABEFLBECDgBBBQYNRQwAEQUDABMNMgBADQYVBhgA
AJ0RIBUNegifpR4QDpUOMK7wAB4fUEVPFjUfCQIgFg4IAPAAXjUdRRYeRQ0ADbUNEA21dyPzDx11
HQUdJX0lHdUdRQ4GDlUttR0ALXUtEA0VfRUNECgAIBANHAAfNcFaHmAABR8WEDjnB-ACHxYIPxgi
DiAPFQAFDxYechAJAAC7RAJ1DRANEAAQDvdPEBxFEDAPFQgNABFlFwARCAYaEFUMAPANEE01HRAL
EK0QCyBtIRALMD1RAAtADREwEWAhMLMFfx8UUCHAARpjBx3wGJAoAAjADxgYcB44DnAeaFB_KDAu
DxIVEh4IDjAtRQIuMC1VIjAtH-sBUSUNMC0FCgDQFQ0gAT0FHxY1DSAhLRoa-wcwQS0FHCBBACEQ
FR8VDxQxIBFQG2AbGQsd-y7wFQ8Z4AmgDiAKoAmQDjAKkAmwDhAKgA4QCbAJEAowDjAOEApgCTAJ
MA5ACjAKMAkgDqAKIAkgTxVgCnBdbQAd8QwYEHgwDxgIABh_IB4ILlIeMLIQCA41DxEPHBUFADMQ
CACQDvAQTxZVDCBVDA8VRQwQRQtVAAUgJRtFYAUbRQFgG3FAG5UGcBsRUBEgGwC9Bz9AGpCKABww
MHgwiQkEiQBHIA6yMIgAISAOhwDgDxYACADFDBAFTFUABRCOAPANJUBFC0VQJRsBJYAbMYAbACGA
GxAxYBsQQVAbIAMbHzCHAB7aQAgAGH8YIAhOUh4QHoUAEQiFACsQGA0BJUUQDQHAcBtRYBshEBFQ
Gw8UIAdvGwAKQBHQhgAeAOcJkMAPEhUPFiAeYDsxUBAuAB8R_RuADgAOPxEIAiD6DmAlDg8RMxIX
A-8mHxIlMw8TAwwDEB8VLxIzDAAMAAMAHR8VUwwAAw0ADYMcMBMcMyxAAwwQXFAD4BMQA7Aj8Bwe
Qh6gFQ8WsA8SJQ8WL2oSAAVS8AsFDxYTPggCAE8VDxJjEg4ADoMfEwMNIy1DDS9fEZ3YYP8ADTA9
UAMN0AMN0BMgA6AzVg8ewPAHLxGgbnAeUx5AHv0dIBMz0DAwDgMlDAAwAx0DdwARE5cAER2qVDAA
Ey85ARAdeF8wAwATpwAQFc5f8gAOEAMdAA8VLxIQAUADDSB1G6BwAw0wHIAD4AMgEwEPThIe-xI2
N6AHPxYHgAdeB3B_cA8SXg1wDxUNPg0McBw9HHB8gFwcDR7wDhYXRkcGBQYhBSEFUQ8WBxElAXUO
BwEFBwYBRQcGwzUAzlMxRQYFCwBwIUUhBQ4G1QMAEQcDAAAMAActABYHLQAyBwEFLgB-ETUhRQ4F
7uoAHfAEEqcGMIcWBTA3RiUwFwYXJgVgF4giMHAXJo4igRc2FwYFUBcWnCIgQBeJIgAKABAw8REA
zwgACQDPMAUWBwUwBhVANfASfgAcIAcWhzfwDg4GLgUG5QclAbUhBkUOATU_NQEOFTEOVQEONR4B
Y0v-KQEOVQEGJQ4RDmUBBjUeAWUBB1UxNQEHVQEGHjEFBkUBDjUuBQ5FAYUGNQEOdQEHNQGFASUx
RREFgxYd8AwwFTAFAXAVFwYVAXAFBxYFEZAGBSEFgAcGISXsG0EwDgVwgzgxcAYOBgASBRIAkBE1
gAUGIRVwJeQ2MIBFAV9UEg6sWAEFAA8lBB3-BxC3IBeWFwAXticGvxYGFx6QHhcOsA4EAA0fB1Yt
HmLwNHdgFww0YCMHQAoA8QcsBzAHrDAHDB8QByweHDAHDBEXDA4RCQD-DwccDhEHDDAHDBAXHBAH
DDAccAcMMCwOMAccUC4wLtYpHhAQd2PAMyAzEAMAUwBDDxM5yzDxFiA5ExAjMCkkExATMBk0E3AJ
DxlPFANwKS4JBXBZJVApBAkkFUB3Uf8LJBUwGXQVMB8ZTiQVMFk0FTApBAk0JUBJFCX-CR2AUCMw
EyATAFPXMdEPE5MOQw5TLgAOMy4z_C_QEw4TLjAeBTMuTFnwChMOBTMFDjMeEw4EBRMVDjMOAB4E
GRUEFQ4sMP8WAA8ZPxQUFR4wDxkvFCkkBQ4gGUQFPRUQCSQJDxltBSBkRUAEhZ0AHfAU8DkawAoZ
wAkfGRpgGhAJCggZCjAKABkKADoJMAoZDhkAOkD9NWAJIBoAA1CbLHIPEwATQAkKvlphcAMgEw2A
BQBPDSADDUYIHVCQCgkKsEgnEKAFAEAwLgggaUzwCzAeCB4QGQoZMA4IPgADKQMwDggeGBAjQAgC
hTbwCANQAwIIAgMQAwADYCMgHxMDMAMgDUANEQAABQAAa2UHCwBiABMQDQMACwAhAw0MADEAAw0N
AABJZ18AHSADADIuHvALGdoZGhc6KYoHGgkqCaoJKglKGToJKgk6CRhbRRApxkQACgDwD1oHOhkq
B2oJSgd6CQg6B0oHKgm6B0oZKhlaBxoJCCQAMLoJGDgAfxcqGfoCBzqGABz-MPoECYoJOgkKCToZ
WgkqCRoJChlKGQoZGhkICVopOhm6B-oAB_oHiheKBwnKB4oZihkaCQgJOglaBwoZqgf6DG4AHFEa
GQQaCQMAMTkEKQIAIQkkAgAj9AMJAFBUDxIkDgIANgkEHgMAGC4LAAECABQEAgAlHgEDACIOIQIA
H-DMBB0--xJQmgAIH-6REh3wGSmaOQq5ChkKFH8UFAoJJJ4kCQoZfhkKGQoZDlAOGQopFHAUGSQO
cA4YABFwGAAfcBYADw-TAB2xFQAvEm8VLxIfFU-fI-AHHxX-EgJlbiUvFpUdRX5lDg8VDkw_Fb1l
-ws_LH5sHhUtJW6VTh0VXkUNFR5sHiUevB78AHQAHvAGCm8STxVPEi8VPxIvFS8SFb4VHxUVvSaR
JR4V-gE-FS4swhfxABUuFU4sPhw_JW4VHhUtBalv-wUuHRVeHA4VHiwOLBX_ASwOLC78Cp9MIKAP
FgfWDgcWFQ5GJCIHCQB6LkYuBg4H1gMADygACC8G7lE9HjEGLib8aNAFDlYuFi4FDhYOVi4VJRAR
NvYAUBYeFR4mCABQDhYOFRYiadAORg4WPiYOBg5WFQ4mUWmxDgYuJk4WDmYFXgZ6afACBj4WDgYO
FUYeFRYuBR5GFTbQTQBAACEFRmYAbwYOJgUmDiw0HWEWHxZ1HiZOGADhIRB2VlSADrYOFdYV1hUI
AAAEAP8RLnYuFd4FDxUFvgUtFX4VHQ4tdS0OBg69Hha_di4GHjZzABzwAwAXDFcMBy8QABe8Hgcs
LhwHLBRoAQgA8QIcAQcMLhwnDA4HHAEHHA4cJxUAAAgAkCcMBwEHLAcMBwoAsAwBB2wnLB4HDAc8
DgAiLhcHAAAzAAIUCEEMLgwBuy2RLA4MLgwOAQwO6C0ADQDfHgEMHgxuDB4RABwekdYCHfAoUDiQ
KBooUCgaHxYaKDAIGh4XHhoIIBgKDhcaFw4KGBAICg4HGhgaBw4KCAAYCg4HCjgKBw4KKAoAQA8Y
OA0NAMAIDQkOBwldCQcOCS0KABA9CgAgHQAWAP8XGR0ZBw4JDRAdCQ4XGRcOCR0gDRkeFx4ZDTAt
GR4ZLVAtGS2QPVCCJx8SFZpVI08WolUA3xCBFAUELxYEBRQTRVIUBRQNFAwA8gs1RDUOAD5lPgAe
CgluCgkeAAHPEgEADgylDCkAFUQzAADyVA5BAA8aAAcf7rkAUPAFDjUEJQQ1DgBeCRpeAAFPEgkK
CUy_ADM1LDXAAD8EJQTCAFb-LA8WR5AFPheADxI1DhdwDUUOF2ANVQ4XUA1lDhdADXUOFzANhR0w
DXUdQA1lHVANVR1gDUUdcG2AXfAaagAc8BZQDxckoA45BIAOWQRwBFkPFHAJBDkEDxVwBAk0DxQP
FXApDxYEDSuBcAQJDxYEDQQVAEQJDQkNFgAeDRUAMRQdFBIAMRQJFBAAzw8UJCwPFYBMC6AcG4YC
HfAFUBrAChAJwAkKwBoJDxmgCgcaHoAFQDAucAowVhBwBjowHnAXBQD-BQc6CR5gKkkeMFpJLiB5
PnA_wB7wRTQd-xJAR6AnBieAJwAGJ3AnwCeQV4BncHdwBlcGgAY3BqA28EpQAByIMGeAZ4AHQAcE
AP8FUDdAB0BHEDdANwYAR1AmEDcGsCYMTB7wAUCjIMMQQw8THxIPExMeAxCVOiAvEp47UAAzDg0O
yWXwAg4NACMOAy0EBR0EDQ4jDgMOmwIRBKMCITMOCgDwAAU0BSMOAwUEBXQzDQQFhLE8IAU0y3OQ
Ew4dBAV0DxYjCABwBAwEDBQMBDo88AEdJAwUBQQMEw4dNCwUDAQDHwA-FCwEzl0dkPMtDxMjDkMe
I1Y2AKoAEAN_DGAeDQ4DBR0OACENIxQAAqwAALdlMR0ODbAAggQdDhMdBA00CwARA9AAIYQNhgDC
BVQNDh10BQQPFhQdsgCHJAwEDEQcBAwCAB-8-iod0aNAwyADHxMTDh8SDkP_PBAt-jsQEGta8QMD
LQ4NDjMADg0EHQUELQMOIwD9AwG2AFEOAw4jBacA8AEFBA4zdAUEBQMOI4QFBA0z7HSRNAUEDQ4T
DxZ00QABXgERDNIAECMzdVEMJB0OAxcAkCw0HQ4TPAQsFBwAHwOQCh5wBAUeFS4FLlwYAAQAAo4A
MBUEJcsEAIJ1QhQFNBUIAPAKBAVUBUQFRAWkBUQFNAUUBYQFdAVkBUQFJMUEkRUEBTQVBAUURT4A
-wAVBCUeBQ5VHhVuBQ4FTgXcRh5w-xIHFS4FPpcAQBUONV6NADE1LhWNABJViwBjRCU0BRQeowBB
HgQFHjEBsB6EBQRFFAVkBT4VlgAwBBVOjgBgBRQVPgUeCgCPJS4FPhUeFe6SAB9g8EITwDOw5gEQ
kLlzUAMgIzAOyEAgQzDBDUATHgNw4z-vEA4DYBMeMANwA_AD4A6lIB3-APC0NyAnMAZXAEcQJqeG
N-oIHfANkA8RAz8TYA4jDjNQAw4DHiMeQA4DDxEOAQMuDQ90sBMBDgMtEzADDR4BPQOgMA4TDQEO
Ix4DMDJp8Ao_DRMwDQ4DAQ4tIzATDQ4BQw5AIwEOEy5QNgD-AR4TYAMBDkNwAQ4jgC7ADuCZABzx
CDA5oCkEGaAZBCmgGQ8UGaAJBA4ECRAZnGSACQQAGQQJADniZRAkCgBBGQQZBCEA8hkEDhkQGQQO
JA4UDhkgKQQeBC4JBAkwCTQeJAlQCTQOFAmACRQO0A4EAwAfYFxxHmEKCUAKBwqJPGAJGgkgGQRI
Z-AJEAQZQARKGQRQBwpvFhlACh4WASYOCTAKZUPiFxYOCSAKDgYnAScGDgQKAPEGNw4JIAkOARcx
BwEOBCAJDgYXBgE2CgAUhwYA-wYwBA4nAScOCTAZBG4JFCAJEAlUEATDDx3wA0AeIB6ALgkeCFAu
CA4qGB4gCF8w8BcJCgkILggQSB4IHjggEQgeCA8TCB4IASABDQcBGA0DDRgHAQ0QHV94EBFMEHAR
DSMPHAMsKheg0wADDQMNQwEjAXwQYQ1TDCMMAxMAIKMQBgBTkxAtAw0CAF8dIAGdENAyHgGwAPAG
AB4IYB4IHgkOGB4wGB4IKgguCCA4fjjgDjggIS4ILggREAEPEwG0AAAEAKAdAB0BKAEDARgRowBy
EyEjESMPHJYAEAylAEABIwEjtgAA6XwBnAAlowCnAE8jIAG91AMd8B0wCAAIwB8YEAiQNw6QBwEG
J0AGBxAKBxEnEBcABgcGKQYnBgA3Bg8WBwAYlxIe8hMIHgZ3JhAODRZnFg0QDQYNFkcWDSAdBg0W
JyZAHQYNVg1QOx7PHYBdkAogCqAKIApAkwAtEICQAEFABgcAjgAQJ5gAAI4AAJUA8gMIHgYHBmcN
BhAODSZnFhAdNkeXALGGDTANBg1mDTAKAH8dzyYNUAoJbQngCeAKII8AMhBwjAAALAEhGIeQAAAY
AQCSAAAbATF3DQYbAQGRACA3NgwAEpaPABFQjQCvBhkNcD0KHaAJcMNYHvALFtAmwCYgFmAfEkAm
UB4PFSA2QB4dAB0WUAn1a-AJHh1ACQQOFA0_DTAJBC4EDgQeHSAJFD4E3n0QIFEEok4NDh0gJA4E
Dg0CACYgFAwAX2AdMR0wVDce8TkwGHAIHxgQHgiQPpAeOB5gDggfDhgOGA5QDggdCC4IDkAOOG4w
DggSPhIeMA4CET4RAg4wHggBPgEIHjAuCD4ILjACfgIOAjCKRwBiXBBACgBvMmAPFVIMCTQf9Csi
GGAYQAgvGCAuCHBOkA4fDigOYB4IHQgeCB4wDkhuEA4YvgAuEl4SHgAeAhFeEQIOAAIeGF4YDgIQ
gACfIkCCcB8VMBwwPjAeQBAYkAhTN3AOoA4AHqAOUGixKB8ODoAYDhgdDmAXOaA4YD4IHhhQAl4R
n1gxbgEIBwBuCA4SMBJuBQGfAg4SYHKAEgASkQ4eEBRGJvAOCOAOGB4QGGBIHggOUAguKA5wTigO
YG4YUK4wjhG9WZeOAQgSEAKOCAL-AEYCDhIghgAfkpoWHmAEPxcPFoC-fSAPFx5OoA8WYE4PFw4d
UG5kAjBAHhSMSlAeIB4EHpUCQB0OIB5XFLAdDiAOBA0eDQQuJAkAQC4EHgSMDlAPEgQQDnUUQAQM
LxULAHBeBAwrBBAeIgBADCsMBEcA-wINBAwbDAQgBC4kPARAJEwEULIAP3EPEAEdDAEQtABAER0R
ELMAQx4FHQW0AAQLAFEuBB41IK8AQB8SFRuuAEEbHxUbrgAxGzoLrADPC0oLEBQeK1oLICuKWwE-
MD4tMKQAMT4dMKIAgw8QAQ0ADAEApgAQEed8AacAEC5jWAFZASA_NacAUC8SFRsApwBBew8VAKcA
EQoCAI8aFB4rigArqlMGHvAoEjgSYCI4IkAiAT8YASIwMT4xIAQfFBc-FxcfFAQQBB0DDxMPFh8P
DxYDDxMdBAAEHQMHAQwfDwYA-xkdFA0PFw8PETsRCw8XDQQQGnsaQBpbGmBxcAFSAXByYJJwHRAd
kBQQXjogD5YARQ6UAA8pAWgQUJMAzxFQchRQch1gUqAUkJMANysFD5QAIxUNkwAgDxOUABQVkwAx
PAEVkwD-DhtsFQtAGzwVBg8WFUBhGmABQgEFAWBSAQUBUHIRNAFrACVz-xoQHxd7BQFAGlsKHxZQ
URUJBhUwAUIRFVBiARVAcgEVYB0QHQAVYBQQFKd1Hy-wFKYAAWAPFCE_IQ2kACF-F5oA_AsRHB8P
HBEdFA0MGxEbERsMDQQQHHscQBxbHFoCDyIBHS-wZCMBAxN-IQEyFz8PfwBgFw8TBx8PBgADGQFA
DxMBPwUAIQ8PwAFfHH8PHBCfASLwBT8YIkACDxQHAT8XBwEPFAIwAQ4RJQL3IQ8TEQ4BIAQOBwMN
Bx8PBx0HDgQQBA4MFzwXDA4EAAQenB4UDh8XfBsOBBArXCtAm-cDPx4QHi8CIvAOUhhgEhECARIf
GEASURIeMJESMI8UFw8XIDRPFAcsAvADDyAkLxQfFwcDEQ8PIAQ-FB8XqADwFAEfDzAvFD8XTw9Q
fxcPD2BxcCFCcBFSYBFyYA8UBDANBHANBgAfMIYEHg_QACA5Dw8HkQAybxcfkQA-YCFijgAqAh0B
EDKLAC8xMhsBIf8IjxdgcXAxQmAhUgRAMUIfFFANBNANBJAVAR4PiAAyoQEUATJgER8UUsCGAA8N
ASjwBkEiHjCRAgUwjxQHFSA0TQcDFSAkLYAAYQEVIAQ9HH0A8ggVMC0cTw8GDxZQXBUbFTBxFVAh
MgEVUCMCHw2UAScbIIcADwwBETEFAR0KAfAKDQUdDFA8FQ8WBjUwMRUbRSAhAhEFAXARIngFMRFC
IS0CQAoEcAoGAA9XBB4fFLsCAMB-FD8XIDQ-FA8XER2OAOkdPw8BDTAvFD1PD1BtHKUCQAsEcAsG
AB8w8QUnQw8YGA7QBABLBdIUEAQvFAE_AS0EAATdwgRCBF0EDHwGpwwEPQQMG0AbXBtFBA_oByQv
8ASEAA8fJIIACA4oCA8DAVxAcHFgAoIArw2CQBQNcoBSwBSGAQpQbT04fX0=
:: gfx/icons.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTEyLTI3IDE2OjM4OjUyIixtb2RpZmllZD0iMjAyNS0x
Mi0yNyAxNjo1NDowMiIscmV2aXNpb249MV1dbHo0AEIHAAC-OQAA8z17WzBdPXtibXA9cHh1AEMg
EBAE8CZHkGdwh2CHUCcAJwAnQBcgByAXQBcQJxAXUDcAN4BHoEegBwAHAAfwFSxmbGFncz0wLHBh
bl94CADLeT0wLHpvb209OH0sWgD-DywHwDeQV3BXcFeAVwAHcFcAB4AHADfAJ8A3wBfwFk4AHVAk
h1CnQAIAgTcgN-AFNyA3DQBfp1CH8BNLAB2hJWdwJyAnYBdAFwQAYIdgNwA3YBIABAgAAAQAD1gA
IGFUNzAXQFc-ARFnBABfV6A38DhGAB2TJgcgB5AnACdw8QDPUIdwZ5BHsCfQB-AXTAAeA90B5mCH
cGdwBwBHAAdwB0AHCgAvkEfXAR9zKAfQJ8AngJgAMJBngKwAADIBPwdgB4wBIiGHUNUBL0AnAgAH
L-ASWAAkBUIBj6AnsBfAB-Aa7gAhF7BGAQ_KASVxJAcgByAHYAYAA2sDDwYACijwBQ0AHxL5ASKx
JwAHACdQJxAHECfrAgBlAQAIAAESABFQHgAucGcDAg_MAxQVF0EDUBfQF3AHCACvMCdQl2B3gAfw
GVIAHYQpF8AnsDeQVwIAb7A3wCfQF5oAH0EnFwAXPQMxNxAniwMLBADvYDcQJ3AnACeQFwAX8BTF
AR--B_AnwEegZ4CHYJdQh2BngEegJ8AH8BtIAB1fJScAJ4AEABQPpgAfMCgHwJcDwhcABwAXgDfA
N9AnkAwAT2eQR8C7AiEAHgZ0p0AHAGcABwYAURBHEAdQzQIxcGewIwMPrAEgAVkDMYBngFUDBGUD
D3cFH-EJPBfAJ0AXQDdAFzA3UCcQN3AXADeAV6A3qQMPigIeECPUAmInQCdQJyAqAgKcAAPlBDFQ
J0BMAw_SAx8-I6dAAgAAD0gAH6cnJ8AnwCfwDSfAAgAPTwcfgCVXgHdwFzAXBAD-AIAXECewJ7An
wBfwDhfQF2cGJAceAQUEAARIAQ9mBCIXYwIFAwgFH1JEAB0fI1kFAA8TAAYPcgUqoCcnoAcAJwAH
cIc2AhRg0QZANyA3YDwCIYdwHgAeoKsBD4MGGD_QJ8DzASgCOgICAgAfkMsGKDA3B9CuBd_XQKdQ
l2An0BfgB-AoRAAdwDkH4BfQJ2CXUKdAl3kCT9AH8CZEAB0f8DEA------_rgAoKBLBZIHkQAgBT
CRAZEAkGAE95MDnASAAcQaBZMGlKAJ9pIFkwGXAZ8AFBAB2yeRApECmwKRApEHkCAB_gQgAcUMA5
QFkgQAARGQYAjykQGTAZIFlAywAe0dAZYDkweRB5IFkwWSCWAB_gVQEhMRkwGQQAAUIAAQIAD9IA
HvAE8AEZYCkQGRApIBkAKUA5UClQWVUAD9EAIRFQAgA-QFkgWQEqA9MAPykQKVkBIRegPAAXUFQA
D5AAHgDQAM9JQFkwWTBJQDlgGeBAABz-AOAZYDlASTBZMFlASVA5YFABHiDwCEEAAUsBTyBZ8AY_
AB0TBjoAALsAL-AIPgAdPwUpEAIAAi-wBYgAHxUwAgAv8AbjAh-vaSAZcBnQGXAZIGkgWbBAABxC
4ClQOXsAbzBZUDlgKUAAHYDwABlAGQApIB8DEjkEABEgTQJPAClgGU0AHTWgKRACACPwBgkAD-kD
IY3wDxkAGQAZEAYAL-APdAMegjB5EAkAOQAJBgAxIFlQxgMPrAIekAApYClQKSApAHcDb0lQKXAZ
0D8EHkBwKWA5tAIAgwQfYEAAIFBgKVA5QPQCLzlggAAiBG4DT0AZcBlAACEANgAVQHQDH9DOBSEE
iwECBAAAHQJPaSApYOcGHzHQOUDEBQEEAD9ZIFlFACIBsAL-ADkAKSBpMClwKTBpICkAOa8CIjMI
GUDyBxMglABPIHnwBaABIFVQCRAJQEMAAuUFH7DzAh4TUAIALvAA6gIPQQgUX2ApMFkwQQAjErC8
AAcLAQIMAB_wtgchYlApMGkQSf8DAHcDH_CeBR4DhgAQwAYADmgGD0IAGBPQjggv8AWRASIBpAUP
kQki79AZYElASVBJMFkgKQAZ6gIjJXkQAgAPcwghAQUBHyBvBycAAwEwQDlQpQY-KVApawgfEMA9
ARQJAgAmECkCAC-wAEsAHCLQKWcDYFAJgAlgKQIAH_BNASEpGTCZBgOjCi95oEwAIBGwlwEPGgIk
QilgKUA_AD9pIGljAx0yoGkgbgw-eTApUwYhANcBAtQCAOwMDysEIFA5UGkgCUoBBQQAPwkgacYI
H4GgSUB5QEkQGc0IAwYAP0AZUE4JH0E5IBkgAQkBdAQhSQAMAAAUAC9QOZwBHwDvAjJAOTAaBj8J
UAniASETsBgBEyBgAgU7BwQEAA80AiATcJkNPzA5YAcIIBCwxQMBCwgRcOIAH7DyAiAEGwYEBAAe
IBoBD0gAGhNAiAIPXgEeMEkwafABAIQCMTAJIMYHAMoMH7BgEB4PMQD---------------------
------------NVBtPTh9fQ==
:: gfx/t.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI2LTAxLTAyIDE1OjQ5OjEwIixtb2RpZmllZD0iMjAyNi0w
MS0wMyAwOTowODozNSIscmV2aXNpb249MTBdXWx6NABUTwAAPKoAAPAJe1swXT17Ym1wPXB4dQBD
IBAQBHMPEwMOAgAikw4IAK-zVg4DDtMOAw6zCAAE8wBTLGZsYWdzPTAscGFuX3gIAMp5PTAsem9v
bT04fSxiAPIEA1YPFmYTVg5WI1YOVhNmDmYDZggA4hNXDmcjFQ4FTgUOBSNWGAADJAAFBAAXIyQA
HxN5ABwxdwYHAgATlwgAr-dWBgcG1wYHBrcIAAQfV2EAHBAH2gBhF1YOVhdmBABBZgdmDhAAM4cO
l7QARCdWDlYEAAQiAAAEABV3IgAfF3UAHLVxdXF18VD1EBEFAQIAN0EFAQwAb4EFUYXxFFcAHPEO
0BSwNJBUcFQVUBQFJBUUMDQFBBU0EFQVtBVUFTQEAPAERCVEBVQVVAVEJTQ1JBUUBRQlFCQAMjU0
FSYAD3EAHPAOFdA1sFWQEVVwFRElARVQNREFATUwVRFVEBFVEXUEACAhRQgAsAEFETUxRQEVEQUh
KQAgNTEpAH9VEVUxVRFVcgAccABfFhBeAB4lARA_BQBCHgQOMQQAMG4EbtsAcBUERQEFBEVfACcR
BQwAMGUBZQgAICFVjwARAaoA7xEEBTEFBBVRFVRFIVQViwAe8BgTHxPDDgMO4x4DDmMOE04DDhMO
Ax4TDgMuUx6jHgMuAw6DXqM_Qw4kAGDDDuMO8xQFAB8JZQAcofMBBgM2E1YDZgUCAEEPFmYOCQCk
DmcOZ-4BZg5mDhEAAwgArwVmA2YDVyNX8wFqABzwFxcWxwYHBucWBwZnBhdGBwYXBgcWFwYHJlcW
pxYHJgcGh1anNkcGJABgxwbnBvcUBQAPzgAdUvcBVhdWpgAPzAASbwdWB2b3EWUAHHjxAd8WEQUO
AgAADwAgHjELABAhDwAyMRYeCQAzIRYBCgBRERYRHhU2AEBVHgUNCQASjg8ABAIAYxURBS4FDgIA
FCEMADElISUIAG9FIdUR1fFzAR0AdgOgJCVEJRQRFVQVFA0EgkQVFCEFATUEDgAgAVUOABdlDADw
CYUQNjA2ECYfFgYQJh4GENYQXhZeEC4WjgQAnzAOFg4wPkAeoIYAHPALFRFVETURFSFFIRUhFRFV
IQUBBREVETURJQGvAwB7ACE1ARQAITFlEgASdQ4ABYoA8QQwBh4GEFYwVl4wPhYuFg4wDhZeBgAx
LhAOCABvDkAeUB4glQAc8QhVMZURNRFlARUBFgEVAUUBBREWMQUBJQgAEAaBAAIKAPIEIQURBQEW
MQYxBRHVAZA2EBYQFh4BsNYQHhYeFl4QrhYOBABfsA4WDsCFAB7-PvAUMZARMhFgARIZEhkRMCEi
WREQARIRWSIhIgkSCSIZEgEQMSApQAEyEQIgAkAREhkROVAROREQAiBRCSIRAgCRIhEAAQKREiEi
CYECHQIdgQDlAE8WlQBOAwBA5QAutQMA8QLlAB7FAB6VLgAeRS5FAGUuRSAAMTVOBQUALxDVZAAc
-yP1EF8WVZ4VPiEFXhUuMYUuhT4VDiEGRT4VDhEGAaUOAQYRpQ51PiVeJT4VTqVOpU71EmEAHPEX
5QCVTxYAPlVOAAUGEQ5FTgAFMQ6FAEUOZR4ABREWLkUeAAUBFgEIACEWERoA0VUuAG5FLgAVTnUA
lU46AAAEAC-VEAUEIesOtQ4RDqUOIQ41DjUOBQgAcBUOEQ4FLhXsACMOtQQADygAAQAIAFEFPgUu
JSQAD_QDHmAQNjAPFiUkA9IwHgUOMDYwLgUwPjA_rQMGBgAAJANBwDYwNikAAAQAYFYQVhA_FgMA
AEoDFV4GAA-jAyLAEDZAFkAGHxYGQBZACwB0PkAeQD5AFgQAMdAeQM0DAnsAUBB2EFZeegC-fhDe
EF4QPjA_8AJwABz0GRIANTAWMAJFBiAWMEUGBSAWIAYfFhUGFSAeIA4VDgYlIBYgDiUOFTAHAGMw
PgVAHsC-AxYevgNP3hDesH4AH-EIASIpQRIhIikCERIBAiEiKSIhAhEAEQIIADAgERkHAP8UQBEi
QXARAiGwEcBxgFGQQaBFcJFAoXBtMA0wDQYIBggGDQB1ABzwCBAHKkAHCjAKKRogChkKIAoJKgkg
CgkKBQBZOiAKCRoSAAQKAP8UCToJIAkaCTA5QBnwHgXQBUARUAUABUABcDUAEZAFECGQFTCHABzw
FSAK4AcJ0AoJ0BlQF1AKCVAXUBnQGeAJ8AthkEFABUBBUAUwRWQAzwCBADUQkRAFIG0wFRcFHvAl
AgoQCiAJMAkwGrBasBogCVAJEAoQCvAECRAJ8AQhsAEZCgEwNhARCQoJERBWAAEJChkEAQkA8AYK
GQQKARBGDQABGQQKBAEQDSYdEAEKAE8wPTAh1AId-zjwEQkwCfACCfANCfAHCRAJ4CZAFkBWECYN
AAYQNgAGEA0WDSB2EB0AFgANAEYNBhANJg0AJj0QFg0WDQBdEBYNAB0gHVANQHYAHdAEFhARMBEQ
FAUGIBEQCADwHAQFFhARAAEQFAUUBRYgAgECEEQVMCEQBSQlkEWgBtAWDWAGUA3wEAYQFsAMAJAA
FhAGDXANAAYYAA99AB3wBRABEAEAAQABIAEAARABEAIBAgABcwBgIFEgMTAxkQDxB4ARMBHwCitA
KzADKwMgAysDEAZDBgAEAPAFFzYAJhcWEBcvDyAeFw4gAy4DEA6nCq8ADgAjAA4gMzAjCQIesAkR
ABGQARgBEgEgAwHQARgiARARAgECAQABQqMAEBGvAN8iARABUAEQAQIB0AHgmgAB-AA2FwYAFhcm
EC8PFyAOFx6aAE8QM0Aj-wUd8R4gBR0QDUYNMCU9Jg1ABRAFDRZNIBUQDQdWFRAFIA0XASYHFQA1
AA0XBkcNBQASADA3Bg0bAAJnDvMSFg0gBRAdFgEmDQZADQcGXRZADRdmB0ANhwZADQZnBgdQKACf
BgcGUB1mDXBtLgQd8g_gBR3AJR3QBQ3QHQUNsA0HFQ0GkA0HEAUNkA0GDRAGAPEFBQ2AHQcNEA1w
DQcWDRAtUA0nDQACAP8GQA0XBg0gDWANBgcNIA2ADQYNwB3wggAdkA0YBhgNEB0FMAkA8hAtJTAd
BgIGLQVgFj0GHWAHFgEWFw1gdw1gJwEnBg1g6gDwBQcGDWAmASYdYG0GBw1QZgcGDVBnCgAQVxoA
ElAiAAAkAF9mHWBtgI4AHIHwCjcwLTBXENoAAwcAEUe0A-EFIAYnFiAtQDbwDjGAYRAxEHEAUQAE
AAAMAE_AYbAxagAc8B8QJ0AXQFcQJwYABxA3AAcQBhcGIHcQFgAXAAYARwYHEAYnBgAnNhAXBhcG
AFYQmgL-GCAWUAZAMbBhMAIwcSASAAIAcXBxcHEAIhgQYQACCAkoEDEwGCkIAoEBHfAAAAfQFwZg
B1AG8BAHEBfADAD-CAAXEAcGcAYABwZgB-BNLbANJg2QLQYtBAYd8AGQKzAXGyAXMyBDEAcTJwYQ
BADwBgYHDw8BDiAGBw4BDjBOIE4QAy4gDgQA8QcAIzAzQCNAF0AXG0ArMEMgQxAGRwYABABVDgEO
AQ4IAE8QTiBONQQxzxdgBysgBzsgB0MwM6AAFm9gF0AbFzCgAA4POwQx8gBQLUAdQA0nDSANF0AN
AhcIABASagMwBwJQEQDwAwANFwJQDRIHLQcSYA0CRwINUBQE8ARQDRZHFkAdFggnCBYwDRcNFgcC
RwSADScGDUYNASDSAjEBTRHaAjAxJhHaAgEHAH8GDQYNISYhpAAc8RUN4AcN0AINsB0CDaANFw2w
DQIHDbANEoAtEA0CDWANBw0HDQAKACEWBzoEEBYQACAmDQkA-w0dNg1ADSYHDQYNFg1QDSYBDQEd
cB0GIbANIcARjwYeQA1ALWAaAUgXAg1QCABCBxINUCkBUA0QLRACKwEiDQCXAAAxARAQ0gRRAGcG
DQAJAFAYJxgGHeQEAAkAUg0HJg0QPQH-CQEmDSANRg0RBh0wAQ0GAQYNIQ1QES0xYKcAHHBADxZA
BYAFBADwCw4gBZAVIAUQDjAFIAUOEAUgDjAFEAUOAAVAFwlBDmAFDgUA-xFADgVwBQ4wDgVwFTAV
gAUOEA4FoAUOABWwNQ6gRbAOJYEAHPAWIA8WYAJQBdAFIA6gDgAVQAIoIBUOMBIICRgQFVASCBkI
AgAFcA8A-xsCBfADDuAF0A7gBVACCAJADkACAAgJCCAFDnAICQgACAAVYAJYgBIoCQiCABwQMHcC
URcGDVAdCACQHTANBw0mDSYNRwYgFm2nAhEmAgDyKTA9BgcGPXANJg2wLZBxYAEtGg0FDQFAAQ0T
ChMKEwUBIAENGlsKAwUBAAENChsKawMFEQ0DOwpLEgBBA0saCwoAcAUBBTMKEwqmDw_pABzwLlBB
gBFEEVABBAEJCykhMBEECQQDGwQJFAEgAQQpEwspBAEQARQZBAkTBBkUAQABJAFJASQBAAEUARQp
FAESAFEEAYQBBAgAgQQKRAoEAQQBYgowCiQKaArAIAGkATABCmQKAVAREQBvChGAQfAFpAAc4PA1
UWAhVCEgARQBWQEUYABQCSspBBl2APAXFAkjKxQJFBEUARkzGQEUEQQBFFkUAQQhBAoUORQKBBEA
ARQKVAo0AO8KlAoBIBEaBBoEGhFQceYLHlAtFhEmEckD8D4BJh0HQA0WDTYNBwZADSY9FgJQDSYN
EA0GAmAtIA0W0B2wEbARHQFgQR0FEUABLQEFDQURDTABPQElAR0gAT0BCCEIAQ0gAQUtAQIoAgoA
ryUdASIBHTABRSHnAh3AHaANBgEXDZANFgIGBgASEgUA-yCgDQYCBg2wLfAeAeANAdAdAaARLQFQ
MT0FAUABGwEtJQEwAQsDAT0VAUABEwEFLXUAHLARJiEGDVCGDVANRtEEYQZNJg1QFu0EYWAdIC3w
LP4AcYAhHQUhYA39AMEdMSANASUBPQEbARD_AGE9AQMLAQD-AF8tBQETAcgHHWmwDxYVwA4DAPAO
DpAFDjWABRAloA5gDmAOcC4wDqAOEBUOcCUgFaBMFF8O0CXQFZkGHfEF8BsC4BIAArAIAgASkAII
ArACGAJbBP8aCBkYwBXQFVAOQB8TFQ0wDgVAXRAOBVAdMRAFEAUwDUEQJUANQQAVcDFyAB1jMHFg
AT0FAwQxIxojAQQF5gORDQMLGhsKGwoLBgQVmxQAFEsEBGAKEwoDGgMGBAlJACEaU0gARQobChtK
ACF7GkUAQmsKGwoRADUrGitHABIDfQQPTQQisDQhUAEUARkBJAEwOQRBCxkUCkwEQRspBApMBDEL
EylCBCMZIwgAMgMJBAoAcQkEKQQJFArYA1EROQEUCkwEMgFEAUoEAAoAzyQBMBFEARQBUBE0IUoE
KzBJARSQAFAEGQQrBCYPsQABFCkLEykECgQRCQDzAiQRFBkEEwkEGSQRJAEJExkBmQAxAVQByQBA
BAF0AVIEH3ROBCDxCUABlTCxIAEFAQMBAwojCgMBEAEFHRELAwIAAIQBEQ27AfAISwEFADEFDQEF
QRUAASMhdQABGwMxVQEHAPAKAQWBAAEjARUhChkREDElQR0wAWUBDRVAAfUZj1ABRSENYIHA5Qgd
4AUBUBEDASUNIVAxJQMBLwSAJQEVAQUdATC-GQJNAuAlERUNITARFREFERMBQK0WsBEjAVABBSEF
IWARMBYwcAElKgAwcAFVCwDfIZABFR0BoAEFIbAh0I8AHBANGAUQJSEE8ggVIUUxEIUBJQEQgTUB
EAMaAxoDESUBIAkAMBURICoB-xsBBREwBQELAgsBBREFAUBxBRFAEQoZESUBQAVBNQFAlQFAhQFQ
dQFgcfDMBx3wCrA1sA8WJVAOQCVwHiAOBaAOAA4VsCXAJbCJGDCwDhUTABAlBQAQFQ8AIjWgEgCf
BQAVkA4FEAXwRQMd8AgFkBXQFcAPExUOoF6QMR6QQQ6QQQ6gMXEE-wrADhUekF4ABXABLhEAFWAR
DiEAJVAhDhGgaQQrQxMaExpqBAUPBBEaVwRBEQ0DGzcEBDYEBCMEAZwEQQURFQGqAlElARURDcIY
gREdtQEAAR0FFwAyNQEgZQBvFQFAkfATmghnAAgAMxABpI4IX4QBUBFEiAhUvzQ5NBEAAbQBEAG0
LAQhIBgYHg0hLbAeDTMnDaAfDQCFDBMS9wsUsCINIg3AIw0hDdAkDRDQJA0gDcAlDSINsCYNJR2Q
Jw0zFg1wKQ0zJg1gKw0BoAwBLg0xIR1gLw0jIYAvDSExkAAJIS2gAAkzJw2QAQkBeAhiJj0WIg2g
BQlRIg2wLSCQCF-wAz3wDuwAPBBgbw0G5wwDdw0YEu4MAYENFg30DAKKDRQG_wwQEJENFAYADREg
mA0EBQ0QMJ0NBQkNQlAdBhEMDTOADSENDYCwMS0xsA0GIQMJcaANpg2gDRYGCWCgDSZNJg0_EAAI
CW-QLSAt8Fj7ABr1ByAE8EBx8AFR8AJB8ANF8AChsMHQbbAbFxKwXRMQsF0TEsBdExKgXRMTkF0T
MyUNYF4TSBUNBjBiEyYNUGUTRB0QDWBnEwAbABFwaxMC8xIQF2ASALsONYcGB-cSAHsTALMMFnB-
EwABE38dZh3gbfBx4wALHzbjAADwGKAFQFEwBVAFUEFQBSAFAAVQRVAFMDUAoQA1MAUQwRAFQBUw
bTAVUO8AAy4TMWAlLS8TMZAFLTATIMAdMRMxwA0XMhNxwA2HDcANBjUTF8CkACDAHagCQLANBwY7
ExKg3QARoNsAE6DVABmwLwAB0QAfidEAGY8gIATw----8_gBDA80AJYPFQaTHzAkDy4PogBRD8ML
Lg_lAFoPHwwjD6MAHg-1AiEPNAC14AgIBJAKEApAGjBaMBpAuxsPYx0MHDk-ABCAfBufAQlQCZAJ
EAmQPQAhTwgJ8Ag4AB4v8A02AB8v8DAxAEoOgAEPrQU1HDYnAy-w8OUBDA8xAO8PjgFVDicCD2UA
FA80AP-------zrA0DgfGBgeGB7wAjgeCACDUB4YUBjeGDAHAJQSPhBeEh5yPhAJAFEwUh7yBAUA
8wFwHjIfEhccPRccHRJwHjIdCwCVMBgeMj08NTw9CQB0ED4SXfUAHQcAdDIQHRU9tT0IAKZwHRUf
Fh0-FVVdCgCIkBUfFj8VvRUIADYfFd0IAEE1Eb01BQBgcDsV0RWQBQBxcDsQMXAxkAYANnA7MAYA
zxtQPxRwOnAbUDpwOmoHHlI0PxgYMBoBJXA_CgByEj4QGN4YUAcAIXAyGQESUAcAIHASGwEABQA2
EBheIQEADQAEIgFxEB4SEDIdFRsBBgsAEHAdAQIFAAQYAQ8eAS5xkBsV0RWwGyMBUjFwMbA7IgEA
EAE-kDsQEAEg9A5wOPAMOPAGOBA-GBDYUDgQPhDYUB4YEB4SWJ4YMAkAYlA_Ehj_AgYAYZBe8gAe
cAUA9AfyCHDyCBB-Fh8SNRccNRccFR0QfxYdDAAwO1U9BwEHCQBlGxVQXbU9BgAyfXVdBgCwsP0C
0P0C0DG98AAEACLxAAQAMnEwMQUAYQIxMDHwBAUArz8UMDrwBDowOlDoAByBUB8YFR8WELgHAAkN
AKIwGBIVHhj-GAAeCgCo-QAeEBg9FR4d8gkAZT0QFR7yAggAUnAVHhIV6QAKDACSHxJVPDU8NXAb
BwAwW-UCBABBkFu1OwQA8wp7dTuwe3U70PsC0PsC8ADb8ALb8AKx8ASx4AAOBQAP_QAu8QNYHxgw
GD7QWB4wGD6QOP4AWFAFAFJekh4wPgYAcDA_8gJQPxYGABE9AwQwHww-BQA7FX0VDwDAEj8SFT8M
NTw1HRUwDAASPAsAcxsVHRv1AHAHAFM1HTu1GwYAMVV9mwQAQBu1e5AEAIQfFfsCcRAfFAgAVT8V
e-ECBwDyCBA-FbFwMTA6sXAxUDqx8AA6sfACOlAxBQBQBDpQPxQLAC85kAMBHPEE8DgfFhXwDB4V
8AQ4MB41sB8UMAgA8AIdMBgfGBgcEB4fElBRHTAYHAwAEBsLAIQcEBwbdRBxUAgAYhIYG7UxkAYA
UxgcG9URBgBzHFuVHhURcAcAYhgSPwwbdQoAFDoJALcbGhtVGx4VURAfFQ0AlhkcMlsVOx4VcQkA
pzwSGzo7HjUQURAKAJgyGxo7NRsQGTELAGUSHFKbEDkIAIIwsjsQOTA9EAcAfzCSMDnQkjAlAR-w
FP93tfAEtfAC9QDwAPUA0BI1HxW1sBI1HrWQHxgSHxIeHR6VCgARHQkAhjwSHR4VPXVwCABkXR49
VTEwCAARXCgASD01URAKAEI9Hp1xBgBiEhxyPdURBgAzELIdBQAPswAd8gJyHxgY8AweGPAMEj4w
OF4SkAcAYNAeGJ5SsAUAcXAYHhieklAGAJAwPhJecn8WFRAIAJN9FRA_ED4yXZUHAJNwHhI9VRcc
XxIJALdbEDEQGxJVOxxVGwoAVVG7VRccBwCkHxQxm1UbHDsQGggAYxAxezV7NQcAUhBREPsGBQBS
GhFQu5AFAF-wDhrwDOgAHYCyHxgYULiQHgUAYRI_EB7YcAYAk7ASHngeGD4YkAgAUVA4PjjeBQCD
MBheGF6SPhAHAIMeEhBe8gAfEgkAUR1wPlLdBABzHjKdFxxdUAcAYB0SNf8WAgcAcfsCEFEd9QYF
AHEfFHH9AjAaBQCPkL1wGpC98DjBAB0VtqkB4j6YMtA_mDKQOBB4XjJwBgBhPhI4nlJQBgBBkBie
kgQAsD4SHlIfEjUdPxZQCwDzAB01HTwQMR6SHRUXHwwdNQsA9wEbHTUfFDEeEjUcPRU7PRAaCwBk
EBE9VTydCABRUBFddZwFAFMwGjF91QUAX3C9kBpwzgAf8AdwlhUfFfAClhUe8AAWHxZVPRUe0BYd
BwCmsBYdFXAVHRUekAkAKhWwBwAWFgcARRUesB0HAFBQ9goVPgQAt3YdNR0WHRY9HhUeCwBQVh0V
MRUNADgeFT4MAKY2HRVxFl0VHhUeCgBRVh1xNj0oAAIIAFI2PRUxNiQABQoAI1YVJAAUFSQABEcA
BAkAURAdFh12CgAVMAoAj1D9AH5w-QB_ZggeEFYzAfECBlYVHvAEFh8WFT0VHvACFh0IAFAAFh0V
MCwBFtAJAEUVcBY_BgAg8AwEACEVHgQAHwgnAcmx8Dr-FQaQ-gZQPvUEAEIwHvUKBABQlR8WNR1r
BzEelR0JAJkQHrUWNRYdFRYKACCVHQkAAAMACgwAMbUdFgoBCgsAMlUdNgsADQ0AUXU9NjUWUgAG
CgB3lT0VFhUdVQkAVVUddj11BwAzdV3VBQBEVZYdlQYARJU9lT4GAGJVHXZ1HjAHAB8QGwEd8AAw
-xUw9TQfFjU_NR71AB4HAMbVHhYVPhY1Fh41FlULAJg1PhZeFj4WPhUKACEWHgIAFz4GAA8OABNR
Xha_Fn4GACD_AEkCZRUeFh4VvgoAIF4VCgBHPjUeNQoA71Ue9QYeVR71hv8VMPAw6QAgAAQCUZD1
Bj5QBAA4Ch4wBAAQH48BdR01HbUeEB0KADEWFRbYAQsLAADPAV89FhUddQwAAAAlAD02HTUOABEV
AgBLHRYddQ0AiDUdFR0WFRa1CgBBdR01PTcABQkAVZUdVj1VBwAz1T2VBQBUPnWWHTUHAFMwHpVd
dQYADwoCHdBQ-xUEsP4EcD71BD4wBQCDEB5VHrEeVT4GAIBfFjZdVT5VXQYAVJUdNh2VBgAmPRYG
ABJ9BAA4tT21BAAAnwBCPXU_MAYAZR4V-gQVHgcAJPUIBQARVdwABggANXV9dQYAV1U9Vh1VCABV
NT02fTUIAA-sAB30A7A4fxjwBDh_0B4SGD4SHjIesAkAEJAJACHScAYAYFA_Ej4SP5kOERwLABE9
CgAQHu8HSB01PDULAKCQMh8WPbUdcDIbBgB1EjUbPTs1PQgAUj01OzV9BgDyBpA9dX2wPXV90P0A
8AD9AHAxEDG9EQYAcFAfFPEKEDoEAEEQUdBRBQCfGvAKMfAMMfByzQEdED8UCKTwBj4QEh4QOH5w
CACUEj4QEjheMh5QCQBgcFI4PrJQBQAikH7sACGQfukAMJA_Ml8OJB1wCAAgEh1hBhCVCQARGwgA
ZR0bNV1VPQcAMTX9AgUA8QCQNRvdsDUb3dA1GzFd8AAGAGACNVEd8AQFAAKVDXACHxSR8AQaBAAi
UDEFAF8OOvAMOl0LHdCwWF8Y8ARYXrAeMlg_vQECBwBQMjheknAFAABbDxFe1wASHQsAAFcQmDA_
EhA_Mh01PAoAgR4SMB1fFh2VCQCTWx2VsBtVPVUdBgBSNf0AG5AFADEbvTsFANCwNbHwADWxkDEQ
8QJwBQCBUB8UkXBRUBoFAEIQUbAxBgAAvQETDN4AL-AyxgEpNFhecAgAAL0BAOkAFFAJAGBwUlg_
klAFADGQnhJLETCQnhJGESGQXjURBAcAEDIaEdS1kDIVGx21kD0VG111BgAxNRu9BQBRsD01O30F
AGDQPVVd8AAFAHEEcfAIcfAGBgBUCFHwClHVAG8-FPAMOrDVABywcJhfGPAAmF5wHjC1AAIGAIQ_
EF4yvxc-FggA8AUwUh0-F90VMFIdPN0VPhAfEj0VPaMKKTUwDQD0DB4wHxI1G1UfDFUwHjAbNRtV
GlVwEZt1Fxo9MAcARLtVGhsHAMH-FQY7UPkGO5Ax_wIEAGJxu7Bxu5AZEWHQUTBR8AAFAIIfFBEw
UfACFgYAUTAWMfAEBgB-ChbwDhbwCPEAHPEMkB8V8A4e8AY-FDA_8AQ9MD7wBjEwHnASHxiQCAC1
HJAxMD5QEhwwHDAJAGWRPlASEBIIAHMdELEecBIwBwB0MTAxtRw4EAcAcBAxlT8WHFgIALA7HFhx
lTsVHxIcOAgAEBoHAFMbFTo8GAcAZXB1OxVaHAcAVho1OxV6CAC1MBsVOjsVGh8MFzoNABAZDACm
EBtVGjtaGRoyHAoAhBs1MFoZF1pSCABzNXBaGToyMAcADyMBHPEC8HA-GJCYcD6QmJA_MPgAHlAG
AGCQPvgAPnAFANEQftj_AtjeMF5YnhI_BgBAcFKecgQA8QQwPxZfEvIAHTA-Fl3yAB0QPBVdGwIz
FxsVDQARGwwAlTwVEBVdOzU7PQkAgRwVMBU9XxW9CACCWr0cFVBa3RAGAGI1EFr9ADAGAFMVWnEQ
kQYAYDqxEJEQWgUAHxrhAB0SMMsDEAzZABFwBQDQXvgEUF74BHAe2H4YUAUAsnCY3nCY3jA_OJ6S
BQAwnvICBAAkcF8HEzQdcF0KADFQXxYzFiFQWwcAwDA7NT8VHXVdMDs1OgcAZhsVHTr9AgcAVDr9
AjEQBwBUOjARvVEHAJA6HxSRkDEQOhkGAGQaEBmRkDkHAA-kABxAPxAw-NwAgPwAcF5cvhxQBQBx
kB4c-gIccAYA8AFQ-gpQ-gowfjUXHxY1Fx01CgARHQkAVD51PTU9BwBScBUd9QQFAGA1HZU-FTUH
AHI7NXBVfTtVBQBVFRCVHXUGAFQeNRuVHAgAQdAeO74EAEE7HnA_BQAzsDs_BQA1kDsQBgAI_BYP
rQId8AWQtvAEtvAANrE2sDaxNpAW8QQVcAUAalAW8QgVMAUAWRAW8QwVBAA9sTCxBQACHAARNQMA
MBUQFT0ACgUAIFAVZQAABQCgkDWxNbA1sTXwAFYSDzAHHfEBcDc28Ag3NvAEFxYVUDbwAAcActAX
FbAVFrAGAEMWEDeQBgCVkBYVEDeQFRZwCAAv8AQFAAERFwUAYpAW8AAXsAUAAkoAAAYAtdA2UBUX
Fh8VHxKwCgBw8AA2FxYwEQsAFdAKACLwDAcAHwoOABNP8AwRHvwAHIPwdDcasBo3cAYANDpwOgYA
UloZcBlaBgBxkBoZsBkasAYA4PD8GhnwDBoZ8ApaGfAIBAAjNzoEAH8a8Ao3GvCGggAcsBAfFXWf
FlUfFTAeCAACzgonPTUIADV1nVUGAEY1dh2VBwAJDAtHHXYdVQgANTW9dQYAIhUdMAAECAA-Vb1V
BgACDCgARhX9AFUHAFc1PXY9NQgANVWddQYAVxUddl1VCAAGfgAPMQQd8QiQvxXwBL6Qnh8Wlf4E
HZWeNR4d9QIedQYAhFUeHTW_VR41BwBVNR6xHjUIAGAVHh0VHvGuDgQIAB81BwAxKx4VaABTNR5V
vlUGAGBVHvUEHnUFAJA1nrX_BLWekL6_AA8EAh9AVX8WlQQCAAgAARoNULV_dT214g5DfXUedQYA
M3UdlQYAMZU_tQIAQPUAPjWXDXE1PpUdFR11BgADCACGPRYd9QIdFl0HACQAPQcAED0kACV1HQgA
gR2VPjU_VR21BgATdVwAQJUeNV1wAAIGADNVfVUGAGI1PpU9lX5mEBG17gEABgAP6AEdhxD-FQww
-gwwWg4ylX8WKg4g9QwDAEE1-gQ1BQCJfvUEvvUEXhDwAgYiDkU1-gA1BwBCXvUAXgUAByIABAUA
JBAejA5TdT02PXUGACKVnQQAUnUdNj2VBgAPRwQe9AU6Pxg4PhAfFhXQPjg_EB0VsB64HgYAU5Ae
_AAeBgBWcB4YHtgHADF_uD4EAEK_WD4SBQBTEv4CEhUGAFMVMr4SNQYAMFWyVQQA8gQw-xUAMpwQ
-AAynJA1MhUyFfAABwByAhUyFTLwBAYAAY8LAiQOEAyPCz878ALRABwQkNAA8AHwBD44PvACHrge
8AAeuB7QwgAQsAUAIXAVwAAlNTAIAER_uD4VBgAAyAAEBwAfUNAADLBQ3xUynTDdMp2QVboAEQAG
ACcCNQYABZYbH7rDABwAbhxB2JAVHgUAUBC4XxhwBwByXXA1WP0AUAUAQh4YPdIGAADSACIdEkcJ
CAwAQVAYNR56GwkKAGAdNR8S9QAIAJIb9QBQPRsVO9UGAJBwHxURe3U7cBoGAGFQOjH7AHAFAFEa
kZs1UAUAU1EwEXtVBgADUgwSGQYAMZHwBAQAMXHwBgQAX-AOGfAO9AAcAWAesQwYHxgQHhjwBhge
BwD2AX5QFR8W0H5QFR3wAB4SODAIAGnQFR1YHhAIAFQYPhIfEgoAERwJACAeMj0LExUKABAbCQA3
ElU7BwByFxsVPxQVHAoAEToJAGY7NTE8kBoIAGYcVTE8EHEJAHM1HTxRPJEQBwByHDU8MVwxcAcA
UpB8URxRBQDhHxVckdAZXJGwORBcUdAFAA8RARwSEBIBYB8YOPAKHgQAQRA_8AgFABF4FgFgeFAV
HbAY7QAYMAkAfB4VHT4SFRAKAEkyFRccCgBnEhUdVTw1BwB4HD8UNR8SFQsAeBsVHRwVMVsIABk1
BwCFOzFbEDEwHxQLAHQaGzU7MVuRBwCDEHtRG1EQMTAHAOEfFVuxsBlbsZA5MDtxsAUADyYCHTAQ
uNAEAKAYHxhYPjgesBgeBwCh0FjesFjekDhesgQAMBg_MiMREDUJABA9CAAzcl08BQCFfRUfFj1V
nxUIAKk1HxZ9PxUfFhUfDAAwnTV-BwAkNRAJAMEwnbWQnbWwEb0R8AAFAKHxAtDxAtAxcHGwBAAK
AgBQ0D8UsDsCAB9Q4AAkMB8YeN8AEB4GAI-QOP4AsDj_AOAAFzl-FRAJAGqdHxU-Fh8MAPIOXVVf
Fj0QOzBdVVs9EDtQPbU9sD21PdAR3fAAEd1ZIQAEAEExcFHQBAAokDEEAL-wAD8UkDrQOpA6cOIA
HBAwUiFxeBAVHrAVHggAg5AYFR4YfxgYCgC7fRgVHnA4FR49Mj0JACAXHPYABAwAEDsLAECQHRUe
2AQICQAg9QQEAFKwG-UAGwUAUzsVG3U7BgBSWxUbNVsGAFDQ_wDwAAQAAPkEMVHQGgUAQBDxALAF
AGSQGjBRUDEGADMQUXAGACBwGs8dEJAIABMZBwBC8AA5UAcAD3kNHRQ4CwEA0gAFCQACDAEjcDgM
ASOQHQMBCQkABAwBJZAdDAETsAIBBQgAP-UEsAgBHECbUdAaBADE8QKwGvECkBpQMVAxBgAGEAEw
cBowBAFTOVAaMBkHACDwCAUAHwYAARxQ9jDwtBaYDRFQBgDxBPC6HxWQHvACHpAe8L4RUBGQEZAG
AC-wtlgAHPMEkBI-GBLwCBI_EvAEEh44PjLwAAcAUx43OD4SBwCD0BIYNzheErAHADMeeH4FADM_
OJ4FADIS-gAFAGHQEr4S8AAFADIyfjIFAPEABHLwCHLwCj8V8Aw98AwyAwAhHhIEACwOHgMAHwDD
ABz1B3DR8ALR0DHVMZAx1TFwETVWEVY1EVAIAHcVNjcVNzYVCgC4MBEVNlcVVzYVERAKAFsWdxV3
FgoADygAAZsRFRY3ETUWFVEMACM21yoAAwgAShb3AhYJAFg2VxZXNgoAHzCeAAAbUMIAE3DaABDQ
5wAv8Dp4DiASX3QMAAgAAEELVB2WdT4QBwAzlT3VBQAAXhkVlQcAdzUdNj01HXUJABC1tRo4FR01
CgAAVAwD0BoLDQBBNR02HeUaLRYdDgBfdR0VFj0MAAARtVodKxYVCwAhHTWUGwYKAAbDHQIEAATb
HQDiGy-_Bh4cHvAGEL8VEJ5wvhCeUF51PnW_dT51XlUeDA0TdQYAwRV-FhUeFV0eVR4VfQkAhnUe
FV0VHhVWCQAQNSIAIR02HgAIDAARFQcASBUeNT0LAIZWFR41HTUedQkAAOwAKR6VCQArFR0JAB91
BgAEJ1U_BgAHGAAVFc8AIxC_4QAPPQIfUJV2HxY1PgIBCQBkHhA_tT11BgBEtR2WNQYARPUAXVUG
AFWVPXYdNQcAAOIBNxU9dQkAAP0eSDU2PVUKAAQoHxEV8RwPDgABTRUWHZUMAAIDACsddQ0AEDUJ
ADk1FpUKAAHlHzV1HjAJADL1CD4EADAGHnAEAAI-Ag9iAx1zHxWVnxZ1PwYAUHVfFjYeCAByXjYe
dT11vgQAQZU2PpUFAHodEB31CB0wBQAA4ysg9QDZGAIHAEJV-QBVBQAg9QwDAFKVHhYetQYA0V31
CH31CD0QXfUAXTAFAGUdNf0ANR0HAC71CAUAADoAFXUIAA-CDx5QFT8WMHhYDQMIAJA1PxYYfxhS
HlAJAOp_Uh5QHxUQFR8WPvIAMAoAMz8WH74WEx0QABcdDwBAHhU-FmkNDQ0AEBgNABrVCgAhEBjZ
Kxy1DABjMJ11PTAbBgAj-QYFADNQ3VEFAEJwfbEQBQBTkB0xcDEHACPQUQQAkjGQPxTQMZA6sEsP
IBE6BAAPfQwdcPAEWBAY8AYFABQKggxgAD54HvACBQDyCwA_2NA_2LD_AFiQ-gBYcF4fEjUyPhge
cF4dCABDXZUSXgUAIrVSBAAQP3IDJ1UdCQARFQoAFzUKAHFQEX0VPxZ1CACzPHUdUFFdNTwVHXAH
AFCRXRU8kAUAkVCREFEwNT8VEAgAgDsfFHFQMbAaBQABkQov0DrEEh1B8HofGagHAbkOQwYeUBoF
AFEZ8AQecAUAQRrwBBkFAFLwCB4wGgUAMQIeMA8AkRnwCBkwGnAe0AYAY3AeMBrQGQYAUxlwHpAa
BgBhGnAZUB6wBgBR8AYaUBkFAP8AUJ8V0BpQndAa8AC98AS9ugAdEDh5GQEFAJIfGBgQOP4AUB4H
AGE_GF6yPjAGAAJ-LZEwGB51HxEfHDUFAAwOABIQsRgDCADyD3AVnxa1HFAVnLUcULUcHxWVHDC1
HBuVHDCVG7UQFQYA0lBVO5WwVTuV0BU7lREFAME78QCwO-EAkDsxkDEFAEJwOzGwBQAwUDsQFA0Q
MAcAITqQPB4fBOsAHKJw_ADwAPgAcBgf4gAsGB7pAEBQHvIIBAAXcNsACAwAIVAe3gAyHxYwCQBx
HBAYEPUKHAUAMDAVnNsAAgYAAPQAoFWQtRwbVZCVG5UEAGCwVTsRVdAFAPAA8AI7cfAEO3HwAjsQ
UfAEBQDQAjswcfAAOzBx0DswkQQAMLA7UIctf5A7UDowOnDoACODkBgQOP8YAHDtAEGesj4wBQBf
PvIIMD7kAAgRGNsAAwcAITA4ygEvEDjLAQEylTAVBgAIywEh8AAFACA7sQQAUdA7UTAxBQCgsDsf
FDFQMbA7GgwMQzsQGpAGAADKAR8M5AAeAMAQAaYnlAofEjUeUD7QHQYAYjBeED8RcAkAtTxwHVUe
EB58GBJQCQC1HxUdVR4cczIcMBsJAIE9VXMfExMaEwoAEBoJAHY7XXMaEBoQCQCTEDw7sxoQExww
CABhEBzzAjpwBQBRMzpzWpAFAFITGjC6sAUAoPAOE-AOMzAT8AYFAH8IU-AKU-CI5QAc8ATwdjUf
FvAKNR7wCB8SVR5fETA99i-2AR5dMD1QPxU-EhUeM30YEjALAIMQnxUfEtMyHQcAkBAd8wI-ExMc
EwkAozwTHFNckxwwHBAHAIMz-AQwEx0QEwcAQxxwfLAFACjwDAQAUDNQE-AEBQBfBnPwCHPjGR7w
CfA_XxHwCl7wBt7wAt7wAD6zPrA_sz6QPnEyZhNzHhgScAsAQFAeE1UMAGETPRMyHjANABEdDADr
EB4zHxJVHxY9ER0THRMOAEAzXxI1DQA8EB0QDQAAGwF4NRAxEBMeMAwApxM9EB8VXxIwEZAKACAd
UEwbsB8V8AATHVAcHxIcCQAjcDwGABIC0gEQEwgBJBNQ0gEfRA0BHfEI-HfwCHfwBhd-FhfwBBd_
F-ACF74X8AAFACL_AAQAcB8Svh3wAB0FAJIfFR1_HRzwABwHADM8fTwFACH8AAQAXwK88AS8HRYe
YjY3lpcWFQYAghZRFVEVsR8WCAB1HhcxVRH1AAcAqREVFxYRlRcWERUMAIwWNRYVEZUWFQsANlGV
UQcAKfUMBAAbFwQABBgAGBZYAAhwAAZZAAgLACERFV4ABAgAUxYxdVGVBgBvFf4OFf4OBB0eQfcG
FnAEADICNhUFADF3llUEAGM3FjdWFdAGAGQ2NxYV8AAHAFNWNxYV0AYAU3Y3FhWwBgAgNhUhABWQ
CAAxFhUQCgAWcAoAAGIeANYOCQkAR3AVNhcJAEEWNZB1BQAv8HTQABzhFzZXHxZWHhZeFRc2Vx4J
ALAW9Q4W9Q4XVRH1BgUAcQhRFpUeEZUGAHJ1fnURHjVxBgB0HrURHnU_EQcAACFnJR61CABlFlUe
MR7VBwA0dT4RBgBEF7VxdQUAUxEWPnEVBwBkFpURHnVeBwBRHpUR9QIFAHMWdREe9QARBwBTF3UR
9QIGAFNVcZUxFQYAD-gAHHNwNXAVEfAABgA2NxY1BwByFRc2FTHwAgcAUwQWFVEVBgByAhcWUVXw
AAYAohYfFnAeFfAAFh4HADcVcBYHABkeBwA4FXAeBwAjMXUGAFMCFRZRNQYAgwBVFh4RFfACBwBR
lRE18AAFABE1NgACBgBOHhVwNQYADw0HHcAw9whw9whQN-YENzAFAPAEEDf2CHf2CFcW-xYIFjcW
-ggWN88aAgUATx7wCB4FAEIvF-C4AB3C8Pj3APAA9wDQNxwXAgAVsAoAE5AKADZcF3AKADIX-AYE
ALMcPxAXXD48cBccPggAWjE3HB4xCQBpFzweMRccCgBIMDc8MAkANTzwAAYAYVwecBc8kAYAQLBe
cF4EAC-wNooBHWEzMBNQc3AGAHFQczATELMwBgCgEJMfE3kQcxCTHgYAYDNQeTMwkwUAc1NwWVQz
MDMGAFE5dDPwAAUAZhkfGZ8UEwgARFldGRUGALK5VdC5VbBZFBlUNQYAQJBZFBkIABRwCAAzOfQA
BQBwPxmdVDVwPAUAIrl0BABSWRQZdFUGAI_QmTRVsJk0VQERHfEAsFNwM9BTcDNQMxCzEHMwBgDx
AxBTHxPzBB4QUx7zBB6THrNeEAUAYR5zXnMeUAYAk3AeMz4zHjNeUAgAgnA_FXNeMx5QBwCmEB4z
HhVzFR5zPggARxQVMzUJAMYeED4UOTUUNR4zHjAKAKUeEB8ZfxQ0NT5QCgCVcB8ZXxRZVBUeCQBy
UDmUFX01MAYAcBlUGR8Z3RUIAP8DHN0VUNSVcNSVkBT1ArAU9QJQzDYeEQOMDDIKGjkEAPMDGT8Z
OvAGGT460DowGRoYORqwCACTcBoQORoQehmQCACEcBo5HjkQepAHAJUZHhgZUDoQE3AKAJGwGToZ
MB8TEDMJAMUdEDOQGRo9UB0QEx0JAI7wABNQMx3wAgYAYB1QEx3wBAYAD8wOHmAEGhka8AoFAHwI
OhkaGfAGBgCFcF4YUBoZGjkIAFc_GD4wOQgAdx4YfhATWRMIAFM_ODBTkAcAIBgS9gkkE7AIAIcT
EhgSEzATEAoAUNBTUD8TBgCBPRNwE1AdkB0WAAQJAAAFAD8wE1ALAAQnEDMLAEIwHRMQCwAtEx0M
AD4QEx0NALVQHRAdED1QExAdcAoADzwVHTA5_gwDAFE6N3pZWgYAkvoCFzoZWhn6AAcAFAYFADWa
OXoGALt6GTgZGhc6WToXOgoAM7oXWggA8AF6OVoX_gQ5WhfaGZoX_gA5BQB0GRh6F5oXWgcA0voI
F-oOF5o5Wjm6FzoGACAZGEgAI-oACAAwCBk4gAARAAcAYHo3Wjn6AgUAEBQ4AB966gAccPo4GfoC
GZoFAHF6GRoZejnaBgCUuhlaGToZGjmaCAB0ORo5OjkYGQgAgrpZejnaWXo5rQAh_hAGAAIDAHEC
N-oCFxlaBgAi_goTAAFQAZMCOToZGBl6GXoIADC6FxpAAEEaOfoGJgAfSLsAHFI6ORQ6GQMABgsA
OXkUWQIAKRlUAgBJ9DYZVAIAWLQfElQeAgA-GRQ_AwADH14LAAQJAgAcFAIALz4RAwACKh5RAgAv
8PD9ABxP-xL-cQEBIz-_-3FsABzCWfoEufoEeRr5CBo5BQBQNP8UADQIAPUF-gA0GhlU-gS0-gRU
GRo5-gA5GjkHADYesB4IAGBZNPAANHkFACA5VJIjELQFAAA0ABLwLQAOBwAPMgA1D1oBHbMVMF8S
3xVfEj8VfwgAtJ8SHxU-Ej8V-xIGCQDxABSV-gbV3lVfFlXeVV31BNAW8QD_ANX_AtUeHxUenH41
XhwGAPELXH5cfpx_XH5c-gD8AP4A3D41XVX_ADVdVd4XJv8Nnj01vpVdNb6VHTU_3D6VPtw_VT78
CH78CD78MLgAHvMARL8S-xUE3xKfFZ8SXxVfCAARfwwA8Aw1-gBfFV41-gg1PTU-FjW_NT01PFU8
VT41vhUGAIH_En3_CH1eXS8oIzWeCABhXjWeXX49BQBAflXeNQQApD41XBUePRUcFX4JAIJePDW_
PR41HgcAYD5dHl013gUA3-4SXf4KXR5dXv0KXv1oDx2g9w4W9w4WF-YMHwUAFR4EAH82NR6WNR4W
CQALNl6WXgcAL-YMBAATDkgAD1oAFE8W-g4Wtg4eoz8WFl5WHhY_Nl4IAHQeFR62XjZeBgBRNh62
XlUGABA1ThsQdpABFD4JAKMeNj41PlYeNR5WCACkNh42HjU2HjY_VgkAczYelh42flYGADAWHrYt
AAIHAJNeFh42HhZeVn4IAFGeNh7WFQUAcb4WHnYeNt4GAJNeFn42HhYeNZYHAHI_NTZeFT52BwAw
ljV2vDo0Nh5WCQBANh4VlsMAAwcAg14WHlYVVh5WCAAPhgsdcDY-FvUAPnYgKhJWGikSNgcAAE05
UvYAPhU_BwBxHhUe9ggeNQUAJvYMAwAGFgAGBQBCXvYAXgUA0P4MNf4MFR8VFf4IFT0FABBdXAAQ
fQUAID0efRoQPgUAYR4WHv0IPgUA-wI2-gh2-gj2AF4WPvYEXhY_ds8AHJEQNxy3HBdfEDAIAGBe
EDf8CD4EAJUXXF48F1weHB4JAAIIACQ8EQgAiRccXjxXHB4XCgBAPB48Vx8ABQkAAQgARVccFxEJ
AFAXXBccFwoAGRwLAELcV1w_BQAwHBd8EwAVXgkAEjcHABQRCAAyFzwetg07HF4cDQAwHB4crQA5
XhweDAAACwAwHB4cDQAbPg0AYz4c3hw_MQcAYBA8PvEEMAUAD7MbHfQVsHjwCHjwBFg6WPAAWDpY
sFg6PxY6WHBYOj46WHAYOj43PjoYCAC2UDgaHjc6Nx4aODAKALgYGh4XOjg6Fx4aGAwAxRA4Gh4X
GngaFx4aeAoAEFgKAEAfGHgdDQABIQASHQwAxRgdGR4XGb0ZFx4ZPQoAEF0KABB9CgAVfQoAID0Q
KgCIOT05Fx4ZHTAMAJY9GR43OTceGT0KAJRQHTk_Nz45HXAIAFJdOT45XQYAYLBdOV3wAAUAbwR9
8Ah9sPxCHzAVHxK2HCKfFggAAJocChIA0x4QHhU0FRRfFhQVNBUNABZdDAA_NB00DAA0dZR1BgAx
ftV_BAB1PhoZ3hoZPggA9QIR-xIKERAR-AoREB4c9QYcHgcARRU0FZRTAAYKAF4UHRQdFA4AD4UA
Bw80ACBf-g4Q-g5EAX9XHnUUVRQIAEK_GTq_BQCyEZ8SGRoZnBEQEZwIAHYeHHVcdRweCAAAawAX
VXcAL1UUHgEmD1IBVeEfFpfwBB6X8AQVfjfwAgUAgh8SdR438AAdBgBClR430AUAQrUeN7AFAELV
HjeQBQBU9QAeN3AGACQCPQUAMgA9kAUAMdU9sAQAMbU90AQAQZU98AAFAGDd8ALd8AJqHS-whLMA
HPAAsB8XVPAIHlTwBh55FPAEBQBhAh65FPAABQAxFLkfBgCSHfAAGRR5FB8VCAB2HPAAFBl0HQcA
oVkfFhQdPPAAWRsHAIgUGRsUGxQdHAoAMhkbGR0ABQkADyYAE1Y0OzQdHAcARRk0HTwHAEMdVF0c
BgD-AAKdHPAEnRzwBj088Ag9PFAEHnHGFPAOFPAMKx9yABQZcBkfFAgAxB7wBBQZMBQeMBkUsAkA
tjA5ND4UHhQeFBlwCgDzADQ_PxUeHR4dFD4UMDQ_PQsAshAUMDQePTReHxZUCQAwHDRQMgB2PhQe
HBQZcAsA1jA5PDQeFBkeHBk0GRAMAJM5dBkcNBmUHhkIABAQbgAwGTQeAgAXMAwAYBAZHhA_NB8A
OxAeFA4AgrAeFDAeUB7QBwAfMBsBHMKQl-AGl-AGVxZX8AIFAFMQFlfwAAYAJPAKAwAgBLcDACAC
1wMAEgBEFVLwABa3FgUAMAIWd4k2v3cW8AZ28Ah28P9FhwAcEXBZAAMDAD8XkBcFABAisHcEAEGQ
lzB3BABBdxYQlwUAUbBWMHcWBQCf8AhW8ApW8P89FgEd8A3zBpDzBlDzClDzCjCTHxM-Eh8TMz4T
MJMePxIeCQCWcx4THl0THhMeCgBAEHMeHQoAOB0eHQsAp1MeE10UFT0UHR4LAEBTHhMeowQRFKsE
Cg4AIXMeCgA2FXQVCgCEUx4TFRQV9AAIAGJzHRQV9AIGADAzHh0jADhUFRQKABA9JwAjHxYJACAc
UwgAeBQcFBw0HBQMALkzHhMePVQcNBUUHAsAMT10XB4AAggAEBMyAEU0XBR8CQAPUAEc8QLzyh8T
8w4eUx6TPlMeHxIeMwkAMR0eEwQASzM_Mz4MABAVYgMiEx0kAAkNAAIlAXkeHVMePR4dDQABLAFT
FD0eMz1NAQQNABJ0CwARExYAGFQNADD0Ah3SACH0BAcAcTQVtB0ePZQGAID0ABUUHxY0PSgBQpQV
FBwKADA0HFQQABQ8CAAnFBwCADWcFBwCAB-8eEkdAXECEZBxAlBQEz8TM2kC9wSTMBM_Mx49HpMw
HhMeE10eEx5zCgAAekx3E10eHR5zEAsAqB4dFD0VFF0THlMLAAEQBwEtAUoeEx5TDgARFR8BRhUU
HnMKAAD_AEUVEx5TCABSAhUUHXMGAABDAWZ0FRQdHjMKACAfFioAQz0eMxwIAAFdAhEcagEYUwwA
cBwUFTQcVD3pAQcLAGYUHDRcdD0IAEB8FFw0LwAVEwkAD2wSHnE4FT41XhXeBgAQXtkpCAQAAucA
EDW2CAUKABJVGwIQNNIABAoAEjUIAANVAwEKAHG0FZQVlBVUBgDR9AYV9A4VlBV0FTQV1AYAcPQC
FfQAFbQFABXUJwAAgIRgNDUUFXQ1bQAECgAhNJV5AAAUAAQKAHFVPhUetT51BgByNd4VHhWeFQYA
L-4wAAEeAPgAYP4ENV4Vfv8AQzUedT4IABC_6wAgVZ4GADJ1XjXnAAMIABO17QASlQgAk5RVdBU0
PhQVNAgAAQMBVD4UFT6UCQAB-wEhPtQGAAAdAkGVNBW0BgBA1BV_Nf0AAAYAUDQVFDWe4QAlFRQK
AFI0NX4VPhQABAoAcVVeFX41PnUGABE1Vx8P9wAfkfD-NTPwDDPwCjciEAhIA4DwBhM_M-AEE9wh
NFBTcAgAch5QHhMwk1AHABBwzhc0Mz4TCABA8AATEOcZJBPQCAAyMz5wBQAj8ACVIQEDAAEmLx8C
pQAe8AD-_ndQV7B3UFdwFrcQl1AFAP8BMFb3BhYQVvcG9gJ39gh3dkEZHlMfERN-EwcAUdAeUx5z
BQBzsBMeEz5TPgcA8gCQHhMfER4RE14dE5AeEx0KAJdwEx4zER4TXTMJADAdPhFvBRSQCQCYcB4z
HREeUz4TCQBVHhF_HTMIAIMdHhMRHl1TkAgAg3AzHR4Rkx6QBwBiUxEeM16wBgAAZQAzPjPQBwBi
ExEek-AABgBQER5T8AYFACACXr8jEQpfAQ_mCx3AcHnwCHnwBlkUOfAEBQBgBjkUWfAEBQAxBjkf
EABQHjnwBhnVCTMwOdAIAMZQGVA5HhkUEDkUGTALAHoQeRAZFB5UCgBBORQ5FDYAORQeOQ0ApTA5
FB5UHjQeOVAJAIVZFD4UXhkUGQkAcXAZdD5UGZAGAHGwGXQeNBnQBgBw8AIZNB7wCAUAPwweFAQA
AQ8MKx2TMBcaGZAaFxqQCACUcBk6GZAZOhlQCACWORQwFBkUMBQ5CgBgkBSaORTQBQD0BLAXGt8W
OZAXGt45kBo_NhFWHhkIALdwGj4WNxE3Nh4ZUAoAjB4WVxFXFh4UCgA2dx4ZCQCZGR4RN3EXER4U
CgBbFjcWEXYKAC-3AgcABJNwFB5XEVceGZAIAHJwORTeGTRQBgBjGTAZtDAUBwAPPAQdYZA_UD7w
AgUAQl4ZPhgGAIKwXhgeWjg_cAcAIFAYiVJ4GRoZGF4YMAwAUpg_GD54BgDAUDEYPhgfExg_GBFw
CwAQHQoA6VARHRcROB0THTgXER0wDQBmPVEdUz0xCADBHRMxHVMfHBNcEx0QDAADCwAh8wwEAJcT
HRMdkxFTERMKAHcdEx2zHFMcCQAAHAAj8wYHABEwBwAUBAcAM10THQIAGD0MAI9QEf0EkBH9BHMF
Hhc4OAEyED4YBgCT0D4YPhkeOD6QCACUcDg_GFoYXhhQCAB1eB4ZGhkeeAgAY1FeGF4YMQcAUDAR
HxMROAEABABHPRARHQ0AqD0RWBETETgxEx0LAIMdM1FTMVMfHAkAExz7ABMcBwAAGQFDEVMRMwgA
EFM7ATQcUxwIACIzHSgAAwcAFRAXARZTIgFQU1AR-QgEAA8DFB0gcBiPLgEFAPMMPxgwGPAGPjAY
8AR3HvAGdx7wBBcRFleQFhdQCADGMBoXMVcwNxAWFxYQCwCjWRZXFhB3Fh8WFwoAlB0XEDj3BBYd
FgcAYxg_FvcAVgcAdDAeHTbXNh0HAIQdFh02lzYdUAgAcj0WHTZXVnAHAGKQPRYdth0GABKw-zMj
PdAIAAN0ECAEGlYuCQUAH5AEAT4DBgAQAvUABAgBQZAWFxDxABVXBQEBCgAB9QAjHxYEARAX9gBV
FxbXHRYJAGMwHh1W1zYGAFM9dpc2HQYAch0WHfYCHVAHAHFwHRYd1h2QBgAgcBrqUlUWHVYdkAoA
UbAaGd0ZBQAi8A4DAADgVh9Q_wBKAwYAEADtAAT-AAAPATM49wL6AAIIAAHpAQEEAQIKACAdF_4B
RfcAHRYIAADvASTXNgcAQj12d3YFAAD9ABEEAwEYBAIBEbD2AEQWOR3QCQBw8AB9Gj3wAgUAAh0-
Dw84HYHwfjbwDDbwDIMPIApW60agVlA20D8SkFawPgQA8QEfFVB2sD4dUHaQPj0QPTbQBgCEsBkU
ORQdPj0IAISQGRQeNB1_HQgAQHAZFF5XERU9CQCXUBk0fhQ_HR4dCQB2FB4Unh0ePQkAUlQeFB4d
AgAJDAAWNAwAF3AMAGCQPj1xPbAFAA9iJh5hODhwOPAABQCQGD8YMD4Y8AAY7S_w8AR_8Ah_8AQ_
eD6WMoA_0B4YPw44HjE9JBg9CAA1GF4YCABRkB543nAEAFUYMn4yPgcAZRIxfjESHggAdT4YEX4R
GD4IAFNeGH4YXgYAAAc6JB4SBwAxUh4SAgAWMgoAEJAKACFysAYAQNAfFbL5Ky_yHPQAHlC0ONA4
kAQA8AkYXxhQXhiQGF5QXhjwAJ7wBp7wBB4-DlgiO8M9WB7QPhg9GD4YPpAIAOFwHpjeUB6Y3jAe
OP4IEAUAU14yvjI_BgB1PhIxvjESHggAdBI_OL44HhIIABQwxwAlUlAKAKCQ8gLQ8gLwAD8VZCdP
PHA8cDRgHkEwOPAEBQAgHxgmYDHwBB4HAGAGPhAe8AgFADAKHjh_KCk4HtwAMPAAHscBBQcAEXh9
YRPQBwBBOD4YfgUAdLASHjG_EpAGAFMYEd4ScAcANTIeGAYAUxIeEt4yBgAUMt0ABgoAEpAKACNS
sAgA-wLQ8gDwAPIA8AQyEDLwBjIQMoMlHhWEzEJx8AwYHrA4MMU-AQYAQR4YPpgFAEDwAh5Y2AEA
BgBB0B5YngQAYTje0DjesLM3cnASHjH_AlAGAHMyGBH_AhIwBwBIEh4SGAgAArgAAbwACAwAH1Ds
AAFf8gSw8gQnJx5xOH8XHxbwBgYA6QIfF18WHxcfFj8XHxbQDQBgnh8XHj3QJAQgsN77AxKQBgCD
PjReHR4dPnAIAEBQPhQ_WwQpPR4KADdeFF4IAIkeFB0_HRReVAkAQF4UPhR8GUMfEhQwDwBAHB8V
HA0AAQwAGlsKABm_CAAQPjEANxxbHAoAAIAAdR0UHDscFHAKAHFQFF5UfBRwBgCfkFScFNBUnBSw
MAFesB8QET0cEVA_NF4cCQARMCkBODE9MQkAdV4UPhU9FVAJAAIqAQ8LAABHXhQ_dQgAcl4UPj8S
NTsrARE7CQBCvjs-FQgAITo7HwE0O3obCAABJQElG5oIAFMwND5bugYAj1Bb_gJwW-oCUQJeIX5d
BQAAtwE2FH49BwCxXhQ_HxARHRAcERANABIcDAADEAFMMR0QMQwAiV4UXhUdEBUwCwBGXhR_dQcA
0L5fEjU7EB4Uvls1OxAWAUL7AB8VCAAhGhAWAREaAgAZOg0AUTQ_W-oCBQCPEFv6BjBb_gbvCh4g
MnhrQPAMeDLQUnhSsFJ4UpBSEX8YEVJwUhF_EVJwcX5xBADgUBQ-FDd-Fzc-FBQwFD0KABA9CQDC
Ex8THxY-Dx8WEx8TEQATHBAAwBw9FBAUPRMXERw-DwYAIT00DQASOwwA0x0fFxsxezEbGh00HRoK
AHAUMDr7ADpwBQCUkDq7OrA6uzrQIEQzEbIRBQACNwUR0GIEcfAAPTA98AQFADE0MDQFAA9HBR4f
OAABmQ-4AAgP9wG4FrD3AJMx0BGyMbDyADQEABA9BADf0LLwBLLwBjTwDDTwBPgASiUVH-kAKhUd
_gAeNRAAAvoAIB8T_wA5NT00DQDwAR0fFx8PMXwRNR8XHTQdGxwLAJAbHRQwO9w1G3AFAJCQO3w1
Fh8WNXAIAOMaNZDROtDROtARkhEVEQYAFLIFADCw8gAUAR8xCAKtJBURCAIiFREIAjEVEXAGAGCQ
OrsaPxYGAII5sLE1GRY1cAYAURGSMTWwBQAh0hEEADOQ8gAFAFTQPTA9EAYAcTQwNBAV8AAHAA83
Bh4feBMBFFAfFFF_UQYCEx0IAEE9-xcABwEh-AD-AMAxPD8PPDE9ND0xPDsIAJYdHDsxOzE7HB0K
AEAUMDz79Qq-_wA8kDy7PLA8uzz1Aw4fkMAWHh_55QEWWP8XAD8UywAyN38P7AExN3w31QDTNx8T
Fzw3Gxc9ND03GwoAoR0fFxwbEXwbERzaAwUMAEAUMDr83ANP-AA6MJgCJ-IIfxhSsFJ_UpASHxQX
EX8XFxEfFBJwEh0MAGAdEnARHTFnA1AfEzEdEQ0A8QMcPw8cMR0RUBQdFxMcFzsXPBelAQkNAFgb
N3s3GwoAcRAUPfsEPTQFAJAdPxf7ADodNB2VBP0BHRQwWrtacFq7WpD6BLD6BJ8BD5QGP-EBcLI4
8ACyONAyMRIRMj8YsAgAcT6QMrEyPnAFADHxBDIEAGP-FAI3HxcHAFBQdJ8UF5IDFw8KAIpUXxQ-
FxcTMQsAUBR-FD8XMgEqET8NAGRwXxR-F58HAHKw-xcAHw-QBgAE9wAiUZIEACAxsgQA-gPQMfIA
sDHyANAfFBRwHRTwAB0HAA_dDh4fOAABUjcfDxcBAQQOAAsCAVHfFz8P0AUACgABb9BR0rBR0vYA
OQb1ARFy8wCBcj6QMnFyPnAFAA-xAVcB-G4E7ADwAnGS0HGS0FGyFLBRshSQcZI-BQBnPLAcFPAM
BAAfBOABHg-rAIBCETQRcgYAt9AxPxSysDE8svAK5QAvDBzSATJBkVI_cAUAQvEEEhUFAPQA-xQC
FzVw-QIXNVB0nRcTBgAgVF3SABARCQARPAgAMRR9PMoABwoAUHBdPJ8PlToDCABhsLw1OzVwBQBA
8QA1sAQAM1FyEQUAC7EDCKwCD7oCKx9Q6AAHD88BNjIVET0LAEE9FRE9wwGAHRU9HHBfFHwIAPEE
sHw1HxYWdXB8NRsWdXBxNTuVUAUAMFESMes7AwcANTFSEQcAgdAxklGwMZJRwgNeGhTwABoHAA9o
Bx4feLgEFzIAfxcGAIBQdH8UHxcxPQgAsB0xPVAUfD1-DxEdCABwexEdcFx9mwQAb7DdO9DdO4QE
A38cFHAcFPAABwAAH3AMCjBBHxg4HikINx44HisIYjRRflE0MAYAsRRfFBF_EV0UMBRdCAByEBT9
DDT9DPMKQxS9FBzzCgALAAHzCnMcFH0UHDtwCACPkDu8O7A7vDtZB1Av8DjiACoiNBDiAB9U4AAi
D80NGQ_5AZoC1gBA8QDQEtUAAAUAYbAUHfICkAUAQTQd8gAFACHwArYNEAq2DQ_ZAgpQbT02fX0=
:: label.qoi
b64$cW9pZgAAAeAAAAEOBAH9-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39-f39
-f39-f39-f39-f39-f39-f39-f39_f7-8ejF-qKIecA-zBI-zRI-zRI-yhI-8BL_wsPHwRI-yRI-
-RI-2hI-0BI-2hI-4TvBEj-JEj-KEj-NEj-BO8ESP8kSP847wRI-yRI7wRI-yRI-3RLAP8wSP80S
wD-MOz-H-rkAPsE-wRLA-n4lUz-HEsE--qKIeT-_uQA_wC0-xjsSwT-BEsAtP8cSwT-BEsAtP8cS
wT-BEsAtP8P_ooh5P8H_uQA_wT-BEsAtP8H_ooh5P8P_uQA_wT-BEsAtP8cSwT-BEsAtP8cSwT-B
EsAtP8cSwT-_ooh5P-65AD7ALT-WOz-Q-qKIeT-aOz-kOz-JEj-KOz-NOz-EOz-JEj-ROz-JEj-B
Oz-JEj-dOxI-zDs-zTvAP8w7P8b_uQA_-v8ATcESPxI-DcAtP8USDcESOxI-DcAtP8USDcESPxI-
DcAtP8USDcESPxI-DcAtP8USDcESPxI-DcAtP8I7P8ASDcESPxI-DcAtP8A7P8ISDcESPxI-DcAt
P8USDcESPxI-wS0-xRI-wRI-Ej-BLT-FEj-BEjsSP8EtP9U7P9A7P8T_X1dP-f39zTvAP8w7P807
wD-MO8E-wxINP8ASwQ3BEsAtP8MSDT-AEsENwRLALT-DEg0-wBLBDcESwC0-wxINP8ASwQ3BEsAt
P8MSDT-AEsENwRLALT-BOz8SDT-AEsENwRLALT87P8ESDT-AEsENwRLALT-DEg0-wBLBP8MtP8MS
P8MSP8MtP8MSP8MSP8MtP9Q7P9A7P8Qu-h0rU8E-KM0-KP390j-AKMU-wijAP8AoxT8owD8oP8Eo
wS7_ooh5Oz-MOz-NO8A-zDs-xf65AD4NP8ASwg0SwC3AP8MSDT-AEsINEsAtwD-DEg0-wBLCDRLA
LcA-wxINP8ASwg0SwC3AP8MSDT-AEsINEsAtwD-BOz8SDT-AEsINEsAtwD87P8ESDT-AEsINEsAt
wD-DEg0-wBLBP8MtP8MSP8ktP8MSP8M7P8MtP9Q7P9A7P8QuKME-KMw-wCj9-dE-KMA-KME-KMA-
KMI-KMA-KMQ-KMA-KD8owD8owC47wD-MOz-N-qKIeTs-zBI-xf65AD4NwRLGLT-DEg3BEsYtP8MS
DcESxi0-wxINwRLGLT-DEg3BEsYtP8H_ooh5P-65AD4NwRLGLT-_ooh5P8H_uQA_DcESxi0-wxIN
wRLBP8MtP8MSP8ktP8MSP8P_ooh5P8MtP9Q7P9ASP8QuKME-KMI-KMA-KMU-KP390T8oP8AowT8o
wD8owj8oP8AoxD8owD8oPyjAPyjALjvAP8wSP80SwD-MEj-FLf65AD4NwBLDLRItwD-DLRINwBLD
LRItwD-DLRINwBLDLRItwD-DLRINwBLDLRItwD-DLRINwBLDLRItwD-B-qKIeT8t-rkAPg3AEsMt
Ei3AP-6iiHk-wS3_uQA_DcASwy0SLcA-wy0SDcASwT-DLT-DLT-JLT-DLT-D-qKIeT-DLT-UEj-Q
Ej-ELijBPyjCPyjAPyjFPyj9-dE-wCg-KMA-KME-wSjAP8AoPyjFP8AowD-BKMEuEsA-zBI-xjvF
EsI7EjvHEi47xi3_uQA_DcASLRItEi3AO8UtEg3AEi0SLRItwDvFLRINwBItEi0SLcA7xS0SDcAS
LRItEi3AO8UtEg3AEi0SLRItwDvC-qKIeT-ALf65AD4NwBItEi0SLcA7wP6iiHk7wi3_uQA_DcAS
LRItEi3AO8UtEg3AEi07wi07xS07xy07xS07wv6iiHk7wi071RI70BI7xC4owT8owj8owD8oxT8o
-f3RPyjAPyjAPyjEPyg-KMA-KMQ-KMA-KD8owy4SwjsSO8cSLjvNEsA-zC47xy3_uQA_DRLALRIt
wDvHLRINEsAtEi3AO8b_ooh5Lf65AD4NEsAtEi3AO8ctEg0SwC0SLcA7xy0SDRLALRItwDvD-qKI
eTvBLf65AD4NEsAtEi3AO8H_ooh5O8Mt-rkAPg0SwC0SLcA7xy0SDRLAO8EtO8ctO8UtO8ctO8H_
ooh5O8EtO9YSO9ASO8QuKME-KMI-KD8oxj8o-f3RPyjAPyg-KMU-KD8owD8oxD8owD8oPyjDLhLA
P8wuO80SwD-MEjvILf65AD7ALRItwDvJLRLALRItwDvHLjstEsAtEi3AO8ktEsAtEi3AO8ktEsAt
Ei3AO8T_ooh5O8EuLf65AD7ALRItwDvCLjvELRLALRItwDvJLRLALTvALTvJLTvDLTvJLTvA-qKI
eTvALTvXLjvQEjvELijBP8IoP8Aowj8owT-BKP390T-AKMA-KMI-wSjBP8AoxT8owD8oPyjDLsAS
P8wSO8YSwDsSLhLALsA-zC4SO8MSLsASwC3A-rkAPi3ALsD_ooh5wDvBEsE7Ei4twP65AD4twP6i
iHk7wBLALhLCLhLALcD_uQA_LcA7wP6iiHnBO8QSLi3A-rkAPi3A-qKIecE7xBIuwBItwP65AD4t
wP6iiHnAOxIuEsAuwBLALhItwP65AD4twDvC-qKIeS7AEsIuwC3A-rkAPi3AO8D_ooh5LsASwDvB
EsEtwP65AD47LTv_ooh5LhLAO8ESwTvALTvBLS7AEsA7wRLBOxIuLRIuwC0SO8ESwTvEEi4SwDvA
EsAuEsIuEsAuwRLAO8ESwTsSLhLALsASwDvBLij9-f3LLsE-zC7BEsA7wRI7xS4SP8wuO8UuO8It
wS47zC3BO8QSO8UuLcE7whI7yC3BO8ASO8otwTvGLjvELcE7xC4SO8ESOxLALcE7yhI7wC3BO8gS
O8ItOy07zS0uLTvEEjvNEjvFLjvNLjvELv39-c4SP8wuO80SwD-MLjvFEjvDLTsSO80tO80SOy07
wxI7yS07wRI7yy07xxI7xS07xRI7wRI7EsItO8sSO8EtO8kSO8MtO88tO8USO9USO80SO8USO9US
O8USO80SO80SO8USO80SO80SO8USO8USO8USO80SO8USO8USO8USO8ESOxLCO8wSO8USwD-MLjvG
EjvEEsA-zC47xRI7xRI7xhI7xBI7xRI7xRI7xS47zS47zhI7xBI7xS47xRLHLjvMLjvNLjvOEjvE
EjvFLjvNEjvFEjvGEjvEEjvFLjvNEjvFEjvFLjvNLjvNLjvFEjvFEjvFEjvFEjvFEjvFLjvFEjvF
LjvNLjvFEjvFLjvFEscuO8wSO8USwD-MLjvG-gAAAMc-zDX9-f39-f38P8w10D-COz-HNRLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEsL_RS0yEgMSAxIDEgMSAygD
EgMSAxIDEgMSAxIDEgMoAxIDEgMSAxIDEgMSAxIDKAMSAxIDEgMSAxIDEgMSwCg1P8w10D-AOz-J
NRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLBAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIDEgMSAxIDEgMSKDU-zDXQPxI-yjUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SwgMSAxIDEgMSAxIDLgMS
AxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEgMuAxIDEgMSAxIDEgMSAxLALjU-zDXQEj-LNRLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLBAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSAxIDEgMSKDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEsIDEgMSAxIDEgMSAygDEgMSAxID
EgMSAxIDEgMoAxIDEgMSAxIDEgMSAxIDKAMSAxIDEgMSAxIDEgMSwCg1P8w10D-MNRLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLBAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSLjU-zDXQP8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEsIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxID
EgMuAxIDEgMSAxIDEgMSAxIDLgMSAxIDEgMSAxIDEgMSwC41P8w10BLAO8gSwDUSzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SwQMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEi41EsI7xhLANdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SwgMSAxIDEgMSAxIDLgMSAxIDEgMSAxID
EgMSAy4DEgMSAxIDEgMSAxIDEgMuAxIDEgMSAxIDEgMSAxLALjU7wBI-yTXQP8w1Es0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEsEDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIuNTvAEj-JNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SwgMSAxIDEgMSAxIDLgMSAxIDEgMSAxID
EgMSAy4DEgMSAxIDEgMSAxIDEgMuAxIDEgMSAxIDEgMSAxLALjU-wBI-yTXQP8w1Es0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEsEDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIuNT-AOz-JNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SwgMSAxIDEgMSAxIDLgMSAxIDEgMSAxID
EgMSAy4DEgMSAxIDEgMSAxIDEgMuAxIDEgMSAxIDEgMSAxLALjU-wBI-yTXQP8w1Es0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEsEDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIoNT-MNdA-zDUowC7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7K
KMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsAD
LgMuAy4DLgMuAygDKAMuAy4DLgMuAy4DLgMoAygDLgMuAy4DLgMuAy4DKAMoAy4DLgMuAy4DLgMu
KMA1P8w10D-COz-HNRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLBAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSKDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEsIDEgMS
AxIDEgMSAygDEgMSAxIDEgMSAxIDEgMoAxIDEgMSAxIDEgMSAxIDKAMSAxIDEgMSAxIDEgMSwCg1
P8w10D-AOz-JNRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLBAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSKDU-zDXQPxI-yjUSzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SwgMSAxID
EgMSAxIDLgMSAxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEgMuAxIDEgMSAxIDEgMSAxLALjU-
yxI10BI-yzUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSwQMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEig1P8o7PzXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEsIDEgMSAxID
EgMSAygDEgMSAxIDEgMSAxIDEgMoAxIDEgMSAxIDEgMSAxIDKAMSAxIDEgMSAxIDEgMSwCg1P8w1
0D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLBAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSAxIDEgMSAxIDEgMSLjU-yDs-wTXQP8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEsIDEgMSAxIDEgMS
Ay4DEgMSAxIDEgMSAxIDEgMuAxIDEgMSAxIDEgMSAxIDLgMSAxIDEgMSAxIDEgMSwC41P8cSP8E7
NdASwDvIEsA1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEsEDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIuNRLAO8MSwjsSwDXQP8w1Es0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEsID
EgMSAxIDEgMSAy4oxxIDEj-HEgMSKMcSAxIDEgMSAxIDEgMSwC41P8w10D-MNRLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLBAxIDEgMSAxIDEgMSKMkSP8D_4msCxD-BEijJEgMSAxIDEgMSAxIDEi41P8w10D-MNRLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLCAxIDEgMSAxIDEgMoyQM-AMU-wQMoyQMSAxIDEgMSAxIDEsAuNT-MNdA-zDUSzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SwQMSAxIDEgMSAxIDEijJEj8AwD-GEijJEgMSAxIDEgMSAxIDEi41P8w10D-MNRLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLCAxIDEgMSAxIDEgMoyQM-AMA-xgMoyQMSAxIDEgMSAxIDEsAuNT-MNdA-zDUS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSwQMSAxIDEgMSAxIDEijJEj-FAMA-wBIoyRIDEgMSAxIDEgMSAxIoNT-MNdA-
zDUowC7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIu
yijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsADLgMuAy4DLgMuAyjJAz-F
AMA-wAMoyQMuAy4DLgMuAy4DLijANT-MNdA-zDUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSwQMSAxIDEgMSAxIDEijJ
Ej-AAMU-wBIoyRIDEgMSAxIDEgMSAxIoNT-MNdA-yTs-wDUSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSwgMSAxIDEgMS
AxIDKMkDP8AAxD-BAyjJAxIDEgMSAxIDEgMSwCg1P8w10D-IOz-BNRLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLBAxID
EgMSAxIDEgMSKMkSP8kSKMkSAxIDEgMSAxIDEgMSKDU-zDXQP8c7P8I1Es0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEsID
EgMSAxIDEgMSAy4oxxIDEj-HEgMSKMcSAxIDEgMSAxIDEgMSwC41P8w10D-HEj-CNRLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLBAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSKDU-zDXQP8U7Ej-DNRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLCAxIDEgMSAxIDEgMoAxIDEgMSAxID
EgMSAxIDKAMSAxIDEgMSAxIDEgMSAygDEgMSAxIDEgMSAxIDEsAoNT-MNdA-xDs-xTUSzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SwQMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIDEi41P8w10D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLCAxIDEgMSAxIDEgMuAxIDEgMSAxIDEgMS
AxIDLgMSAxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEsAuNT-MNdASO8kSwDUSzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SwQMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEi41EsA7EjvGEsA10D-JEj-ANRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLCAxIDEgMSAxIDEgMuAxIDEgMS
AxIDEgMSAxIDLgMSAxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEsAuNT-MNdA-yBI-wTUSzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SwQMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSAxIDEi41P8w10D-HOz-CNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLCAxIDEgMSAxIDEgMuAxIDEgMS
AxIDEgMSAxIDLgMSAxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEsAuNT-MNdA-xjs-wzUSzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SwQMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSAxIDEi41P8w10D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLCAxIDEgMSAxIDEgMuAxIDEgMSAxID
EgMSAxIDLgMSAxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEsAuNT-MNdA-zDUSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSwQMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEig1P8w10D-DOz-GNSjALsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijC
Lsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIu
wAMuAy4DLgMuAy4DKAMoAy4DLgMuAy4DLgMuAygDKAMuAy4DLgMuAy4DLgMoAygDLgMuAy4DLgMu
Ay4owDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEsEDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIoNT-COz-HNdA-zDUSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSwgMS
AxIDEgMSAxIDKAMSAxIDEgMSAxIDEgMSAygDEgMSAxIDEgMSAxIDEgMoAxIDEgMSAxIDEgMSAxLA
KDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEsEDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIoNT-AOz-JNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SwgMSAxID
EgMSAxIDLgMSAxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEgMuAxIDEgMSAxIDEgMSAxLALjU-
Ej-KNdA-zDUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSwQMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxID
EgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEig1Ej-LNdA-zDUSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSwgMSAxIDEgMS
AxIDKAMSAxIDEgMSAxIDEgMSAygDEgMSAxIDEgMSAxIDEgMoAxIDEgMSAxIDEgMSAxLAKDU-zDXQ
P8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEsEDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIDEgMSAxIDEgMSAxIuNT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SwgMSAxIDEgMSAxIDLgMS
AxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEgMuAxIDEgMSAxIDEgMSAxLALjU-zDXQEsA7yBLA
NRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLBAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIDEgMSAxIDEgMSLjUSwDvIEsA10D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLCAxIDEgMSAxIDEgMu
AxIDEgMSAxIDEgMSAxIDLgMSAxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEsAuNT-MNdA-zDUS
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SwQMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMSAxIDEgMS
AxIDEgMSAxIDEgMSAxIDEi41P8w10D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLCAxIDEgMSAxIDEgMuAxIDEgMS
AxIDEgMSAxIDLgMSAxIDEgMSAxIDEgMSAy4DEgMSAxIDEgMSAxIDEsAuNT-MNdA-zDUSzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQP8w1
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oNT-MNdA-zDUowC7KKMIuyijCLsoowi7KKMIuyijCLsoo
wi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijC
Lsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oNT-MNdA-zDUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1P8w10D-MNRLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKDU-zDXQP8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-MNdA-zDUSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSxTXAEsQoEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oNT-MNdA-zDUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSxDX_AOQ2wDXAEsIoEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oNT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SxDUj
wjUSwS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLENSM1wRLCLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQEsA7EjvGEsA1Es0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEsQ1IzUSxC4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS41EsA7yBLANdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SwjXBIzUSxC4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8w1
0D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLBNSPCNRLELhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQP8w1Es0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEsE1I8E1EsUuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uNT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SwjXBEsYuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-MNdA-
zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLMI84SKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KDU-zDXQP8w1KMAuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7K
KMIuyiPOKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIu
yijANT-MNdA-zDUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzCPOEigSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1P8w10D-MNRLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLMI84SKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oNT-MNdA-zDUSzS4SzS4S
zS4SzS4SzS4SzS4SzS4Szf5iWlISzRsSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN-iEvVhLN
HRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-
zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0dEs0dEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oNT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzRsSzRsSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS41P8w10D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNGxLNGxLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQEsI7xhLANRLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLjUSwDvIEsA10DvAEj-JNRLNLhLNLhLNLhLNLhLNLhLNLhLNGxLNGxLN
GxLNGxLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-
zDXQO8ASP8k1Es0uEs0uEs0uEs0uEs0uEs0uEs0bEs0bEs0bEs0bEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-MNdA-wBI-yTUSzS4SzS4SzS4SzS4S
zS4SzS4SzRsSzRsSzRsSzRsSzS4SzS4SzS4Swv7-zKrAEscuEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uNT-MNdA-wDs-yTUSzS4SzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsS
zRsSzS4SzS4SzS4SwRT_-_wn-qtSNhQSxi4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS41P8w10D-AEj-JNRLNLhLNLhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLNGxLNLhLNLhLN
LhLA-v_jAMEfwBTAEsQuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-M
NdA-zDUSzSgSzSgSzSgSzSgSzSgSzSgSzR0SzR0SzR0SzR0SzSgSzSgSzSgSwSEfwxQSwygSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1P8w10D-MNSjALsoowi7KKMIuyijC
Lsoowi7KKMIuyijCLsMbxR3CG8odwhvKHcIbyh3CG8YuwijCLsoowi7KKMIuIR-DFC7CKMIuyijC
Lsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijANT-MNdA-zDUS
zSgSzSgSzSgSzSgSzSgSzSgSzR0SzR0SzR0SzR0SzSgSzSgSzSgSNcEhwB-AChLEKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0o
Es0dEs0dEs0dEs0dEs0oEs0oEs0oNcQKwDUSxCgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSg1P8w10D-MNRLNKBLNKBLNKBLNKBLNKBLNKBLNHRLNHRLNHRLNHRLNKBLNKBLN
KBI1xRLFKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQP8g7wBLA
NRLNLhLNLhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLNGxLNLhLDNcASxi4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8U7P8Q10BLAO8A-xzs1Es0oEs0oEs0oEs0o
Es0oEs0oEs0dEs0dEs0dEs0dEs0oEsI1I8A1wBLEKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQOz-KOzUSzSgSzSgSzSgSzSgSzSgSzSgSzR0SzR0SzR0S
zR0SzSgSwjUjwjUSwygSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSg1P8U7P8Q10Ds-yjs1Es0uEs0uEs0uEs0uEs0uEs0uEs0bEs0bEs0bEs0bEs0bEsI1IzXBEsQu
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-FOz-ENdA7P8o7
NRLNLhLNLhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLNGxLNGxLCNSM1EsYuEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-FEj-ENdA7P8U7xDUSzS4SzS4SzS4SzS4S
zS4SzS4SzRsSzRsSzRsSzRsSzRsSwDXBIzUSxi4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS41O8USO8Q10DvEEjvFNRLNLhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLN
GxLNGxLNGxI1I8I1EsYuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uNTvFEjvENdA7xBI7xTUSzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSzRsSzRsSzRsSNSPBNRLH
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU7xS47xDXQO8Qu
EsA7wRLANRLNLhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLNGxLNGxLNGxLANcESyC4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41LhLAOxIuEi4SO8ESwDXQEjvCEi47
xTUSzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSzRsSzRsSzRsSzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41O8MuO8Y10DvEEjvFNRLNLhLNLhLNLhLNLhLNLhLN
GxLNGxLNGxLNGxLNGxLNGxLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLjU7wxI7xjXQO8QuEjvENRLNKBLNKBLNKBLNKBLNKBLNHRLNHRLNHRLNHRLNHRLNHRLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU7wxI7xjXfKMAu
yijCLsoowi7KKMIuyijCLsoowi7IG8AdwhvKHcIbyh3CG8odwhvKHcIbyh3CG8EuxyjCLsoowi7K
KMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijANd4S
3SgSzSgSzSgSzSgSzSgSzR0SzR0SzR0SzR0SzR0SyiPOEsEoEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs41zhLdKBLNKBLNKBLNKBLNKBLNHRLNHRLNHRLNHRLN
HRLKI84SwSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzjXO
Et0oEs0oEs0oEs0oEs0oEs0dEs0dEs0dEs0dEs0dEsojzhLBKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLONc4S3S4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSzRsS
zRsSyiPOEsEuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs41
zhLdKBLNKBLNKBLNKBLNKBLNHRLNHRLNHRLNHRLNHRLNHRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLONc4S3SgSzSgSzSgSzSgSzSgSzR0SzR0SzR0SzR0S
zR0SzR0SzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzjXO
Et0uEs0uEs0uEs0uEs0uEs0bEs0bEs0bEs0bEs0bEs0bEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs41zhLdLhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLNGxLN
GxLNGxLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLONc4S
3S4SzS4SzS4SzS4SzS4SzRsSzRsSySgSwRsSzRsSzRsSzRsSzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzjXOEt0uEs0uEs0uEs0uEs0uEs0bEs0bEsgoPygS
wBsSzRsSzRsSzRsSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzjXOEt0uEs0uEs0uEs0uEs0uEs0bEs0bEsgoP8AoEhsSyCjBEsAbEs0bEs0bEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs41zhLdLhLNLhLNLhLNLhLN
LhLNGxLNGxLIKD-BKBsSxyjADSjAEhsSzRsSzRsSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzjXOEt0uEs0uEs0uEs0uEs0uEs0bEs0bEsgoP8IoEsYowD-_
uQA_PyjAG-6iiHnNGxLNGxLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLONc4S3S4SzS4SzS4SzS4SzS4SzRsSzRsSyCg-wCjAGxLGKD-ADT-AKBsSzRsSzRsS
wBTAEskuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs41zhLd
KBLNKBLNKBLNKBLNKBLNHRLNHRLJKMA-KB0SxSjAP8MowBLNHRLNHRIUHwoUEsgoEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs41zi7OKMAuyijCLsoowi7KKMIu
yijCLsoowi7EG8QdwhvKHcIbyh3CG8MoP8UoHcAbyh3CG8odwCHBH8AUwBvALsMoNcAoLsoowi7K
KMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijALs41
3hLNKBLNKBLNKBLNKBLNKBLNHRLNHRLNHRLEKMA-xSjAEswdEs0dEiEfwxQSxDUjwDXAEsooEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oNd8-zDUSzSgSzSgSzSgSzSgS
zSgSzR0SzR0SzR0SwyjAP8E7wT-BKMASyx0SzR0SIR-DFBLENSPCNRLJKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0dEs0d
Es0dEsIowD-BO8M-wSjAEsodEs01wSHAH8AKEsU1IzXBEsooEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oNT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSwig-
wTvFP8EoEsobEsw1xArANRLFNSM1EswuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uNT-MNdA-zDUSzSgSzSgSzSgSzSgSzSgSzR0SzR0SzR0Swig-wTvBEjvCP8AoEsod
Es01xRLENcEjNRLMKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-
yxI10D-MNRLNKBLNKBLNKBLNKBLNKBLNHRLNHRLNHRLCKD-AO8c-wCgSyh0SzR0SyTUjwjUSzCgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1P8o7PzXQP8w1Es0uEs0u
Es0uEs0uEs0uEs0bEs0bEs0bEsIowD8SOxI7wRI7Ej8owBLKGxLNGxLJNSPBNRLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQP8w1Es0uEs0uEs0uEs0uEs0u
Es0bEs0bEs0bEsMowBLAOxI7EjsSwCjAEssbEs0bEso1wS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8g7P8E10BI7PzvDP8E7EsA1Es0uEs0uEs0uEs0uEs0u
Es0bEs0bEs0bEsQowBLAOxI7EsAowBLMGxLNGxLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLjUSwDvAP8MSP8I10D-MNRLNLhLNLhLNLhLNLhLNLhLNGxLNGxLN
GxLFKMAfEsEfKMASzRsSzRsSxCPOEscuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uNT-CO8ISwD-CNdA-zDUSzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSxCjALcANwS3A
KMASzBsSzRsSxCPOEscuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
NT-IO8ASwDXQP8w1Es0uEs0uEs0uEs0uEs0uEs0bEs0bEs0bEsMowC3BDcEtwSjAEssbEs0bEsQj
zhLHLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQP8w1Es0u
Es0uEs0uEs0uEs0uEs0bEs0bEs0bEsMoLcEo-rkAPg0SKC3BKP6iiHnLGxLNGxLEI84Sxy4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNLhLNLhLNLhLN
LhLNLhLNGxLNGxLNGxLCKMT_uQA_wSjE-qKIecobEs0bEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-MNdA-zDUSzSgSzSgSzSgSzSgSzSgSzR0SzR0SzR0S
wigKwCjB-rkAPsEowQrAKP6iiHnKHRLNHRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1KMAuyijCLsoowi7KKMIuyijCLsoowi7GG8IdwhvKHcIb
yh3CGyjACv5yMC3BKP65AD7BKDbBCijAG8gdwhvKHcIbwy7FKMIuyijCLsoowi7KKMIuyijCLsoo
wi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMA1P8w10D-MNf6iiHnNKBLN
KBLNKBLNKBLNKBLNHRLNHRLNHRLBKAo2ywooEskdEs0dEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oNT-MNdA-zDUSzSgSzSgSzSgSzSgSzSgSzR0SzR0SzR0S
wSgKNv7-rMUUCjbDChQxNgooEskdEs0dEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oNT-MNdA-zDUSzSgSzSgSzSgSzSgSzSgSzR0SzR0SzR0SwSjBMcAUCjbB
ChQxwCjBEskdEs0dEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oNT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSwyjAMcAUwzHAKMASyxsSzRsSzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNKBLN
KBLNKBLNKBLNKBLNHRLNHRLNHRLEKMkSzB0SzR0SzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSg1P8w10D-MNRLNKBLNKBLNKBLNKBLNKBLNHRLNHRLNHRLFKMAt
wyjAEs0dEs0dEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
NT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSxCjALcUowBLMGxLNGxLMFMASzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNLhLNLhLNLhLN
LhLNLhLNGxLNGxLNGxLEKC3HKBLMGxLNGxLLFAofFBLMLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQEsA7yBLANRLNLhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLE
KME2wCg2wCjBEswbEs0bEskUwB-AIcESyy4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS41EsI7xhLANdA-zDUSzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSxDXAKArAKArA
KDXCEsobEs0bEsgUH8MhEswuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uNTvAEj-JNdA-zDUSzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSwzXBKMU1wxLJGxLNGxLIFB-D
IRLMLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU7wBI-yTXQP8w1
Es0uEs0uEs0uEs0uEs0uEs0bEs0bEs0bEsM1zRLJGxLNGxLHNcAKH8AhwBLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-wBI-yTXQP8w1Es0uEs0uEs0uEs0uEs0u
Es0uEs0bEs0bEsM1zRLJGxLNGxLGNcIKwDXBEswuEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uNT-AOz-JNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzRsSzRsSxDXLEsob
Es0bEsc1xRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-wBI-
yTXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0dEs0dEsc1xRLNHRLNHRLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1KMAuyijCLsoowi7KKMIuyijC
Lsoowi7KKMIbyh3CG8odwhvKHcIbyh3CG8odKMEuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijC
Lsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijANT-MNdA-zDUSzSgSzSgSzSgSzSgS
zSgSzSgSzR0SzR0SzR0SzR0SzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSg1P8w10D-MNRLNKBLNKBLNKBLNKBLNKBLNKBLNHRLNHRLNHRLNHRLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1Es0oEs0o
Es0oEs0oEs0oEs0oEs0dEs0dEs0dEs0dEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oNT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSzRsS
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-M
NRLNKBLNKBLNKBLNKBLNKBLNKBLNHRLNHRLNHRLNHRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0dEs0d
Es0dEs0dEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
NT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSzRsSzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNLhLNLhLNLhLNLhLNLhLN
LhLNGxLNGxLNGxLNGxLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLjU-zDXQEsA7yBLANRLNLhLNLhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLNGxLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjUSwjvGEsA10D-MNRLN
LhLNLhLNLhLNLhLNLhLNLhLNGxLNGxLNGxLNGxLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU7wBI-yTXQP8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0bEs0b
Es0bEs0bEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
NTvAEj-JNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzRsSzRsSzRsSzRsSzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8ASP8k10D-MNRLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNGxLNGxLNGxLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLjU-wDs-yTXQP8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0bEs0bEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-AEj-JNdA-
zDUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzR0SzR0SzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1P8w10D-MNSjALsoowi7KKMIuyijCLsoowi7KKMIu
yijCLsoowi7DG8UdwhvKHcIbxi7CKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7K
KMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0dEs0dEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oNT-MNdA-zDUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzR0SzR0SzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1P8w10D-MNRLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-LEjXQP8w1
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oNT-KOz810D-MNRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KDU-zDXQP8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-IOz-BNdA-zDUSzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS41P8cSP8E7NdASwjvGEsA1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNRLAO8MS
wjsSwDXQO8ASP8k1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-MNdA7wBI-yTUSzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS41P8w10D-AEj-JNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQP8A7
P8k1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-MNdA-wBI-yTUSzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS41P8w10D-MNRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1KMAuyijCLsoowi7K
KMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoo
wi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMA1P8w10D-COz-HNRLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKDU-wjs-xzXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oNT-M
NdA-wDs-yTUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1P8A7P8k10D8SP8o1Es0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uNT8SP8o10BI-yzUSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1Ej-LNdA-zDUS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1P8w10D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-
zDXQP8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-MNdASwDvIEsA1Es0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uNRLAO8gSwDXQP8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-MNdA-zDUSzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQ
P8w1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-MNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS41P8w10D-MNRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKDU-zDXQP8w1KMAuyijCLsoowi7KKMIu
yijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7K
KMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMA1P8w10D-MNRLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKDU-zDXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oNT-JOz-ANdA-zDUS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSg1P8g7P8E10D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LjU-xzs-wjXQP8w1Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0o
Es0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oEs0oNT-HEj-CNdA-zDUSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgSzSgS
zSgSzSgSzSgSzSgSzSg1P8U7Ej-DNdA-zDUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8Q7P8U1
0D-MNRLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLjU-zDXQEsI7xhLANRLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLjUSO8kSwDXQO8ASP8k1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-JEj-ANdA7wBI-
yTUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8gSP8E10D-AEj-JNRLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLNLhLN
LhLNLhLNLjU-xzs-wjXQP8A7P8k1Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0u
Es0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uEs0uNT-GOz-DNdA-wBI-
yTUSzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4S
zS4SzS4SzS4SzS4SzS4SzS4SzS4SzS4SzS41P8w10D-MNRLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLNKBLN
KDU-zDXQP8w1KMAuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7K
KMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoowi7KKMIuyijCLsoo
wi7KKMA1P8M7P8Y10D-MNf39-f39-fw-zDXHP8YSP8wSP8Q1wT-EEj-NEjvBEj-BNcE-wxI7wRI-
yRI-zRI-yhI-wTvBEj-JEj-NEjvBEj-JEj-NEj-NEj-NEjvBEj-JEjvBEj-JEj-eO8ESP8kSP80S
O8ESP8kSP8g1xD-KEj-QEj-KEj-gEj-NEj-NEsA-zBI-zhI-zBI-wzXAADXAP8M7P807P8E7PzXB
ADU-wxI-wTs-yRI-zTs-yjs-xDs-yRI-zRI-wTs-yRI-zTs-zRI-zRI-wTs-yRI-wTs-yRI-4Ts-
yRI-zRI-wTs-yRI-xjXBLf65AD7ALTXBP8g7P9A7P8o7P_A7P807P807-qKIeT-MOz-OOz-MOz-C
NcAAwTXAP8I7P807P8E1wQDANcA-wzs-zTs-zTs-yjs-0Ds-zTs-zTs-zTs-zTs-zTs-zTs-zTs-
7Ts-zTs-zTs-xjUt-rkAPg3AEsAtwDU-yDs-0Ds-yjs-4Ds-zTs-zTvAP8w7P847P8w7wT81wADD
NcA7wP6iiHnAOyjAP8EowD-AOz87wBLAPzXBAME1wT-DKMA-wSjAP8Y1xD-ANcI7PzsowBI-wSg-
xjs-0Ds-zTs-zTvBP8Y7PzvAEsA-zTs-zTs-zTs-xjXCP8E7P8UowD-kOz-HKMA-wjs-zTvBP8M1
wP65AD4-wA3AEsAtNcA-xijAP8E7wD-GOz87wP6iiHnAP8o7P9E7wD-GOz87wBLAO8A-xjs-O8AS
wDvAP8Y7PzvAEsA7P8w7P807wD-MOz-ANcAAxTXAP8A7KD-AKD8oP8AoP8Q7NcAAxTXAP8EoOz8o
Pyg-wCg-xDXAAMI1wD81AMA1P8AoP8AoP8AowD-GOz-QOz-NOz-NOz-NOz-NOz-NOz-NOz-FNcAS
wDXAP8A7P8QoP8AoP8M7P807P8g1wj87P8YoP8AoP8E7P807P8U1LQ0-wA3A-rkAPsEtNT-FKD87
KD-POz-KOz-QOz-NOz-NOz-NO8A-zDs-yP6iiHk7P8I7P8w7P8A1AMc1P8A7KD8owD8oPyjAP8Q1
wADHNcA-wCgSKMA-wig-xDUAxDXBAMA1P8AoPyjAP8EoP8Y7P9ASP80SP80SP807P80SP80SP80S
P8Q1wBIxwBI1wD8SP8QoPyjAEjs-zBI7P8s1wBTANcASP8YoPyjAP8ESP80SP8U1-rkAPg3CEsIt
NT-FKD8owD-POz-KOz-L-qKIeTs-0Ts-zTs-zTvAP8wSP8g7P8MSP8wSP8A1AMc1P8ASKMA-KD8o
wD8oP8Q1AMk1P8AowD8oPzs-KD-FNQDANcAAxTU-wCjAPyg-wSg-xhI-xDs-yRI-zRI-wTs-yRI-
zRI-zRI-zRI-wTs-yRI-wTs-wDUSMRTAMRI1PxI-xCjAPyg7P807P8Y7P8M1FAofFDXAP8YowD8o
P8ESP8E7P8kSP8U1-rkAPsANwBLDLTU-xSjA-qKIeSg-zxI-yhI-yzs-0hI-zRI-zRLAP8wSP8Y7
wT-BO8ASO8wSO8A1AMc1O8ASKDvAKDsoO8AoO8Q1AMk1O8AoEj8oPxIoO8Y1AMA1wADFNTvAKDvA
KDvBKDvGEjvBP8ESO8kSO80SP8ESO8kSO80SO80SO80SP8ESO8kSP8ESOzXAEhTBMRI1wBI7xCg7
wCg7P8E7yz-BO8A-wRI7wjXAFB8hwTU7xig7wCg7wRI-wRI7yRI7xTUt-rkAPsYtNTvFKDv_ooh5
KDvPEjvKEjvMP8E7zxI7zRI7zRLBO8gSOxLAO84SO8wSO8A1wADFNcA7wBIoO8AoOyg7wCg7xDUA
yTU7wCgSOyg7KDvHNQDENcQ7wCg7wCg7wSg7xhI7xBI7yRI7zRI7wRI7yRI7zRI7zRI7zRI7wRI7
yRI7wRI7NRIxFMAxwBIuNRI7xCg7wCg71xI7wTXAFB-BITXAO8YoO8AoO8ESO8ESO8kSO8U1wC3_
uQA_xC01wDvFKDv_ooh5KDvPEjvKEjvgEjvNEjvNEsA-zBI7zi47zC47wTXAAMM1wDvBLjsowDvB
KMA7xTUAyTU7wSjAO8AowjvENcAAwjXAO8YowC47wCjBO8UuO8QuO8kuO80uO8EuO8kuO80uO80S
O80uO8EuO8kuO8EuOzUSFMAxwBLALjUuO8UowDvYLjvBNRQfwiE1LjvHKMA7whI7wS47yS47xjUt
wP65AD7CLcA1O8cowDvQLjvKLjvgLjvNLjvNLv6iiHk-zBI7xi4SO8ISLsISwDvAEsA7wxIuEjvB
NcAAwTXAEsEuwBI7wxIuwBLDLjXAAMc1wDvAEi7AEsAuEjsSwTvDNcQ7wBIuwBLDLsESwDvAEsAu
EsIuEsAuwBLALhI7EsE7wxIuEjvDEi7AEsMuwRLALhI7EsE7wxIuEjvDEi7AEsMuwhLAO8ESwTsS
LhLALhI7wxIuwBLDLsESwC4SOxLBO8MSLsASwC4SNRIxwRLBLjUuwBLCLsASLhI7whIuwBLCLsAS
LhI7whIuwBLALhI7EjUUH8EhwDUuwRLAO8ESwTsSLhLALsASwC4SOxLBO8MSLhI7wxIuNcEtwjXB
EjvAEsAuEsIuEsAuEjvDEi7AEsMuwRLAO8ASwC4Swi4SwC7AEsIuwBIuEjvCEi4SO8MSLsASwy7A
EjvDEi7AEsMuwBI7wxIuwBLDLsE-zC7AEsA7wBLALhI7xS47zC47wzXAADXAO8MuO8UuO8UuNcAA
xTXAO8IuO8USO8UuO8UuO8UuO8USO8UuO8USO8UuO8UuO8UuO8USO8UuO8UuO8UuO80uO8UuO8Uu
O8USO8UuO8M1wC4Swi41wC4SO8ESOxLBO8USO8ESOxLBO8w1wCHBCjXALjvNLjvFEjvFLjvFLjvA
NcADwDXAO8USO8UuO8UuO8UuO8USO8UuEjvBEjsSwTvMLjvFLjvFLjvFLjvFLjvFLhI-zBI7xRLA
O8USO8wSO8Q1wTvEEjvFEjvFEjs1xzvDEjvFEjvFEjvFEjvFEjvNEjvFEjvFEjvFEjvFEjvFEjvF
EjvFEjvFEjvNEjvFEjvFEjvFEjvFEjvENcAuwjXAOxI7wRI7EsI7yBI7EsI7zBI1wAo1wTsSO80S
O8USO8USO8USO8E1LcA1EjvNEjvFEjvFEjvNEjvBEjsSwjvMEjvFEjvFEjvFEjvFEjvFEsA-zBI7
xi47xRI7zBI7xRI7xRI7xRI7xRI7xS47xRI7xS47xRI7xRI7xRI7xRI7xRI7xS47xRI7xRI7xRI7
xS47xRI7xRI7xRI7xhI7xBI7xRI7xRI7xS47xRI7xTXEO8ASxy47xRLGLjvMLjs1wTvBEjvGEjvE
EjvFLjvFEjvFEjvBNf65AD4tNf6iiHk7xRI7xRI7xRI7xRI7xRI7xRLHLjvMEjvFEjvFEjvFEjvF
EjvFEsA-zBI7xRI1-f39-f3d-rkAPjX98z-MNf39-f395hI1-fM-zDX9-f39-eYSNf3zP8w1-f39
-f39-d4-zDX9-f39-f393j-MNf39-f39-f3eP8w1-f39-f39-d4-zDX9-f39-f393j-MNccAAAAA
AAAAAQ==
:: lib/.info.pod
--[[pod,created="2026-01-04 08:23:37",modified="2026-01-04 08:44:13"]]
:: lib/beholder.lua/.info.pod
--[[pod,created="2026-01-04 08:23:37",modified="2026-01-04 08:44:13"]]
:: lib/beholder.lua/MIT-LICENSE.txt
b64$Q29weXJpZ2h0IChjKSAyMDExIEVucmlxdWUgR2FyY8OtYSBDb3RhCgpQZXJtaXNzaW9uIGlz
IGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcg
YQpjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxl
cyAodGhlCiJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3Ry
aWN0aW9uLCBpbmNsdWRpbmcKd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBj
b3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLApkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQv
b3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8KcGVybWl0IHBlcnNvbnMgdG8g
d2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvCnRoZSBm
b2xsb3dpbmcgY29uZGl0aW9uczoKClRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlz
IHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCmluIGFsbCBjb3BpZXMgb3Igc3Vi
c3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgoKVEhFIFNPRlRXQVJFIElTIFBST1ZJ
REVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKT1IgSU1Q
TElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgpNRVJD
SEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZS
SU5HRU1FTlQuCklOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xE
RVJTIEJFIExJQUJMRSBGT1IgQU5ZCkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwg
V0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsClRPUlQgT1IgT1RIRVJXSVNFLCBBUklT
SU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFClNPRlRXQVJFIE9SIFRI
RSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLg==
:: lib/beholder.lua/README.textile
b64$aDEuIGJlaG9sZGVyLmx1YQoKQSBzaW1wbGUgZXZlbnQgb2JzZXJ2ZXIgZm9yIEx1YS4KCmgx
LiBFeGFtcGxlCgo8cHJlPgpiZWhvbGRlciA9IHJlcXVpcmUgJ2JlaG9sZGVyJwoKLi4uCgpsb2Nh
bCBnb2JsaW4xID0ge3g9MTAwLCB5PTEwMH0KZ29ibGluMS5wYXVzZUlkID0gYmVob2xkZXIub2Jz
ZXJ2ZSgiUEFVU0UiLCBmdW5jdGlvbigpIGdvYmxpbjEucGF1c2VkID0gdHJ1ZSBlbmQpCgouLi4K
CmxvY2FsIGdvYmxpbjIgPSB7eD0yMDAsIHk9MTAwfQpnb2JsaW4yLnBhdXNlSWQgPSBiZWhvbGRl
ci5vYnNlcnZlKCJQQVVTRSIsIGZ1bmN0aW9uKCkgZ29ibGluMi5wYXVzZWQgPSB0cnVlIGVuZCkK
Ci4uLgoKCmZ1bmN0aW9uIHBhdXNlQnV0dG9uUHJlc3NlZCgpCiAgYmVob2xkZXIudHJpZ2dlcigi
UEFVU0UiKQplbmQKCgouLi4KCmZ1bmN0aW9uIHVwZGF0ZUdvYmxpbihnb2JsaW4pCiAgaWYgZ29i
bGluLnBhdXNlZCB0aGVuCiAgICByZXR1cm4gInp6eiIKICBlbHNlCiAgICByZXR1cm4gIndhYWFy
Z2ghIgogIGVuZAplbmQKCi4uLgoKZnVuY3Rpb24gZGVzdHJveUdvYmxpbihnb2JsaW4pCiAgYmVo
b2xkZXIuc3RvcE9ic2VydmluZyhnb2JsaW4ucGF1c2VJZCkKZW5kCjwvcHJlPgoKKE5vdGUuIGlm
IHlvdSBhcmUgZG9pbmcgbG90cyBvZiB0aGF0ICJpZiB3aGF0ZXZlci5zdGF0ZSB0aGVuIC4uLiIg
eW91IG1pZ2h0IHdhbnQgdG8gZ2l2ZSBhIGxvb2sgdG8gInN0YXRlZnVsLmx1YSIuaHR0cC4vL2dp
dGh1Yi5jb20va2lraXRvL3N0YXRlZnVsLmx1YSApCgpoMS4gV2h5PwoKVGhpcyBsaWJyYXJ5IHRy
aWVzIHRvIHNvbHZlIHRoZSBmb2xsb3dpbmcgcHJvYmxlbS4gc29tZSBhY3Rpb25zIG5lZWQgdG8g
YmUgZXhlY3V0ZWQgd2hlbiBzb21lIGFzeW5jaHJvbm91cyBjb25kaXRpb24gaXMgZnVsZmlsbGVk
LiBCeSAiYXN5bmNyb25vdXMiIHdlIG1lYW4gdGhhdCBpdCBzb21ldGhpbmcgdGhhdCB0eXBpY2Fs
bHkgZG9lc24ndCBkZXBlbmQgb24gdGhlIGNvZGUuIEhlbmNlIHByZWNhbGN1bGF0aW5nIGl0IGJl
Zm9yZWhhbmQgaXMgaW1wcmFjdGljYWwuCgpTb21lIGV4YW1wbGVzLgoKKiBUaGUgcGF1c2UgbWVu
dSBpcyBicm91Z2h0IHVwLCBhbmQgYWxsIHRoZSBhY3RvcnMgaW4geW91ciB2aWRlb2dhbWUgbmVl
ZCB0byBiZSBmcm96ZW4uCiogQW4gaW1hZ2UgaGFzIGl0ZW0gaGFzIGJlZW4gbG9hZGVkIGZyb20g
ZGlzaywgYW5kIGEgcHJvZ3Jlc3MgYmFyIG5lZWRzIHRvIGJlIHVwZGF0ZWQuCiogVGhlIHVzZXIg
cHJlc3NlcyBjZXJ0YWluIGNvbWJpbmF0aW9uIG9mIGtleXMuCgpUaGUgd2F5IHRoZXNlIHByb2Js
ZW1zIGFyZSB0eXBpY2FsbHkgaGFuZGVkIGlzIGJ5IGNvbnRpbnVvdXNseSBwb2xsaW5nIGZvciB0
aGUgdHJpZ2dlciBjb25kaXRpb24uIEZvciBleGFtcGxlLCBvbiB0aGUgcGF1c2UgbWVudSwgb25l
IHdvdWxkIGZpbmQgdGhpcyBjb2RlIG9uIHRoZSBlbmVteSBtb3ZlbWVudCByb3V0aW5lcy4KCjxw
cmU_CmlmIHBhdXNlX21lbnVfaXNfdXAgdGhlbgogIC0tIGRvIHRoZSBwYXVzZS1yZWxhdGVkIHN0
dWZmCmVsc2UKICAtLSBkbyB0aGUgbm9uLXBhdXNlIHJlbGF0ZWQgc3R1ZmYuCmVuZAo8L3ByZT4K
CllvdSB3aWxsIGhhdmUgYSBjb2RlIHNpbWlsYXIgdG8gdGhhdCBvbiBlYWNoIHBhcnQgdGhhdCBu
ZWVkcyB0byBiZSBzdG9wcGVkLiBvbiB5b3VyIGVuZW15IGNvZGUsIHRoZSBidWxsZXQgY29kZSwg
dGhlIHBsYXllciBjb2RlLCBldGMuCgpCdXQgdGhlIGJpZ2dlc3QgcHJvYmxlbSB3aXRoIHRoYXQg
Y29kZSBpcyBsYWNrIG9mIHNlcGFyYXRpb24uIFRoZSBjb2RlIGRlYWxpZ24gd2l0aCB5b3VyIGdv
YmxpbnMgc2hvdWxkIG9ubHkgZGVhbCB3aXRoIGdvYmxpbiBzdHVmZi4gSXQgc2hvdWxkIG5vdCAi
a25vdyIgYWJvdXQgdGhlIG1lbnUgc3lzdGVtLCBvciB0aGUga2V5Ym9hcmQgYWN0aW9ucywgb3Ig
dGhlIGZpbGUgbG9hZGVyLiBBbmQgdGhlIHNhbWUgZ29lcyB3aXRoIHlvdXIgYnVsbGV0IGNvZGUs
IHBsYXllciBjb2RlLCBldGMuIFRoZXkgZG9uJ3QgbmVlZCB0byBrbm93IGFib3V0IGV4ZXJuYWwg
c3lzdGVtcywgc3VjaCBhcyB0aGUga2V5Ym9hcmQuCgpUaGlzIGxpYnJhcnkgYWxsb3dzIHlvdSB0
byBidWlsZCAid2FsbHMiIGJldHdlZW4gdGhlbS4geW91ciBrZXlib2FyZCBjb2RlIHdpbGwganVz
dCByYWlzZSBldmVudHMsIGFuZCB5b3VyIHBsYXllciBjb2RlIHdpbGwgb2JzZXJ2ZSB0aG9zZSBl
dmVudHMuIFRoaXMgYWxsb3dzIGZvciBiZXR0ZXIgZW5jYXBzdWxhdGlvbjsgaWYgeW91IGxhdGVy
IGFkZCBtdWx0aXBsYXllciBmdW5jdGlvbmFsaXR5LCBmb3IgZXhhbXBsZSwgdGhlIG5ldHdvcmsg
bW9kdWxlIHdpbGwganVzdCBoYXZlIHRvIHJhaXNlIHRoZSBzYW1lIGV2ZW50cyBqdXN0IGxpa2Ug
dGhlIGtleWJvYXJkIG1vZHVsZSBkaWQ7IHlvdXIgcGxheWVyIGxvZ2ljIHdpbGwgYmUgdW5hZmZl
Y3RlZC4KCllvdSBjYW4gb2J2aW91c2x5IGF0dGFjaCBhbnkgbnVtYmVyIG9mIG9ic2VydmVycyB0
byBhbnkgZ2l2ZW4gZXZlbnQuIFNpbWlsYXJseSwgeW91IGFyZQoKaDEuIEhhbHRpbmcgZXZlbnQg
b2JzZXJ2YXRpb24KCkV2ZXJ5IGNhbGwgdG8gQGJlaG9sZGVyLm9ic2VydmVAIHJldHVybnMgYW4g
aWRlbnRpZmllciB3aGljaCBjYW4gYmUgc3RvcmVkLgoKPHByZT5sb2NhbCBpZCA9IGJlaG9sZGVy
Lm9ic2VydmUoIkZPTyIsIGJhciwgYmF6KTwvcHJlPgoKVGhhdCBpZGVudGlmaWVyIGNhbiBiZSB1
c2VkIHRvIGNhbmNlbCB0aGUgb2JzZXJ2YXRpb24gYXQgYW55IG1vbWVudC4gWW91IGNhbiBkbyBz
byBieSB1c2luZyB0aGUgQGJlaG9sZGVyLnN0b3BPYnNlcnZpbmdAIG1ldGhvZC4KCjxwcmU_YmVo
b2xkZXIuc3RvcE9ic2VydmluZyhpZCk8L3ByZT4KCmgxLiBDb21wb3NlZCBldmVudHMKCkV2ZW50
cyBjYW4gYmUgYW55IHR5cGUgb2YgTHVhIG9iamVjdC4gT24gdGhlIGV4YW1wbGUsIHdlIHVzZWQg
dGhlICJQQVVTRSIgc3RyaW5nLiBJdCBjb3VsZCBhbHNvIGJlIGEgbnVtYmVyLCBhIGZ1bmN0aW9u
IG9yIGEgdGFibGUuIFRoZSA9PSBvcGVyYXRvciBpcyB1c2VkIGluIGFsbCBjYXNlcy4KCkNvbXBv
c2VkIGV2ZW50cyBhcmUgYnVpbHQgZnJvbSBtb3JlIHRoYW4gb25lIGx1YSBvYmplY3QuIFlvdSBj
YW4gZG8gdGhlbSBieSBzaW1wbHkgYWRkaW5nIG1vcmUgcGFyYW1ldGVycyB0byB0aGUgb2JzZXJ2
ZS90cmlnZ2VyIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGUsIHRoaXMgdHJpZ2dlci4KCjxwcmU_YmVo
b2xkZXIudHJpZ2dlcignUExBWUVSREVURUNUSU9OJywgcGxheWVyMSwgMTAwLCAyMDApPC9wcmU_
CgpXaWxsIHRyaWdnZXIgdGhpcyBhY3Rpb24uCgo8cHJlPmJlaG9sZGVyLm9ic2VydmUoJ1BMQVlF
UkRFVEVDVElPTicsIHBsYXllcjEsIDEwMCwgMjAwLCBmdW5jdGlvbigpIHByaW50KCJwbGF5ZXIx
IGRldGVjdGVkIGF0IDEwMCwgMjAwIikgZW5kKTwvcHJlPgoKQ29tcG9zZWQgZXZlbnRzIGFyZSBp
bmNsdXNpdmUuIFRoaXMgbWVhbnMgdGhhdCB0aGlzIG90aGVyIG9ic2VydmVyIHdpbGwgYWxzbyBn
ZXQgYWN0aXZhdGVkIGJ5IHRoZSBhZm9yZW1lbnRpb25lZCB0cmlnZ2VyLgoKPHByZT5iZWhvbGRl
ci5vYnNlcnZlKCdQTEFZRVJERVRFQ1RJT04nLCBwbGF5ZXIxLCBmdW5jdGlvbih4LHkpIHByaW50
KCJwbGF5ZXIxIGRldGVjdGVkIGF0ICIseCx5KTwvcHJlPgoKTm90aWNlIHRoYXQgdGhlIHR3byAi
bm9uLW9ic2VydmVkIGludGVnZXJzIiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgYXMg
YWRkaXRpb25hbCBwYXJhbWV0ZXJzLiBUaGF0IHNlY29uZCBhY3Rpb24gd2lsbCBiZSBleGVjdXRl
ZCBhbnkgdGltZSBwbGF5ZXIxIGlzIGRldGVjdGVkLCBubyBtYXR0ZXIgd2hhdCBjb29yZGluYXRl
cy4KClNpbWlsYXJseSwgeW91IGNhbiBhZGQgYW4gYWN0aW9uIHRoYXQgd2lsbCBiZSB0cmlnZ2Vy
ZWQgZm9yIGFueSBwbGF5ZXIgZGV0ZWN0aW9uLgoKPHByZT5iZWhvbGRlci5vYnNlcnZlKCdQTEFZ
RVJERVRFQ1RJT04nLCBmdW5jdGlvbihwbGF5ZXIseCx5KSBwcmludChwbGF5ZXIubm8sIiBkZXRl
Y3RlZCBhdCAiLHgseSk8L3ByZT4KCmgxLiBUaGUgbmlsIGV2ZW50CgpJZiB5b3Ugd2FudCB0byBk
ZXRlY3QgYWxsIHNpZ25hbHMgcmFpc2VkIChpLmUuIGZvciBsb2dnaW5nIGFuZCBkZWJ1Z2dpbmcp
IHlvdSBjYW4gZG8gc28gYnkgb2JzZXJ2aW5nIHRoZSAiZW1wdHkiIGV2ZW50IC0gc2ltcGx5IHBh
c3MgYSBmdW5jdGlvbiB0byBvYnNlcnZlLCB3aXRob3V0IGFkZGluZyBhbnkgbW9yZSBwYXJhbXMu
Cgo8cHJlPmJlaG9sZGVyLm9ic2VydmUoZnVuY3Rpb24oLi4uKSBsb2coIkV2ZW50IHRyaWdnZXJl
ZCIsIC4uLikgZW5kKTwvcHJlPgoKQSBxdWljayBhbmQgZGlydHkgd2F5IG9mIGR1bXBpbmcgYWxs
IGV2ZW50cyBpbiB0aGUgc3RhbmRhcmQgb3V0cHV0IGlzIGp1c3Qgb2JzZXJ2aW5nIHRoZSBuaWwg
ZXZlbnQgd2l0aCBAcHJpbnRALgoKPHByZT5iZWhvbGRlci5vYnNlcnZlKHByaW50KTwvcHJlPgoK
SWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZXZlbnRzIGF0dGFjaGVkIG9ubHkgdG8gdGhlIG5p
bCBldmVudCwgeW91IGNhbiBkbyBzbyBieSBjYWxsaW5nIHRyaWdnZXIgd2l0aG91dCBwYXJhbXMu
Cgo8cHJlPmJlaG9sZGVyLnRyaWdnZXIoKTwvcHJlPgoKaDEuIFRyaWdnZXJpbmcgYWxsIGNhbGxi
YWNrcwoKWW91IGNhbiB1c2UgdGhlIEB0cmlnZ2VyQWxsQCBtZXRob2QgdG8gdHJpZ2dlciBhbGwg
b2JzZXJ2ZWQgZXZlbnRzICh0aGlzIHdpbGwgYmUgdXNlZnVsIG1vc3RseSBmb3IgZGVidWdnaW5n
KS4KCjxwcmU_YmVob2xkZXIudHJpZ2dlckFsbCguLi4pPC9wcmU_CgpOb3RlIHRoYXQgeW91IGNh
biBwYXNzIHBhcmFtZXRlcnMgdG8gQHRyaWdnZXJBbGxALiBUaGVzZSB3aWxsIGJlIHBhc3NlZCB0
byBhbGwgY2FsbGJhY2tzIChtYWtlIHN1cmUgdGhhdCB0aGV5IGFyZSBwcmVwYXJlZCBmb3IgdGhp
cywgb3IgeW91IHdpbGwgZ2V0IGVycm9ycykuCgpoMS4gR3JvdXBzIG9mIGV2ZW50cwoKU29tZXRp
bWVzIGl0IG1ha2VzIHNlbnNlIHRvIGdyb3VwIHNldmVyYWwgZXZlbnRzIHRvZ2V0aGVyLCBzbyB0
aGV5IGNhbiBiZSBlYXNpbHkgZGlzY2FyZGVkLgoKWW91IGNhbiB1c2UgdGhlIEBncm91cEAgbWV0
aG9kIHRvIGRvIGp1c3QgdGhhdC4KCk9uIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSwgQG1vdmVQbGF5
ZXJVcC9Eb3duL0xlZnQvUmlnaHRAIGFyZSBmdW5jdGlvbnMgZGVmaW5lZCBlbHNld2hlcmUuCgo8
cHJlPiBsb2NhbCBwbGF5ZXIgPSB7fSAtLSBwbGF5ZXIgY291bGQgYmUgYW55IEx1YSBvYmplY3QK
Ci4uLgoKYmVob2xkZXIuZ3JvdXAocGxheWVyLCBmdW5jdGlvbigpCiAgYmVob2xkZXIub2JzZXJ2
ZSgidXAiLCAgICBtb3ZlUGxheWVyVXApCiAgYmVob2xkZXIub2JzZXJ2ZSgiZG93biIsICBtb3Zl
UGxheWVyRG93bikKICBiZWhvbGRlci5vYnNlcnZlKCJsZWZ0IiwgIG1vdmVQbGF5ZXJMZWZ0KQog
IGJlaG9sZGVyLm9ic2VydmUoInJpZ2h0IiwgbW92ZVBsYXllclJpZ2h0KQplbmQpPC9wcmU_CgpP
bmNlIHRoZXNlIG9ic2VydmF0aW9ucyBhcmUgc2V0dXAsIHlvdSBjYW4gc3RvcCBvYnNlcnZpbmcg
dGhlbSBpbiBhIHNpbmdsZSBsaW5lOgoKPHByZT5iZWhvbGRlci5zdG9wT2JzZXJ2aW5nKHBsYXll
cik8L3ByZT4KCmgxLiBJbnN0YWxsYXRpb24KCkp1c3QgY29weSB0aGUgYmVob2xkZXIubHVhIGZp
bGUgd2hlcmV2ZXIgeW91IHdhbnQgaXQgKGZvciBleGFtcGxlIG9uIGEgbGliLyBmb2xkZXIpLiBU
aGVuIHdyaXRlIHRoaXMgaW4gYW55IEx1YSBmaWxlIHdoZXJlIHlvdSB3YW50IHRvIHVzZSBpdC4K
CjxwcmU_bG9jYWwgYmVob2xkZXIgPSByZXF1aXJlICdiZWhvbGRlcic8L3ByZT4KCk9uIHRoaXMg
ZXhhbXBsZSBJJ3ZlIGFzc2lnbmVkIGl0IHRvIGEgbG9jYWwgdmFyaWFibGUuIElmIHlvdSBhcmUg
Z29pbmcgdG8gdXNlIGJlaG9sZGVyIGFjcm9zcyBtdWx0aXBsZSBmaWxlcywgaXQncyBiZXR0ZXIg
dG8gcmVxdWlyZSB0aGUgZmlsZSBqdXN0IG9uY2UgYW5kIG1ha2UgdGhlIHZhcmlhYmxlIGdsb2Jh
bC4KClRoZSBAcGFja2FnZS5wYXRoQCB2YXJpYWJsZSBtdXN0IGJlIGNvbmZpZ3VyZWQgc28gdGhh
dCB0aGUgZm9sZGVyIGluIHdoaWNoIGJlaG9sZGVyLmx1YSBpcyBjb3BpZWQgaXMgYXZhaWxhYmxl
LCBvZiBjb3Vyc2UuCgpQbGVhc2UgbWFrZSBzdXJlIHRoYXQgeW91IHJlYWQgdGhlIGxpY2Vuc2Us
IHRvbyAoZm9yIHlvdXIgY29udmVuaWVuY2UgaXQncyBub3cgaW5jbHVkZWQgYXQgdGhlIGJlZ2lu
bmluZyBvZiB0aGUgYmVob2xkZXIubHVhIGZpbGUpLgoKaDEuIFNwZWNzCgpUaGlzIHByb2plY3Qg
dXNlcyAidGVsZXNjb3BlIi5odHRwcy4vL2dpdGh1Yi5jb20vbm9ybWFuL3RlbGVzY29wZSBmb3Ig
aXRzIHNwZWNzLiBJZiB5b3Ugd2FudCB0byBydW4gdGhlIHNwZWNzLCB5b3Ugd2lsbCBoYXZlIHRv
IGluc3RhbGwgdGVsZXNjb3BlIGZpcnN0LiBUaGVuIGp1c3QgZXhlY3V0ZSB0aGUgZm9sbG93aW5n
IGZyb20gdGhlIHJvb3QgaW5zcGVjdCBmb2xkZXIuCgo8cHJlPgp0c2MgLWYgc3BlYy8qLmx1YQo8
L3ByZT4=
:: lib/beholder.lua/beholder.lua
b64$LS0gYmVob2xkZXIubHVhIC0gdjIuMS4xICgyMDExLTExKQoKLS0gQ29weXJpZ2h0IChjKSAy
MDExIEVucmlxdWUgR2FyY8OtYSBDb3RhCi0tIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQs
IGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBz
b2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgIlNvZnR3YXJl
IiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGlu
ZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVy
Z2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBv
ZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2Fy
ZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRp
b25zOgotLSBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5v
dGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRp
b25zIG9mIHRoZSBTb2Z0d2FyZS4KLS0gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIs
IFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVE
SU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFks
IEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElO
IE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJM
RSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBB
TiBjYWxsYmFjayBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwg
T1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBP
VEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgpsb2NhbCBmdW5jdGlvbiBjb3B5KHQpCiAg
bG9jYWwgYz17fQogIGZvciBpPTEsI3QgZG8gY1tpXT10W2ldIGVuZAogIHJldHVybiBjCmVuZAoK
bG9jYWwgZnVuY3Rpb24gaGFzaDJhcnJheSh0KQogIGxvY2FsIGFyciwgaSA9IHt9LCAwCiAgZm9y
IF8sdiBpbiBwYWlycyh0KSBkbwogICAgaSA9IGkrMQogICAgYXJyW2ldID0gdgogIGVuZAogIHJl
dHVybiBhcnIsIGkKZW5kCi0tIHByaXZhdGUgTm9kZSBjbGFzcwoKbG9jYWwgbm9kZXNCeUlkID0g
bmlsCmxvY2FsIHJvb3QgPSBuaWwKCmxvY2FsIGZ1bmN0aW9uIG5ld05vZGUoKQogIHJldHVybiB7
IGNhbGxiYWNrcyA9IHt9LCBjaGlsZHJlbiA9IHNldG1ldGF0YWJsZSh7fSwge19fbW9kZT0iayJ9
KSB9CmVuZAoKCmxvY2FsIGZ1bmN0aW9uIGZpbmROb2RlQnlJZChpZCkKICByZXR1cm4gbm9kZXNC
eUlkW2lkXQplbmQKCmxvY2FsIGZ1bmN0aW9uIGZpbmRPckNyZWF0ZUNoaWxkTm9kZShzZWxmLCBr
ZXkpCiAgc2VsZi5jaGlsZHJlbltrZXldID0gc2VsZi5jaGlsZHJlbltrZXldIG9yIG5ld05vZGUo
KQogIHJldHVybiBzZWxmLmNoaWxkcmVuW2tleV0KZW5kCgpsb2NhbCBmdW5jdGlvbiBmaW5kT3JD
cmVhdGVEZXNjZW5kYW50Tm9kZShzZWxmLCBrZXlzKQogIGxvY2FsIG5vZGUgPSBzZWxmCiAgZm9y
IGk9MSwgI2tleXMgZG8KICAgIG5vZGUgPSBmaW5kT3JDcmVhdGVDaGlsZE5vZGUobm9kZSwga2V5
c1tpXSkKICBlbmQKICByZXR1cm4gbm9kZQplbmQKCmxvY2FsIGZ1bmN0aW9uIGludm9rZU5vZGVD
YWxsYmFja3Moc2VsZiwgcGFyYW1zKQogIC0tIGNvcHkgdGhlIGhhc2ggaW50byBhbiBhcnJheSwg
Zm9yIHNhZmV0eSAoc2VsZi1lcmFzdXJlcykKICBsb2NhbCBjYWxsYmFja3MsIGNvdW50ID0gaGFz
aDJhcnJheShzZWxmLmNhbGxiYWNrcykKICBmb3IgaT0xLCNjYWxsYmFja3MgZG8KICAgIGNhbGxi
YWNrc1tpXSh1bnBhY2socGFyYW1zKSkKICBlbmQKICByZXR1cm4gY291bnQKZW5kCgpsb2NhbCBm
dW5jdGlvbiBpbnZva2VBbGxOb2RlQ2FsbGJhY2tzSW5TdWJUcmVlKHNlbGYsIHBhcmFtcykKICBs
b2NhbCBjb3VudGVyID0gaW52b2tlTm9kZUNhbGxiYWNrcyhzZWxmLCBwYXJhbXMpCiAgZm9yIF8s
Y2hpbGQgaW4gcGFpcnMoc2VsZi5jaGlsZHJlbikgZG8KICAgIGNvdW50ZXIgPSBjb3VudGVyICsg
aW52b2tlQWxsTm9kZUNhbGxiYWNrc0luU3ViVHJlZShjaGlsZCwgcGFyYW1zKQogIGVuZAogIHJl
dHVybiBjb3VudGVyCmVuZAoKbG9jYWwgZnVuY3Rpb24gaW52b2tlTm9kZUNhbGxiYWNrc0Zyb21Q
YXRoKHNlbGYsIHBhdGgpCiAgbG9jYWwgbm9kZSA9IHNlbGYKICBsb2NhbCBwYXJhbXMgPSBjb3B5
KHBhdGgpCiAgbG9jYWwgY291bnRlciA9IGludm9rZU5vZGVDYWxsYmFja3Mobm9kZSwgcGFyYW1z
KQoKICBmb3IgaT0xLCAjcGF0aCBkbwogICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bcGF0aFtpXV0K
ICAgIGlmIG5vdCBub2RlIHRoZW4gYnJlYWsgZW5kCiAgICB0YWJsZS5yZW1vdmUocGFyYW1zLCAx
KQogICAgY291bnRlciA9IGNvdW50ZXIgKyBpbnZva2VOb2RlQ2FsbGJhY2tzKG5vZGUsIHBhcmFt
cykKICBlbmQKCiAgcmV0dXJuIGNvdW50ZXIKZW5kCgpsb2NhbCBmdW5jdGlvbiBhZGRDYWxsYmFj
a1RvTm9kZShzZWxmLCBjYWxsYmFjaykKICBsb2NhbCBpZCA9IHt9CiAgc2VsZi5jYWxsYmFja3Nb
aWRdID0gY2FsbGJhY2sKICBub2Rlc0J5SWRbaWRdID0gc2VsZgogIHJldHVybiBpZAplbmQKCmxv
Y2FsIGZ1bmN0aW9uIHJlbW92ZUNhbGxiYWNrRnJvbU5vZGUoc2VsZiwgaWQpCiAgc2VsZi5jYWxs
YmFja3NbaWRdID0gbmlsCiAgbm9kZXNCeUlkW2lkXSA9IG5pbAplbmQKCgotLS0tLS0gYmVob2xk
ZXIgdGFibGUKCmxvY2FsIGJlaG9sZGVyID0ge30KCgotLSBiZWhvbGRlciBwcml2YXRlIGZ1bmN0
aW9ucy92YXJzCgpsb2NhbCBncm91cHMgPSBuaWwKbG9jYWwgY3VycmVudEdyb3VwSWQgPSBuaWwK
CmxvY2FsIGZ1bmN0aW9uIGFkZElkVG9DdXJyZW50R3JvdXAoaWQpCiAgaWYgY3VycmVudEdyb3Vw
SWQgdGhlbgogICAgZ3JvdXBzW2N1cnJlbnRHcm91cElkXSA9IGdyb3Vwc1tjdXJyZW50R3JvdXBJ
ZF0gb3Igc2V0bWV0YXRhYmxlKHt9LCB7X19tb2RlPSJrIn0pCiAgICBsb2NhbCBncm91cCA9IGdy
b3Vwc1tjdXJyZW50R3JvdXBJZF0KICAgIGdyb3VwWyNncm91cCArIDFdID0gaWQKICBlbmQKICBy
ZXR1cm4gaWQKZW5kCgpsb2NhbCBmdW5jdGlvbiBzdG9wT2JzZXJ2aW5nR3JvdXAoZ3JvdXApCiAg
bG9jYWwgY291bnQgPSAjZ3JvdXAKICBmb3IgaT0xLGNvdW50IGRvCiAgICBiZWhvbGRlci5zdG9w
T2JzZXJ2aW5nKGdyb3VwW2ldKQogIGVuZAogIHJldHVybiBjb3VudAplbmQKCmxvY2FsIGZ1bmN0
aW9uIGZhbHNlSWZaZXJvKG4pCiAgcmV0dXJuIG4gPiAwIGFuZCBuCmVuZAoKbG9jYWwgZnVuY3Rp
b24gZXh0cmFjdEV2ZW50QW5kQ2FsbGJhY2tGcm9tUGFyYW1zKHBhcmFtcykKICBhc3NlcnQoI3Bh
cmFtcyA_IDAsICJiZWhvbGRlci5vYnNlcnZlIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBwYXJhbWV0
ZXIgLSB0aGUgY2FsbGJhY2suIFlvdSB1c3VhbGx5IHdhbnQgdG8gdXNlIHR3bywgaS5lLjogYmVo
b2xkZXIub2JzZXJ2ZSgnRVZFTlQnLCBjYWxsYmFjaykiKQogIGxvY2FsIGNhbGxiYWNrID0gdGFi
bGUucmVtb3ZlKHBhcmFtcywgI3BhcmFtcykKICByZXR1cm4gcGFyYW1zLCBjYWxsYmFjawplbmQK
CgotLS0tLS0gUHVibGljIGludGVyZmFjZQoKZnVuY3Rpb24gYmVob2xkZXIub2JzZXJ2ZSguLi4p
CiAgbG9jYWwgZXZlbnQsIGNhbGxiYWNrID0gZXh0cmFjdEV2ZW50QW5kQ2FsbGJhY2tGcm9tUGFy
YW1zKHsuLi59KQogIGxvY2FsIG5vZGUgPSBmaW5kT3JDcmVhdGVEZXNjZW5kYW50Tm9kZShyb290
LCBldmVudCkKICByZXR1cm4gYWRkSWRUb0N1cnJlbnRHcm91cChhZGRDYWxsYmFja1RvTm9kZShu
b2RlLCBjYWxsYmFjaykpCmVuZAoKZnVuY3Rpb24gYmVob2xkZXIuc3RvcE9ic2VydmluZyhpZCkK
ICBsb2NhbCBub2RlID0gZmluZE5vZGVCeUlkKGlkKQogIGlmIG5vZGUgdGhlbiByZW1vdmVDYWxs
YmFja0Zyb21Ob2RlKG5vZGUsIGlkKSBlbmQKCiAgbG9jYWwgZ3JvdXAsIGNvdW50ID0gZ3JvdXBz
W2lkXSwgMAogIGlmIGdyb3VwIHRoZW4gY291bnQgPSBzdG9wT2JzZXJ2aW5nR3JvdXAoZ3JvdXAp
IGVuZAoKICByZXR1cm4gKG5vZGUgb3IgY291bnQgPiAwKSBhbmQgdHJ1ZSBvciBmYWxzZQplbmQK
CmZ1bmN0aW9uIGJlaG9sZGVyLmdyb3VwKGdyb3VwSWQsIGYpCiAgYXNzZXJ0KG5vdCBjdXJyZW50
R3JvdXBJZCwgImJlaG9sZGVyLmdyb3VwIGNhbiBub3QgYmUgbmVzdGVkISIpCiAgY3VycmVudEdy
b3VwSWQgPSBncm91cElkCiAgZigpCiAgY3VycmVudEdyb3VwSWQgPSBuaWwKZW5kCgpmdW5jdGlv
biBiZWhvbGRlci50cmlnZ2VyKC4uLikKICByZXR1cm4gZmFsc2VJZlplcm8oIGludm9rZU5vZGVD
YWxsYmFja3NGcm9tUGF0aChyb290LCB7Li4ufSkgKQplbmQKCmZ1bmN0aW9uIGJlaG9sZGVyLnRy
aWdnZXJBbGwoLi4uKQogIHJldHVybiBmYWxzZUlmWmVybyggaW52b2tlQWxsTm9kZUNhbGxiYWNr
c0luU3ViVHJlZShyb290LCB7Li4ufSkgKQplbmQKCmZ1bmN0aW9uIGJlaG9sZGVyLnJlc2V0KCkK
ICByb290ID0gbmV3Tm9kZSgpCiAgbm9kZXNCeUlkID0gc2V0bWV0YXRhYmxlKHt9LCB7X19tb2Rl
PSJrIn0pCiAgZ3JvdXBzID0ge30KICBjdXJyZW50R3JvdXBJZCA9IG5pbAplbmQKCmJlaG9sZGVy
LnJlc2V0KCkKCnJldHVybiBiZWhvbGRlcg==
:: lib/beholder.lua/spec/.info.pod
--[[pod,created="2026-01-04 08:23:37",modified="2026-01-04 08:44:13"]]
:: lib/eggs.p8/.info.pod
--[[pod,created="2026-01-04 08:23:37",modified="2026-01-04 08:44:13"]]
:: lib/eggs.p8/MIT-LICENSE.md
b64$IyMjIFRoZSBNSVQgTGljZW5zZSAoTUlUKQoKQ29weXJpZ2h0IMKpIDIwMjUgRW5yaXF1ZSBH
YXJjaWEgQ290YQoKUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2Us
IHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3Nv
Y2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSDigJxTb2Z0d2FyZeKAnSksIHRvIGRlYWwg
aW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxp
bWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gs
IGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdh
cmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNo
ZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOgoKVGhlIGFi
b3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUg
aW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29m
dHdhcmUuCgpUSEUgU09GVFdBUkUgSVMgUFJPVklERUQg4oCcQVMgSVPigJ0sIFdJVEhPVVQgV0FS
UkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1Qg
TElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9S
IEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNI
QUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENM
QUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0Yg
Q09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBD
T05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1Mg
SU4gVEhFIFNPRlRXQVJFLg==
:: lib/eggs.p8/README.md
b64$IyBlZ2dzLnA4CgpBIHBzZXVkby1bRUNTXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lr
aS9FbnRpdHlfY29tcG9uZW50X3N5c3RlbSkgbGlicmFyeSBmb3IgW1BJQ08tOF0oaHR0cHM6Ly93
d3cubGV4YWxvZmZsZS5jb20vcGljby04LnBocCkuCgoKIyMgQ29yZSBjb25jZXB0cwoKVGhpcyBs
aWJyYXJ5IGhhcyAzIG1haW4gY29uY2VwdHM6IGVudGl0aWVzLCB0YWdzIGFuZCBzeXN0ZW1zLgoK
KiBFbnRpdGllcyBhcmUgTHVhIHRhYmxlcyB3aXRoIHplcm8gb3IgbW9yZSB0YWdzIGFzc29jaWF0
ZWQgdG8gdGhlbS4gVGhleSByZXByZXNlbnQgeW91ciBnYW1lIG9iamVjdHMuIFRoZXkgY29udGFp
biBkYXRhIChsaWtlIGNvb3JkaW5hdGVzLCBoZWFsdGgsIGV0YykgYnV0IG5vIGJlaGF2aW9yIChu
byBmdW5jdGlvbnMpCiogVGFncyBhcmUganVzdCBzdHJpbmdzLgoqIFN5c3RlbXMgYXJlIGx1YSBm
dW5jdGlvbnMgdGhhdCBvcGVyYXRlIG9uIGVudGl0aWVzIHdpdGggc3BlY2lmaWMgdGFncy4KClRo
YXQncyB0aGUgZ2lzdCBvZiBpdC4gT24gYSBwdXJlIEVDUyBzeXN0ZW0geW91IHdvdWxkIGhhdmUg
ZW50aXRpZXMgYnVpbHQgb2YgIkNvbXBvbmVudHMiLCB3aXRoIHRoZSBzeXN0ZW1zIGFjdGluZyBv
biB0aGUgY29tcG9uZW50cyB0aGVtc2VsdmVzIGluc3RlYWQgb2Ygb24gdGhlIGVudGl0aWVzLiBJ
IGZvdW5kIHRoYXQgYXBwcm9hY2ggZGlkbid0ICJnbyB3ZWxsIiB3aXRoIEx1YSBzbyBJIHRyaWVk
IHRvIGRvIDIvM3JkcyBvZiBpdCBpbnN0ZWFkLCBjdXR0aW5nIGNvbXBvbmVudHMgYWxtb3N0IGNv
bXBsZXRlbHkgdW50aWwgb25seSB0aGUgdGFncyBzdXJ2aXZlZC4KCiMjIFF1aWNrICJFZ2dzYW1w
bGUiCgpgYGAgbHVhCiNpbmNsdWRlIGVnZ3MubHVhCgpsb2NhbCB3b3JsZCxyZWRtb3Zlc3JpZ2h0
LGJsdWVtb3Zlc2xlZnQsZHJhdwoKZnVuY3Rpb24gX2luaXQoKQogIGxvY2FsIHdvcmxkID0gZWdn
cygpCgogIC0tIHN5c3RlbSB0byBtb3ZlIGVudGl0aWVzIHRhZ2dlZCAicmVkIiBhbmQgIm1vdiIg
dG8gdGhlIHJpZ2h0CiAgcmVkbW92ZXNyaWdodD0gd29ybGQuc3lzKCJyZWQsbW92IixmdW5jdGlv
bihlKQogICAgZS54ID0gKGUueCArIDEpJTEyOAogIGVuZCkKCiAgLS0gc3lzdGVtIHRvIG1vdmUg
ZW50aXRpZXMgdGFnZ2VkICJibHVlIiBhbmQgIm1vdiIgdG8gdGhlIGxlZnQKICBibHVlbW92ZXNs
ZWZ0PSB3b3JsZC5zeXMoImJsdWUsbW92IixmdW5jdGlvbihlKQogICAgZS54ID0gKGUueCAtIDEp
JTEyOAogIGVuZCkKCiAgLS0gc3lzdGVtIHRvIGRyYXcgYWxsIGVudGl0aWVzIAogIGRyYXc9IHdv
cmxkLnN5cygiIixmdW5jdGlvbihlKQogICAgY2lyYyhlLngsZS55LDUsZS5jb2xvcikKICBlbmQp
CgogIHdvcmxkLmVudCgiYmx1ZSxtb3YiLHt4PTY0LHk9NjAsY29sb3I9MTJ9KSAtLSB3aWxsIG1v
dmUgbGVmdAogIHdvcmxkLmVudCgicmVkLG1vdiIse3g9NjQseT05MCxjb2xvcj04fSkgLS0gd2ls
bCBtb3ZlIHJpZ2h0CiAgd29ybGQuZW50KCJibHVlIiwge3g9NjQseT0zMCxjb2xvcj0xMn0pIC0t
IHdpbGwgbm90IG1vdmUgKG5vIG1vdiB0YWcpCiAgd29ybGQuZW50KCJ5ZWxsb3ciLCB7eD02NCx5
PTIwLGNvbG9yPTEwfSkgLS0gYWxzbyB3aWxsIG5vdCBtb3ZlIChubyBtb3YsIG5vIHJlZCBvciBi
bHVlKQplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQogIC0tIGNhbGwgbW92ZSBzeXN0ZW1zCiAgcmVk
bW92ZXNyaWdodCgpCiAgYmx1ZW1vdmVzbGVmdCgpCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQogIGNs
cygpCiAgLS0gY2FsbCBkcmF3IHN5c3RlbQogIGRyYXcoKQplbmQKYGBgCgpQbGVhc2Ugc2VlIHRo
ZSBmb2xsb3dpbmcgY2FyZHJpZGdlIChbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9r
aWtpdG8vZWdncy5wOC9ibG9iL21haW4vdGVzdF9lZ2dzLmx1YSkpIGZvciBhIG1vcmUgYWR2YW5j
ZSBleGFtcGxlOiAKClshW2VnZ3NdKGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9r
aWtpdG8vZWdncy5wOC9yZWZzL2hlYWRzL21haW4vdGVzdF9lZ2dzLnA4LnBuZyldKGh0dHBzOi8v
d3d3LmxleGFsb2ZmbGUuY29tL2Jicy9jYXJ0X2luZm8ucGhwP2NpZD10ZXN0X2VnZ3MtMCkKCgoj
IyBBUEkKCiMjIyBDcmVhdGluZyBhIHdvcmxkCgpgYGAgbHVhCmxvY2FsIHdvcmxkID0gZWdncygp
CmBgYAoKVGhlIGBlZ2dzYCBmdW5jdGlvbiB0YWtlcyBubyBhcmd1bWVudHMgYW5kIHJldHVybnMg
YSBuZXcgd29ybGQgb2JqZWN0LiBZb3UgY2FuIGNyZWF0ZSBtdWx0aXBsZSB3b3JsZHMgaWYgeW91
IG5lZWQgdG8sIGJ1dCB1c3VhbGx5IG9uZSBpcyBlbm91Z2guCgoKIyMjIEFkZGluZyBlbnRpdGll
cyB0byB0aGUgd29ybGQKCmBgYCBsdWEKbG9jYWwgZW50aXR5ID0gd29ybGQuZW50KHRhZ3MsIG9i
aikKYGBgCgpBZGRzIGFuIGVudGl0eSB0byB0aGUgd29ybGQuIEVudGl0aWVzIHdpbGwgYmUgZmls
dGVyZWQgYnkgc3lzdGVtcyBiYXNlZCBvbiB0aGVpciB0YWdzLgoKIyMjIyBQYXJhbWV0ZXJzCgoq
IGB0YWdzYDogQSBzdHJpbmcgd2l0aCB6ZXJvIG9yIG1vcmUgY29tbWEtc2VwYXJhdGVkIHRhZ3Mu
CiogYG9iamA6IEEgdGFibGUuIFRoZXJlIGlzIG5vIHJlc3RyaWN0aW9uIG9uIHRoZSBjb250ZW50
cyBvZiB0aGUgdGFibGUsIGl0IGNhbiBiZSBhbiBlbXB0eSB0YWJsZS4gSXQgaXMgaG93ZXZlciBy
ZWNvbW1lbmRlZCB0aGF0IHRoZSBjb250ZW50cyBoYXZlIHNvbWUgcmVsYXRpb25zaGlwIHdpdGgg
dGhlIHRhZ3MuCgojIyMjIFJldHVybnMKCiogYGVudGl0eWA6IEl0IGlzIGxpdGVyYWxseSBhIHJl
ZmVyZW5jZSB0byBgb2JqYCwgYWRkZWQgZm9yIGNvbnZlbmllbmNlLgoKIyMjIyBFeGFtcGxlCgpg
YGAgbHVhCmxvY2FsIHBsYXllciA9IHdvcmxkLmVudCgicGxheWVyLG1vdmFibGUsc29saWQiLCB7
eD0wLHk9MH0pCmBgYAoKIyMjIyBOb3RlcwoKKiBOb3RlIHRoYXQgaW5zdGVhZCBvZiB1c2luZyBg
OmAsIHdlIHVzZSBgLmAgZm9yIHdvcmxkIG1ldGhvZHMuIFRoaXMgaXMgYSB0b2tlbi1zYXZpbmcg
ZGVjaXNpb24uCiogYHdvcmxkLmVudCgpYCB3aWxsIHRocm93IGFuIGVycm9yIGlmIGBvYmpgIGlz
IGFuIGVudGl0eSB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gaW5zZXJ0ZWQgaW4gdGhlIHdvcmxkLgoq
IEl0IGlzIHZlcnkgaW1wb3J0YW50IHRoYXQgYG9iamAgaXMgYSB0YWJsZS4gVGhlIGxpYnJhcnkg
d2lsbCBub3QgY2hlY2sgZm9yIHRoaXMuIEhvd2V2ZXIgaXQgd2lsbCBub3Qgd29yayBwcm9wZXJs
eSBpZiB5b3UgYWRkIG5vbi10YWJsZSBlbGVtZW50cy4gSW4gcGFydGljdWxhciwgbnVtYmVycyBh
bmQgc3RyaW5nIG1pZ2h0IGJlaGF2ZSB1bmV4cGVjdGVkbHkuCgoKIyMjIEFkZGluZyBzeXN0ZW1z
IHRvIHRoZSB3b3JsZAoKYGBgIGx1YQpsb2NhbCBzeXN0ZW0gPSB3b3JsZC5zeXModGFncywgZm4p
CmBgYAoKQWRkcyBhIHN5c3RlbSB0byB0aGUgd29ybGQuIFRoZSBzeXN0ZW0gbmVlZHMgdG8gYmUg
aW52b2tlZCAodXN1YWxseSBmcm9tIGBfdXBkYXRlYCBvciBgX2RyYXdgKSB0byBvcGVyYXRlIG9u
IHRoZSBlbnRpdGllcy4gSXQgd2lsbCBvbmx5IG9wZXJhdGUgb24gZW50aXRpZXMgd2l0aCB0aGUg
c3BlY2lmaWVkIHRhZ3MuCgojIyMjIFBhcmFtZXRlcnMKCiogYHRhZ3NgOiBBIHN0cmluZyB3aXRo
IHplcm8gb3IgbW9yZSBjb21tYS1zZXBhcmF0ZWQgdGFncy4gQSBzeXN0ZW0gd2l0aCBhbiBlbXB0
eSAoYCIiYCkgYHRhZ3NgIHBhcmFtZXRlciB3aWxsIG9wZXJhdGUgb24gYWxsIGVudGl0aWVzIGlu
IHRoZSB3b3JsZC4KKiBgZm5gOiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb24gZWFj
aCBlbnRpdHkgdGhhdCBtYXRjaGVzIHRoZSB0YWdzLiBUaGUgZnVuY3Rpb24gdGFrZXMgYSBzaW5n
bGUgcGFyYW1ldGVyLCB3aGljaCBpcyB0aGUgZW50aXR5IHRhYmxlLgoKIyMjIyBSZXR1cm5zCgoq
IGBzeXN0ZW1gOiBBIGZ1bmN0aW9uIHRoYXQgd2lsbCBpbnZva2UgYGZuYCBpbiBhbGwgdGhlIGVu
dGl0aWVzIHRoYXQgbWF0Y2ggdGhlIHNwZWNpZmllZCB0YWdzLgoKIyMjIyBFeGFtcGxlCgpgYGAg
bHVhCi0tIGRlZmluaXRpb24gKHVzdWFsbHkgaW4gX2luaXQpOgpncm93X29sZCA9IHdvcmxkLnN5
cygibGl2aW5nIiwgZnVuY3Rpb24oZSkKICBlLmFnZSA9IGUuYWdlICsgMQplbmQpCgotLSBpbnZv
Y2F0aW9uICh1c3VhbGx5IGluIF91cGRhdGUpOgpncm93X29sZCgpCmBgYAoKIyMjIyBOb3RlcwoK
SXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlbW92ZSBzeXN0ZW1zIGZyb20gdGhlIHdvcmxkIG9uY2Ug
dGhleSBoYXZlIGJlZW4gYWRkZWQuIElmIHlvdSBuZWVkIHRvIGRlYWN0aXZhdGUgYSBzeXN0ZW0s
IHVzZSBhbiBgaWZgIHRvIG5vdCBjYWxsIGl0OgoKYGBgIGx1YQppZiBzb21lX2NvbmRpdGlvbiB0
aGVuCiAgZ3Jvd19vbGQoKQplbmQKYGBgCgpJZiB5b3UgbmVlZCB0byBkbyBzb21lIHdvcmsgYmVm
b3JlIG9yIGFmdGVyIHRoZSBzeXN0ZW0gcnVucywgeW91IGNhbiB3cmFwIGl0IGluIGFub3RoZXIg
ZnVuY3Rpb246CgpgYGAgbHVhCi0tIGRlZmluaXRpb24KbG9jYWwgZ3Jvd19vbGRfc3lzID0gd29y
bGQuc3lzKCJsaXZpbmciLCBmdW5jdGlvbihlKQogIGUuYWdlID0gZS5hZ2UgKyAxCmVuZCkKCmxv
Y2FsIGdyb3dfb2xkID0gZnVuY3Rpb24oKQogIGluaXRpYWxpemVfc29tZV9hZ2VfcmVsYXRlZF90
aGluZ3MoKQogIGdyb3dfb2xkX3N5cygpCiAgZmluYWxpemVfc29tZV9hZ2VfcmVsYXRlZF90aGlu
Z3MoKQplbmQpCgotLSB1c2FnZToKZ3Jvd19vbGQoKSAtLSB3aWxsIGRvIGluaXRpYWxpemF0aW9u
IGFuZCBmaW5hbGl6YXRpb24KYGBgCgpUaGUgb3JkZXIgaW4gd2hpY2ggc3lzdGVtcyBwcm9jZXNz
IGVudGl0aWVzIGlzIHVuZGVmaW5lZC4gSWYgeW91IG5lZWQgdG8gcHJvY2VzcyBlbnRpdGllcyBp
biBhIHNwZWNpZmljIG9yZGVyLCB5b3UgaGF2ZSB0d28gb3B0aW9uczogY29sbGVjdCB0aGVtIGlu
IGEgc29ydGVkIGFycmF5IGFuZCB0aGVuIHByb2Nlc3MgdGhlbSBpbiBvcmRlciwgb3IgZG8gc2V2
ZXJhbCBzeXN0ZW1zIHRoYXQgcHJvY2VzcyB0aGUgZW50aXRpZXMgaW4gZ3JvdXBzLgoKSGVyZSdz
IGhvdyBpdCBsb29rcyBsaWtlIHRvIGNvbGxlY3QgZW50aXRpZXMgaW4gYSBzb3J0ZWQgYXJyYXkg
YW5kIHRoZW4gcHJvY2VzcyB0aGVtIGluIG9yZGVyOgoKYGBgIGx1YQotLSBkZWZpbml0aW9ucwoK
LS0gZ2l2ZW4gdHdvIGVudGl0aWVzLCBkZXRlcm1pbmUgd2hpY2ggb25lIGdvZXMgZmlyc3QgYnkg
bG9va2luZyBhdCB0aGVpciB5IGNvb3JkaW5hdGUKbG9jYWwgZHJhd19vcmRlciA9IGZ1bmN0aW9u
KGEsYikgcmV0dXJuIGEueSA8IGIueSBlbmQKbG9jYWwgZHJhd19idWY9e30KbG9jYWwgY29sbGVj
dF9kcmF3YWJsZXMgPSB3b3JsZC5zeXMoImRyYXdhYmxlIiwgZnVuY3Rpb24oZSkKICAtLSBpbnNl
cnQgdGhlIGVudGl0eSBvbiB0aGUgcmlnaHQgcGxhY2UgdXNpbmcgb2FkZC4KICAtLSBTZWUgaHR0
cHM6Ly93d3cubGV4YWxvZmZsZS5jb20vYmJzLz9waWQ9b2FkZGRlbW8tMAogIG9hZGQoZHJhd19i
dWYsIGUsIGRyYXdfb3JkZXIpCmVuZCkKCmxvY2FsIGRyYXdfZW50aXRpZXMgPSBmdW5jdGlvbigp
CiAgZHJhd19idWY9e30gLS0gaW50aWFsaXphdGlvbgogIGNvbGxlY3RfZHJhd2FibGVzKCkKICBm
b3IgaT0xLCNkcmF3X2J1ZiBkbwogICAgbG9jYWwgZSA9IGRyYXdfYnVmW2ldCiAgICAtLSBkcmF3
IGVudGl0eSBlCiAgICBzcHIoZS5zcHIsZS54LGUueSkKICBlbmQKZW5kCgotLSB1c2FnZSAoaW4g
X2RyYXcpOgpkcmF3X2VudGl0aWVzKCkKYGBgCgpBIHNpbXBsZXIsIHByb2JhYmx5IGZhc3RlciBi
dXQgbGVzcyBmbGV4aWJsZSB3YXkgaXMgdG8gaGF2ZSB0aGUgZW50aXRpZXMgdGFnZ2VkIGluIGEg
d2F5IHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gcHJvY2VzcyB0aGVtIGluIGdyb3Vwcy4gVGhl
IGZvbGxvd2luZyBleGFtcGxlIHdpbGwgZHJhdyBldmVyeXRoaW5nIHRoYXQgaXMgdGFnZ2VkICJi
YWNrZ3JvdW5kIiBmaXJzdCwgdGhlbiBldmVyeXRoaW5nIHRhZ2dlZCAibWlkZGxlZ3JvdW5kIiwg
YW5kIGZpbmFsbHkgZXZlcnl0aGluZyB0YWdnZWQgImZvcmVncm91bmQiOgoKYGBgIGx1YQotLS0g
ZGVmaW5pdGlvbnMKbG9jYWwgZnVuY3Rpb24gZHJhd19lbnRpdHkoZSkKICBzcHIoZS5zcHIsZS54
LGUueSkKZW5kCgpsb2NhbCBkcmF3X2JhY2tncm91bmQgPSB3b3JsZC5zeXMoImRyYXdhYmxlLGJh
Y2tncm91bmQiLCBkcmF3X2VudGl0eSkKbG9jYWwgZHJhd19taWRkbGVncm91bmQgPSB3b3JsZC5z
eXMoImRyYXdhYmxlLG1pZGRsZWdyb3VuZCIsIGRyYXdfZW50aXR5KQpsb2NhbCBkcmF3X2ZvcmVn
cm91bmQgPSB3b3JsZC5zeXMoImRyYXdhYmxlLGZvcmVncm91bmQiLCBkcmF3X2VudGl0eSkKCmxv
Y2FsIGRyYXdfYWxsID0gZnVuY3Rpb24oKQogIGRyYXdfYmFja2dyb3VuZCgpCiAgZHJhd19taWRk
bGVncm91bmQoKQogIGRyYXdfZm9yZWdyb3VuZCgpCmVuZAoKLS0gdXNhZ2UgKGluIF9kcmF3KToK
ZHJhd19hbGwoKQpgYGAKCiMjIyBSZW1vdmluZyBlbnRpdGllcyBmcm9tIHRoZSB3b3JsZAoKYGBg
IGx1YQp3b3JsZC5kZWwoZW50aXR5KQpgYGAKClJlbW92ZXMgdGhlIGdpdmVuIGVudGl0eSBmcm9t
IHRoZSB3b3JsZC4gSXQgd2lsbCBubyBsb25nZXIgYmUgcHJvY2Vzc2VkIGJ5IHN5c3RlbXMuCgoj
IyMjIFBhcmFtZXRlcnMKCiogYGVudGl0eWA6IHRoZSB0YWJsZSB0byBiZSByZW1vdmVkLiBJZiB0
aGUgZW50aXR5IGRvZXMgbm90IGV4aXN0IGluIHRoZSB3b3JsZCwgdGhlIGZ1bmN0aW9uIHdpbGwg
c2lsZW50bHkgZXhpdCwgZG9pbmcgbm90aGluZy4KCiMjIyMgRXhhbXBsZQoKYGBgIGx1YQp3b3Js
ZC5kZWwoa2lsbGVkX2VuZW15KQpgYGAKCiMjIyMgTm90ZXMKClRoZSBtb3N0IHVzdWFsIHBsYWNl
IHdoZW4gb25lIHdpbGwgd2FudCB0byByZW1vdmUgYW4gZW50aXR5IGlzIGZyb20gaW5zaWRlIGEg
c3lzdGVtLiBUaGlzIGlzIGlzIG9rOgoKYGBgIGx1YQotLSBEZWZpbml0aW9ucwpncm93X29sZGVy
ID0gd29ybGQuc3lzKCJsaXZpbmciLCBmdW5jdGlvbihlKQogIGUuYWdlID0gZS5hZ2UgKyAxCmVu
ZCkKCnJlbW92ZV9vbGQgPSB3b3JsZC5zeXMoImxpdmluZyIsIGZ1bmN0aW9uKGUpCiAgaWYgZS5h
Z2UgPiAxMDAgdGhlbgogICAgd29ybGQuZGVsKGUpCiAgZW5kCmVuZCkKCi0tIHVzYWdlCmdyb3df
b2xkZXIoKQpyZW1vdmVfb2xkKCkKYGBgCgpSZW1vdmluZyBlbnRpdGllcyBmcm9tIHRoZSB3b3Js
ZCBpcyBkb25lIGluIGEgc2FmZSBhbmQgZWZmaWNpZW50IHdheSwgYnV0IGl0IGludm9sdmVzIGNo
YW5naW5nIHRoZSBvcmRlciBpbiB3aGljaCBlbnRpdGllcyBhcmUgcHJvY2Vzc2VkIGJ5IHN5c3Rl
bXMgKGV2ZXJ5IHRpbWUgYW4gZW50aXR5IGlzIHJlbW92ZWQsIHRoZSBsaXN0cyB3aWxsIGJlIHNs
aWdodGx5IHNodWZmbGVkKS4gVGhpcyBpcyB3aHkgdGhlcmUncyBubyBndWFyYW50ZWVzIGFib3V0
IG9yZGVyIG9mIHByb2Nlc3NpbmcgaW4gc3lzdGVtcy4KCiMjIyBBZGRpbmcgYWRkaXRpb25hbCB0
YWdzIHRvIGFuIGVudGl0eQoKYGBgIGx1YQp3b3JsZC50YWcoZW50aXR5LCB0YWdzKQpgYGAKCkFk
ZHMgbmV3IHRhZ3MgdG8gYW4gZW50aXR5LgoKIyMjIyBQYXJhbWV0ZXJzCgoqIGBlbnRpdHlgOiB0
aGUgZW50aXR5IGJlaW5nIGdpdmVuIG5ldyB0YWdzLgoqIGB0YWdzYDogYSBzdHJpbmcgd2l0aCBv
bmUgb3IgbW9yZSBjb21tYS1zZXBhcmF0ZWQgdGFncyB0byBiZSBhZGRlZCB0byB0aGUgZW50aXR5
LgoKIyMjIyBSZXR1cm5zCgpOb3RoaW5nCgojIyMjIEV4YW1wbGUKCmBgYCBsdWEKd29ybGQudGFn
KHBsYXllciwgImludmluY2libGUiKQpgYGAKCiMjIyMgTm90ZXMKCklmIGFuIGVudGl0eSBhbHJl
YWR5IGhhcyBhIHRhZyB0aGF0IGlzIGJlaW5nIGFkZGVkLCBpdCB3aWxsIGJlIGlnbm9yZWQgKHRo
ZXJlIHdpbGwgYmUgbm8gZHVwbGljYXRlIHRhZ3MpLiBIb3dldmVyLCBjYWxsaW5nIHdvcmxkLnRh
ZyBpcyBleHBlbnNpdmUgc2luY2UgYXQgdGhlIHZlcnkgbGVhc3QgaXQgaW52b2x2ZXMgc3BsaXR0
aW5nIHRoZSBgdGFnc2Agc3RyaW5nIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncywgYW5kIHRoZW4g
cGFyc2luZyB0aGVtLCBwb3RlbnRpYWxseSBjcmVhdGluZyBhIG5ldyBpbnRlcm5hbCBjb2xsZWN0
aW9uIG9mIGVudGl0aWVzIHRvIHdoaWNoIHRoZSBlbnRpdHkgbmVlZHMgdG8gYmUgbW92ZWQgdG8u
CgpZb3UgY2FuIHVzZSB0aGUgYHdvcmxkLm1za2AgbWV0aG9kIHRvIGNoZWNrIGlmIGFuIGVudGl0
eSBhbHJlYWR5IGhhcyBhIHRhZyBiZWZvcmUgY2FsbGluZyBgd29ybGQudGFnc2AgKHNlZSB0aGUg
bm90ZXMgc2VjdGlvbiBpbiBgd29ybGQubXNrYCBiZWxvdykuCgpHaXZlbiB0aGF0IGB3b3JsZC50
YWdgIGlzIGV4cGVuc2l2ZSwgeW91IHNob3VsZCBhdm9pZCB1c2luZyBpdCBvbiBzeXN0ZW1zIHRo
YXQgd2lsbCBwYXJzZSBhIGJpZyBudW1iZXIgb2YgZW50aXRpZXMuCgpFeGFtcGxlIG9mIGJhZCB1
c2FnZToKCmBgYCBsdWEKbG9jYWwgcmV0YWdfYWxsX2VudGl0aWVzID0gd29ybGQuc3lzKCIiLCBm
dW5jdGlvbihlKQogIGlmIHNvbWVfY29uZGl0aW9uIHRoZW4KICAgIHdvcmxkLnRhZyhlLCAic29t
ZV9uZXdfdGFnIikKICBlbHNlCiAgICB3b3JsZC50YWcoZSwgInNvbWVfb3RoZXJfbmV3X3RhZyIp
CiAgZW5kCmVuZCkKYGBgCgpUaGlzIGlzIGEgc3lzdGVtIHRoYXQgd2lsbCBwYXJzZSBhbGwgZW50
aXRpZXMgYW5kIHdpbGwgKmFsd2F5cyogY2hhbmdlIHRoZWlyIHRhZ3MgKGJvdGggc2lkZXMgb2Yg
dGhlIGBpZmAgY2FsbCBgd29ybGQudGFnYC4gSXQgd2lsbCBiZSB2ZXJ5IHNsb3cgYW5kIGluZWZm
aWNpZW50LgoKRXhhbXBsZSBvZiBhIGdvb2QgdXNhZ2U6CgpgYGAgbHVhCmxvY2FsIGtpbGxfY2xv
c2VfZW5lbWllcyA9IHdvcmxkLnN5cygiZW5lbXksY2xvc2UiLCBmdW5jdGlvbihlbmVteSkKICBp
ZiBlbmVteS5ocCA8PSAwIHRoZW4KICAgIHdvcmxkLnRhZyhlbmVteSwgImRlYWQiKQogIGVuZApl
bmQpCmBgYAoKVGhpcyBpcyBiZXR0ZXIgYmVjYXVzZSBpdCB3aWxsIG9ubHkgcGFyc2Ugb3ZlciBl
bnRpdGllcyB0aGF0IGFyZSB0YWdnZWQgYm90aCAiZW5lbXkiIGFuZCAiY2xvc2UiLCB3aGljaCBz
aG91bGQgYmUgYSBzbWFsbGVyIHNldCB0aGFuIGFsbCBlbnRpdGllcy4gQWxzbywgaXQgd2lsbCBv
bmx5IGNhbGwgYHdvcmxkLnRhZ2Agb24gc29tZSBvZiB0aGVtICh0aG9zZSB0aGF0IGFyZSBjbG9z
ZSBhbmQgaGF2ZSBubyBocCBsZWZ0KS4KClRoaXMgY2FuIGJlIGZ1cnRoZXIgb3B0aW1pemVkIGJ5
IHVzaW5nICBgd29ybGQubXNrYCB0byBjaGVjayBpZiBhbiBlbnRpdHkgaGFzIGEgdGFnIGJlZm9y
ZSBjYWxsaW5nIGB3b3JsZC50YWdgIChzZWUgdGhlIG5vdGVzIHNlY3Rpb24gaW4gYHdvcmxkLm1z
a2AgYmVsb3cpCgpgYGAgbHVhCmxvY2FsIGtpbGxfY2xvc2VfZW5lbWllcyA9IHdvcmxkLnN5cygi
ZW5lbXksY2xvc2UiLCBmdW5jdGlvbihlbmVteSkKICBpZiBlbmVteS5ocCA8PSAwIHRoZW4KICAg
IGxvY2FsIG1zayA9IHdvcmxkLm1zayhlbmVteSkKICAgIGlmIG5vdCBtc2suZGVhZCB0aGVuCiAg
ICAgIHdvcmxkLnRhZyhlbmVteSwgImRlYWQiKQogICAgZW5kCiAgZW5kCmVuZCkKYGBgCgojIyMg
UmVtb3ZpbmcgdGFncyBmcm9tIGFuIGVudGl0eQoKYGBgIGx1YQp3b3JsZC51bnQoZW50aXR5LCB0
YWdzKQpgYGAKClRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIGB3b3JsZC50YWdgIC0gaXQgcmVtb3Zl
cyB0YWdzIGZyb20gYW4gZW50aXR5CgojIyMjIFBhcmFtZXRlcnMKCiogYGVudGl0eWA6IFRoZSBl
bnRpdHkgZnJvbSB3aGljaCB0YWdzIHdpbGwgYmUgcmVtb3ZlZC4KKiBgdGFnc2A6IEEgc3RyaW5n
IHdpdGggb25lIG9yIG1vcmUgY29tbWEtc2VwYXJhdGVkIHRhZ3MgdG8gYmUgcmVtb3ZlZCBmcm9t
IHRoZSBlbnRpdHkuCgojIyMjIFJldHVybnMKCk5vdGhpbmcKCiMjIyMgRXhhbXBsZQoKYGBgIGx1
YQp3b3JsZC51bnQocGxheWVyLCAiaW52aW5jaWJsZSIpCmBgYAoKIyMjIyBOb3RlcwoKQXR0ZW1w
dGluZyB0byByZW1vdmUgYSB0YWcgdGhhdCB0aGUgZW50aXR5IGRvZXMgbm90IGhhdmUgd2lsbCBi
ZSBpZ25vcmVkIChubyBlcnJvciB3aWxsIGJlIHRocm93bikuIEhvd2V2ZXIsIHNpbWlsYXJseSB0
byBgd29ybGQudGFnYCwgY2FsbGluZyBgd29ybGQudW50YCBpcyBleHBlbnNpdmUgYW5kIHNob3Vs
ZCBiZSBhdm9pZGVkIGlmIHBvc3NpYmxlLiBUaGUgc2FtZSBwcmVjYXV0aW9ucyB0aGF0IGFwcGx5
IHRvIGB3b3JsZC50YWdgIGFwcGx5IGFsc28gdG8gYHdvcmxkLnVudGA6CiogVHJ5IHRvIG1vZGlm
eSBmZXcgZW50aXRpZXMgYXQgYSB0aW1lIGJ5IHVzaW5nIGl0IG9uIHN5c3RlbXMgdGhhdCBmaWx0
ZXIgZW50aXRpZXMgYnkgdGFncyBhbmQgdGVuIG9ubHkgcmVtb3ZlIHRhZ3MgZnJvbSBzb21lIG9m
IHRoZW0KKiBVc2UgYHdvcmxkLm1za2AgdG8gY2hlY2sgaWYgYW4gZW50aXR5IGhhcyBhIHRhZyBi
ZWZvcmUgYXR0ZW1wdGluZyB0byByZW1vdmUgaXQuCgpgYGAgbHVhCmxvY2FsIHJlYW5pbWF0ZV9j
bG9zZV9kZWFkX2VuZW1pZXMgPSB3b3JsZC5zeXMoImVuZW15LGNsb3NlLGRlYWQiLCBmdW5jdGlv
bihlbmVteSkKICBsb2NhbCBtc2sgPSB3b3JsZC5tc2soZW5lbXkpCiAgaWYgbm90IG1zay51bmRl
YWQgdGhlbgogICAgd29ybGQudW50KGVuZW15LCAidW5kZWFkIikKICBlbmQKZW5kKQpgYGAKCiMj
IyBHZXQgYWxsIHRoZSB0YWdzIG9mIGFuIGVudGl0eQoKYGBgIGx1YQpsb2NhbCBtc2sgPSB3b3Js
ZC5tc2soZW50aXR5KQpgYGAKClJldHVybnMgYSB0YWJsZSB3aXRoIGFsbCB0aGUgdGFncyBvZiBh
biBlbnRpdHkgYXMga2V5cy4KCiMjIyMgUGFyYW1ldGVycwoKKiBgZW50aXR5YDogVGhlIGVudGl0
eSB3aG9zZSB0YWdzIHdpbGwgYmUgcmV0dXJuZWQuCgojIyMjIFJldHVybnMKCiogYG1za2A6IEEg
dGFibGUgd2l0aCB0aGUgdGFncyBvZiB0aGUgZW50aXR5IGFzIGtleXMsIGFuZCBgdHJ1ZWAgYXMg
dmFsdWUuCgojIyMjIEV4YW1wbGUKCmBgYCBsdWEKbG9jYWwgbXNrID0gd29ybGQubXNrKHBsYXll
cikKYGBgCgojIyMjIE5vdGVzCgoqKiBEbyBub3QgbW9kaWZ5IHRoZSByZXR1cm5lZCB0YWJsZSEg
KiouIEZvciBlZmZpY2llbmN5IHJlYXNvbnMsIGBtc2tgIGlzIGEgdGFibGUgdGhhdCBpcyB1c2Vk
IGZvciBpbnRlcm5hbCBjYWxjdWxhdGlvbnMgaW5zaWRlIHRoZSBsaWJyYXJ5LiBJZiB5b3UgbmVl
ZCB0byBtb2RpZnkgaXQsIHBsZWFzZSBtYWtlIGEgY29weSBiZWZvcmUgYW5kIG1vZGlmeSB0aGF0
IGluc3RlYWQuCgpJbiBnZW5lcmFsIHlvdSBzaG91bGQgbm90IG5lZWQgdG8gdXNlIGB3b3JsZC5t
c2tgIGV4Y2VwdCBmb3IgdGhlIGNhc2Ugd2hlcmUgY2hlY2tpbmcgdGhhdCB0aGUgZW50aXR5IGFs
cmVhZHkgaGFzIChvciBkb2VzIG5vdCBoYXZlKSBhIHRhZyBiZWZvcmUgY2FsbGluZyBgd29ybGQu
dGFnYCBvciBgd29ybGQudW50YCwgYXMgZXhwbGFpbmVkIGluIHRoZSBub3RlcyBzZWN0aW9ucyBv
ZiB0aG9zZSBtZXRob2RzLiBJbiBhbnkgb3RoZXIgY2FzZSwgaWYgeW91IG5lZWQgdG8gZG8gc29t
ZXRoaW5nIGxpa2UgdGhpczoKCmBgYCBsdWEKbG9jYWwgbXNrID0gd29ybGQubXNrKHBsYXllcikK
aWYgbXNrLmludmluY2libGUgdGhlbgogIC4uIGRvIHNvbWV0aGluZyBzcGVjaWFsCmVuZApgYGAK
ClRoYXQgaXMgcHJvYmFibHkgYSBzeXN0ZW0gaGlkaW5nIGluc2lkZSB5b3VyIGNvZGUuIFRoZXJl
IGlzIHByb2JhYmx5IGEgd2F5IHRvIHJld3JpdGUgaXQgbGlrZSB0aGlzOgoKYGBgIGx1YQpsb2Nh
bCBpbnZpbmNpYmxlX3N5c3RlbSA9IHdvcmxkLnN5cygiaW52aW5jaWJsZSIsIGZ1bmN0aW9uKGUp
CiAgLi4gZG8gc29tZXRoaW5nIHdpdGggZSwgd2hpY2ggbm93IGNhbiBiZSBhbnkgZW50aXR5IHRh
Z2dlZCBpbnZpbmNpYmxlLCBub3QganVzdCBgcGxheWVyYAplbmQpCmBgYAoKIyMgUHJlZW10aXZl
IEZBUQoKPiBIb3cgbWFueSB0b2tlbnMgZG9lcyBlZ2dzIHVzZT8KClRoZSBsaWJyYXJ5IHdlaWdo
dHMgYXJvdW5kIDU2OSB0b2tlbnMuIEl0IGhhcyBubyBjb21tZW50cyBhbmQgdmVyeSBmZXcgYmxh
bmsgbGluZXMsIGJ1dCBpdCBjb3VsZCBiZSBtaW5pbWl6ZWQuIElmIHlvdSBhcmUgYWxyZWFkeSB1
c2luZyBgb2FkZGAgaW4geW91ciBwcm9qZWN0IHlvdSBjb3VsZCBhbHNvIHJlbW92ZSB0aGUgaW50
ZXJuYWwgYG9hZGRgIGltcGxlbWVudGF0aW9uIGFuZCByZXBsYWNlIGl0IG9uIHRoZSBgbWtpZGAg
ZnVuY3Rpb24gaW4gb3JkZXIgdG8gc2F2ZSBzb21lIHRva2Vucy4KCj4gSG93IGRvZXMgaXQgd29y
az8KCkludGVybmFsbHksIHRoZSBsaWJyYXJ5IGdyb3VwcyBlbnRpdGllcyBpbnRvICJjb2xsZWN0
aW9ucyIgKGFsc28ga25vd24gYXMgImFyY2hldHlwZXMiKSBhY2NvcmRpbmcgdG8gdGhlaXIgdGFn
cy4gVGhlcmUgaXMgYWxzbyBhIGNvbGxlY3Rpb24gb2YgImZpbHRlcnMiLCBlYWNoIG9mIHdoaWNo
IGhhcyBhICJjb2xsZWN0aW9uIG9mIGNvbGxlY3Rpb25zIiwgdGhhdCBpdCBrbm93cyBpdCBuZWVk
cyB0byBwYXJzZSBldmVyeSB0aW1lIHRoZWlyIHN5c3RlbSBpcyBpbnZva2VkLgoKQ29sbGVjdGlv
bnMgYW5kIGZpbHRlcnMgYXJlIGluZGV4ZWQgYnkgdGhlaXIgImlkZW50aWZpZXIiLCB3aGljaCBp
cyB0aGUgc2V0IG9mIHRhZ3MgdGhhdCBkZWZpbmUgdGhlbSwgc29ydGVkIGFscGhhYmV0aWNhbGx5
LiBUd28gc3lzdGVtcyB1c2luZyB0aGUgc2FtZSBzZXQgb2YgdGFncyB3aWxsIHNoYXJlIHRoZSBz
YW1lIGZpbHRlci4gVHdvIGVudGl0aWVzIHdpdGggdGhlIHNhbWUgc2V0IG9mIHRhZ3Mgd2lsbCB1
c2UgdGhlIHNhbWUgY29sbGVjdGlvbi4KCkVhY2ggdGltZSBhIG5ldyBhcmNoZXR5cGUgaXMgYWRk
ZWQsIGl0IGNoZWNrcyBhbGwgb2YgdGhlIGV4aXN0aW5nIGZpbHRlcnMgYW5kIGFkZHMgaGltc2Vs
ZiB0byB0aGVpciAiY29sbGVjdGlvbiBvZiBjb2xsZWN0aW9ucyIgaWYgdGhlIHRhZ3MgbWF0Y2gu
IFNpbWlsYXJseSwgd2hlbiBhIHN5c3RlbSBpcyBhZGRlZCwgaXRzIGZpbHRlciB3aWxsIGNoZWNr
IGFsbCBvZiB0aGUgZXhpc3RpbmcgYXJjaGV0eXBlcyBhbmQgYWRkIHRvIGl0cyAiY29sbGVjdGlv
biBvZiBjb2xsZWN0aW9ucyIgdGhvc2UgdGhhdCBtYXRjaC4KCkVhY2ggdGltZSBhbiBlbnRpdHkn
cyB0YWdzIGFyZSBtb2RpZmllZCwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gaXRzIGN1cnJlbnQg
Y29sbGVjdGlvbiBhbmQgYWRkZWQgdG8gdGhlIGFwcHJvcHJpYXRlIG9uZSAod2hpY2ggaXMgY3Jl
YXRlZCBvbiB0aGUgc3BvdCBpZiBpdCBkb2Vzbid0IGV4aXN0KS4KCj4gV2h5IG5vdCB1c2UgYmlu
YXJ5IG1hc2tzIGZvciB0YWdzIGluc3RlYWQgb2Ygc3RyaW5ncz8KClRoYXQgd2FzIG15IGZpcnN0
IGlkZWEuIFRhZ3MgdXNlZCB0byBsb29rIGxpa2UgdGhpczoKCmBgYCBsdWEKbG9jYWwgcG9zLHZl
bCxzcHI9MSwxPDwxLDE8PDIKCi4uLgoKbW92ZSA9IHdvcmxkLnN5c3RlbShwb3N8dmVsLCBmdW5j
dGlvbihlKQogIC4uLgplbmQpCmBgYAoKQnV0IHVuZm9ydHVuYXRlbHkgUElDTy04IGhhcyBbYSAz
MiBiaXQgbnVtYmVyIGZvcm1hdF0oaHR0cHM6Ly9waWNvLTguZmFuZG9tLmNvbS93aWtpL01hdGgp
LiBTbyBpZiBJIHdlbnQgdGhhdCByb3V0ZSBteSBsaWJyYXJ5IHdvdWxkIGJlIGxpbWl0ZWQgdG8g
MzIgdGFncyBhdCBtYXhpbXVtLiBPbiBteSB0ZXN0X2VnZ3MgZXhhbXBsZSwgd2hpY2ggaXMgdmVy
eSBzaW1wbGUsIEkgYWxyZWFkeSB1c2VkIDEwLiBJIHJlYWxpemVkIHZlcnkgcXVpY2tseSB0aGF0
IGFueSB2aWRlb2dhbWUgdGhhdCB3YXMgZXZlbiBvbmx5IHNsaWdodGx5IGNvbXBsZXggd291bGQg
bmVlZCBtb3JlIHRoYW4gMzIuIFNvIHRoZSBhZHZhbnRhZ2VzIG9mIHVzaW5nIGJpbmFyeSBzdGFy
dGVkIGJlaW5nIGxlc3MgaW50ZXJlc3RpbmcgLSBJIHdvdWxkIGhhdmUgdG8gaW1wbGVtZW50ICJi
aXRtYXNrIiBvYmplY3RzLCBncm91cGluZyBzZXZlcmFsIG51bWJlcnMgdG9nZXRoZXIsIGFuZCB1
c2luZyB0YWJsZXMgd2l0aCBtZXRhdGFibGVzIGZvciB0aGUgYml0d2lzZSBvcGVyYXRpb25zIGFu
ZCAuLi4gd2VsbCBJIHN0b3BwZWQgdGhlcmUuCgpQSUNPLTggYWxyZWFkeSBoYXMgYSBidWlsdC1p
biBgc3BsaXRgIGZ1bmN0aW9uLCBzbyBzdHJpbmdzIGFyZSBtb3JlIGVjb25vbWljYWwgaW4gdGVy
bXMgb2YgdG9rZW5zLiBUaGUgcHJpY2UgaXMgcGVyZm9ybWFuY2UuIFN0cmluZ3MgbmVlZCB0byBi
ZSBzcGxpdCBhbmQgc29ydGVkIGluIG9yZGVyIHRvIGJlIHVzZWQgYXMgaWRzOyBoZW5jZSBhbGwg
b2YgdGhlIHdhcm5pbmdzIGFib3V0IG5vdCB1c2luZyBgd29ybGQudGFnYCBhbmQgYHdvcmxkLnVu
dGAgaW4gZXhjZXNzLgoKVGFncyBoYXZlIGFuIGFkdmFudGUgb3ZlciBiaXRtYXNrcywgaW4gdGhh
dCB0aGV5IGFyZSBtdWNoIG1vcmUgaHVtYW4tcmVhZGFibGUuIGBlZ2dzYCdzIGludGVybmFsIGNv
bGxlY3Rpb25zIGFyZSBpbmRleGVkIGJ5IHRoaW5ncyBsaWtlIGAiYWdlLGhlYWx0aCxwb3MiYCBp
bnN0ZWFkIG9mIGAweDAwMDdgLCB3aGljaCBtYWtlcyBkZWJ1Z2dpbmcgZWFzaWVyLgoKT24gUGlj
b3Ryb24sIHRoZXJlJ3MgdGhpcyBmZWF0dXJlIGNhbGxlZCBbdXNlcmRhdGFdKGh0dHBzOi8vd3d3
LmxleGFsb2ZmbGUuY29tL2RsL2RvY3MvcGljb3Ryb25fdXNlcmRhdGEuaHRtbCkgdGhhdCBjb3Vs
ZCBiZSB1c2VkIHRvIGltcGxlbWVudCBiaXRtYXNrcyBpbiBhIGJldHRlciB3YXksIGJ1dCB0aGF0
IGlzIG5vdCBhdmFpbGFibGUgaW4gUElDTy04LgoKPiBXaHkgaXMgaXQgY2FsbGVkIGVnZ3M-IFNo
b3VsZG4ndCBpdCBiZSBFVFMgKEVudGl0eSBUYWcgU3lzdGVtKT8KCkJlY2F1c2UgSSBmaW5kIHRo
ZSBuYW1lICJlZ2dzIiBmdW5ueS4gSXQgc291bmRzIHNpbWlsYXIgdG8gdHJ5aW5nIHRvIHByb25v
dW5jZSAiRUNTIiBhcyBpZiBpdCB3YXMgYSB3b3JkLiBJIGNvbnNpZGVyZWQgY2FsbGluZyBpdCAi
RmlsdGVycywgQWN0b3JzIGFuZCBUYWdzIiwgYnV0IHRoYXQgZGlkbid0IGdvIHdlbGwgd2l0aCB0
aGUgY3V0ZW5lc3Mgb2YgUElDTy04LgoKQXQgbGVhc3QgSSBkaWRuJ3QgY2FsbCB0YWdzICJnZ29t
cG9uZW50cyIu
:: lib/eggs.p8/test_eggs.lua
b64$LS0gd29ybGQKbG9jYWwgd29ybGQKCi0tZW50aXR5IGNvbnN0cnVjdG9ycwpsb2NhbCBjaGlj
aywgYmVhc3QKCi0tc3lzdGVtcwpsb2NhbCB0aWNrLCBncm93LCBzY2FuLCB3YW5kZXIsIGZsZWUs
IG1vdmUsIGh1bnQsIGxheSwgdmFuaXNoLCBjZW5zdXMsIGRyYXcKCi0tYXV4IHZhcnMgJiBmdW5j
dGlvbnMKbG9jYWwgc3RhdHMsIGNwdSwgcG9wLCBtYXhwb3AKbG9jYWwgdGhlYmVhc3QKbG9jYWwg
cGhhc2VzID0geyAtLSBob3cgbWFueSBzZWNvbmRzOgogIDUsICAtLSBlZ2csCiAgNywgIC0tIGNo
aWxkLAogIDYsICAtLSB0ZWVuLAogIDEyLCAtLSBhZHVsdCwKICAxLCAgLS0gY29ycHNlCn0KCmxv
Y2FsIHBoYXNlYWdlcyA9IHt9CmxvY2FsIG1heGFnZSA9IDAKbG9jYWwgY29ycHNlYWdlID0gMApm
b3IgaSA9IDEsICNwaGFzZXMgZG8KICBmb3IgXyA9IDEsIHBoYXNlc1tpXSAqIDMwIGRvCiAgICBh
ZGQocGhhc2VhZ2VzLCBpKQogIGVuZAogIGlmIGkgPT0gNSB0aGVuCiAgICBjb3Jwc2VhZ2UgPSBt
YXhhZ2UgKyAxCiAgZW5kCiAgbWF4YWdlICs9IHBoYXNlc1tpXSAqIDMwCmVuZAoKbG9jYWwgZnVu
Y3Rpb24ga2lsbChlKQogIGUucyA9IGUucyArIDE2CiAgZS5hZ2UgPSBjb3Jwc2VhZ2UKICB3b3Js
ZC51bnQoZSwiYWxpdmUsdmVsLGxheWluZyxwcmV5IikKICB3b3JsZC50YWcoZSwiZGVhZCIpCmVu
ZAoKZnVuY3Rpb24gX2luaXQoKQogIHdvcmxkID0gZWdncygpCiAgc3RhdHMgPSB0cnVlCiAgY3B1
ID0gMAogIHBvcCA9IDAKICBtYXhwb3AgPSAwCgogIGNoaWNrID0gZnVuY3Rpb24oZywgeCwgeSkK
ICAgIGlmIGNwdT49Ljk1IHRoZW4gcmV0dXJuIGVuZAogICAgZyA9IGcgb3Igcm5kKHsgIm0iLCAi
ZiIgfSkKICAgIGxvY2FsIGFnZSA9IGFnZSBvciAxK2ZscihybmQoMTIwKSkKICAgIGxvY2FsIHAg
PSBwaGFzZWFnZXNbYWdlXQogICAgbG9jYWwgcyA9IHAgKyAoZyA9PSAibSIgYW5kIDQgb3IgMCkK
ICAgIHJldHVybiB3b3JsZC5lbnQoInBvcyxzcHJpdGUsYWdlLHBoYXNlLGdlbnJlLGFsaXZlIiwg
ewogICAgICBnID0gZywKICAgICAgeCA9IHggb3Igcm5kKDEyMCksCiAgICAgIHkgPSB5IG9yIHJu
ZCgxMjApLAogICAgICB2eCA9IDAsCiAgICAgIHZ5ID0gMCwKICAgICAgYWdlID0gYWdlLAogICAg
ICBwID0gcCwKICAgICAgcyA9IHMsCiAgICB9KQogIGVuZAoKICBiZWFzdCA9IGZ1bmN0aW9uKCkK
ICAgIHJldHVybiB3b3JsZC5lbnQoInBvcyx2ZWwsc3ByaXRlIiwgewogICAgICB4ID0gcm5kKDEy
MCksCiAgICAgIHkgPSBybmQoMTIwKSwKICAgICAgdnggPSAwLjUgKyBybmQoMC41KSwKICAgICAg
dnkgPSAwLjUgKyBybmQoMC41KSwKICAgICAgcyA9IDI1NSwKICAgIH0pCiAgZW5kCgogIHRpY2sg
PSB3b3JsZC5zeXMoImFnZSIsIGZ1bmN0aW9uKGUpCiAgICBlLmFnZSArPSAxCiAgZW5kKQoKICAt
LSBjaGFuZ2UgcGhhc2UgYWNjb3JkaW5nIHRvIGFnZSwgYWRkL3JlbW92ZSB0YWdzIGluIHNvbWUg
cGhhc2UgY2hhbmdlcwogIGdyb3cgPSB3b3JsZC5zeXMoImFnZSxhbGl2ZSxwaGFzZSxnZW5yZSxz
cHJpdGUiLCBmdW5jdGlvbihlKQogICAgbG9jYWwgbnAgPSBhc3NlcnQocGhhc2VhZ2VzW2UuYWdl
XSwgZS5hZ2UpCiAgICBpZiBucCA9PSBlLnAgdGhlbiByZXR1cm4gZW5kCiAgICBlLnAgPSBucAog
ICAgaWYgbnA9PTUgdGhlbgogICAgICBraWxsKGUpCiAgICBlbHNlCiAgICAgIGUucyA9IG5wICsg
KGUuZyA9PSAibSIgYW5kIDQgb3IgMCkKICAgICAgaWYgbnA9PTIgdGhlbiAtLSBjaGlsZCAtIHN0
YXJ0IG1vdmluZwogICAgICAgIHdvcmxkLnRhZyhlLCJ2ZWwiKQogICAgICBlbHNlaWYgbnA9PTQg
YW5kIGUuZz09ImYiIHRoZW4gLS0gZmVtYWxlIGFkdWx0IC0gc3RhcnQgbGF5aW5nIGVnZ3MKICAg
ICAgICB3b3JsZC50YWcoZSwibGF5aW5nIikKICAgICAgZW5kCiAgICBlbmQKICBlbmQpCgogIC0t
IGFueSBjaGlja2VucyB0aGF0IGFyZSBhbGl2ZSBhbmQgY2xvc2UgdG8gdGhlIGJlYXN0IGFyZSBt
YXJrZWQgYXMgcHJleQogIHNjYW4gPSB3b3JsZC5zeXMoImFsaXZlLHBvcyIsIGZ1bmN0aW9uKGUp
CiAgICBsb2NhbCB4MCx5MD10aGViZWFzdC54KzQsdGhlYmVhc3QueSs0CiAgICBsb2NhbCB4MSx5
MT1lLngrNCxlLnkrNAogICAgbG9jYWwgZHgsZHk9eDAteDEseTAteTEKICAgIC0tIGNhbGxpbmcg
dGFnIGFuZCB1bnQgaXMgZXhwZW5zaXZlLCB0aGUgbXNrIHZhcmlhYmxlIGFsbG93cyBza2lwcGlu
ZyBpdCB3aGVuIG5vdCBuZWNlc3NhcnkKICAgIGxvY2FsIG1zaz13b3JsZC5tc2soZSkKICAgIGlm
IGR4KmR4K2R5KmR5PDI1NiB0aGVuCiAgICAgIGlmIG5vdCBtc2sucHJleSB0aGVuCiAgICAgICB3
b3JsZC50YWcoZSwicHJleSIpCiAgICAgIGVuZAogICAgZWxzZWlmIG1zay5wcmV5IHRoZW4KICAg
ICAgd29ybGQudW50KGUsInByZXkiKQogICAgZW5kCiAgZW5kKQoKICBsb2NhbCBhZGhkID0geyAt
LSB2ZWxvY2l0eSB2YXJpYW5jZSBwZXIgcGhhc2UKICAgIDAsICAgLS0gZWdnLAogICAgMC4xLCAt
LSBjaGlsZCwKICAgIDAuNCwgLS0gdGVlbiwKICAgIDAuMiwgLS0gYWR1bHQsCiAgICAwLCAgIC0t
IGNvcnBzZQogIH0KICAtLSBtb3ZlIGFyb3VuZCByYW5kb21seQogIHdhbmRlciA9IHdvcmxkLnN5
cygidmVsLGdlbnJlLHBoYXNlIiwgZnVuY3Rpb24oZSkKICAgIGxvY2FsIHYgPSBhZGhkW2UucF0g
KyAoZS5nID09ICJtIiBhbmQgMSBvciAwKSAtLSBtYWxlcyBhcmUgbW9yZSBoeXBlcmFjdGl2ZQog
ICAgZS52eCA9IGUudngrcm5kKDIqdiktdgogICAgZS52eSA9IGUudnkrcm5kKDIqdiktdgogIGVu
ZCkKCiAgLS0gZmxlZSBmcm9tIHRoZSBiZWFzdCB3aGVuIGl0IGlzIHByZXlieQogIGZsZWUgPSB3
b3JsZC5zeXMoInByZXkscG9zLHZlbCIsIGZ1bmN0aW9uKGUpCiAgICBsb2NhbCB4MCx5MD10aGVi
ZWFzdC54KzQsdGhlYmVhc3QueSs0CiAgICBsb2NhbCB4MSx5MT1lLngrNCxlLnkrNAogICAgbG9j
YWwgZHgsZHk9eDAteDEseTAteTEKICAgIGUudng9YWJzKGUudngpKihkeD4wIGFuZCAtMS41IG9y
IDEuNSkKICAgIGUudnk9YWJzKGUudnkpKihkeT4wIGFuZCAtMS41IG9yIDEuNSkKICBlbmQpCgog
IC0tIHVwZGF0ZSBwb3NpdGlvbiBhY2NvcmRpbmcgdG8gdmVsb2NpdHksIGJvdW5jaW5nIG9uIHdh
bGxzIGFuZCBsaW1pdGluZyBtYXggc3BlZWQKICBtb3ZlID0gd29ybGQuc3lzKCJwb3MsdmVsIiwg
ZnVuY3Rpb24oZSkKICAgIGxvY2FsIHgsIHZ4ID0gZS54LCBlLnZ4CiAgICB2eCA9IHggPCAwIGFu
ZCBhYnModngpIG9yIHggPiAxMjAgYW5kIC1hYnModngpIG9yIHZ4CiAgICBlLnZ4ID0gbWlkKC0y
LHZ4LDIpCiAgICBlLnggPSB4ICsgZS52eAoKICAgIGxvY2FsIHksIHZ5ID0gZS55LCBlLnZ5CiAg
ICB2eSA9IHkgPCAwIGFuZCBhYnModnkpIG9yIHkgPiAxMjAgYW5kIC1hYnModnkpIG9yIHZ5CiAg
ICBlLnZ5ID0gbWlkKC0yLHZ5LDIpCiAgICBlLnkgPSB5ICsgZS52eQogIGVuZCkKCiAgLS0ga2ls
bCBwcmV5IGJ5IGNvbGxpZGluZyB3aXRoIHRoZW0KICBodW50ID0gd29ybGQuc3lzKCJwcmV5LHBv
cyIsIGZ1bmN0aW9uKGUpCiAgICBsb2NhbCB4MCx5MD10aGViZWFzdC54KzQsdGhlYmVhc3QueSs0
CiAgICBsb2NhbCB4MSx5MT1lLngrNCxlLnkrNgogICAgbG9jYWwgZHgsZHk9eDAteDEseTAteTEK
ICAgIGlmIGR4KmR4K2R5KmR5PDM2IHRoZW4gLS0gY2VudGVycyBhcmUgY2xvc2VyIHRoYW4gNiBw
eAogICAgICBraWxsKGUpCiAgICBlbmQKICBlbmQpCgogIGxheSA9IHdvcmxkLnN5cygibGF5aW5n
LHBvcyIsIGZ1bmN0aW9uKGUpCiAgICBpZiBybmQoKSA_IC45OSB0aGVuCiAgICAgIGNoaWNrKG5p
bCwgZS54LCBlLnkpCiAgICBlbmQKICBlbmQpCgogIHZhbmlzaCA9IHdvcmxkLnN5cygiZGVhZCIs
IGZ1bmN0aW9uKGUpCiAgICBpZiBlLmFnZSA_PSBtYXhhZ2UgdGhlbgogICAgICB3b3JsZC5kZWwo
ZSkgLS0gcmVtb3ZlIGVudGl0eSBmcm9tIHRoZSB3b3JsZAogICAgZW5kCiAgZW5kKQoKICAtLSBh
IHN5c3RlbSB0aGF0IGhhcyBubyB0YWdzICgiIikgd2lsbCBydW4gZm9yIGV2ZXJ5IGVudGl0eSBp
biBlZ2dzCiAgbG9jYWwgY2Vuc3VzX3N5cyA9IHdvcmxkLnN5cygiIiwgZnVuY3Rpb24oKQogICAg
cG9wICs9IDEKICBlbmQpCiAgLS0gV3JhcCBzeXN0ZW1zIGludG8gY29udGFpbmVyIGZ1bmN0aW9u
cyBpbiBvcmRlciB0byBkbyAicHJlIiBhbmQgInBvc3QiIGFjdGlvbnMKICBjZW5zdXMgPSBmdW5j
dGlvbigpCiAgICBwb3AgPSAwCiAgICBjZW5zdXNfc3lzKCkKICAgIGlmIHBvcCA_IDEwMCBhbmQg
bm90IHRoZWJlYXN0IHRoZW4KICAgICAgdGhlYmVhc3QgPSBiZWFzdCgpCiAgICBlbmQKICAgIG1h
eHBvcCA9IG1heChtYXhwb3AsIHBvcCkKICBlbmQKCiAgbG9jYWwgZHJhd19lID0gZnVuY3Rpb24o
ZSkKICAgIHNwcihlLnMsIGUueCwgZS55LCAxLCAxLCBlLnZ4IGFuZCBlLnZ4IDwgMCkKICAgIC0t
bG9jYWwgbXNrPXdvcmxkLm1zayhlKQogICAgLS1pZiBtc2sucHJleSB0aGVuCiAgICAtLSAgY2ly
YyhlLngrNCxlLnkrNCw2LDE0KQogICAgLS1lbmQKICBlbmQKCiAgbG9jYWwgZHJhd19kZWFkID0g
d29ybGQuc3lzKCJwb3Msc3ByaXRlLGRlYWQiLCBkcmF3X2UpCiAgbG9jYWwgZHJhd19hbGl2ZSA9
IHdvcmxkLnN5cygicG9zLHNwcml0ZSxhbGl2ZSIsIGRyYXdfZSkKCiAgZHJhdyA9IGZ1bmN0aW9u
KCkKICAgIGRyYXdfZGVhZCgpCiAgICBkcmF3X2FsaXZlKCkKICAgIGlmIHRoZWJlYXN0IHRoZW4g
ZHJhd19lKHRoZWJlYXN0KSBlbmQKICBlbmQKCiAgZm9yIHg9MCwxNSBkbwogICAgZm9yIHk9MCwx
NSBkbwogICAgICBsb2NhbCB0PW1nZXQoeCx5KQogICAgICBpZiB0PT0xIHRoZW4KICAgICAgICBj
aGljaygiZiIsMjQreCo1LDIwK3kqNSkKICAgICAgZWxzZWlmIHQ9PTUgdGhlbgogICAgICAgIGNo
aWNrKCJtIiwyNCt4KjUsMjAreSo1KQogICAgICBlbmQKICAgIGVuZAogIGVuZAplbmQKCmZ1bmN0
aW9uIF91cGRhdGUoKQogIHRpY2soKQogIGdyb3coKQogIHdhbmRlcigpCiAgaWYgdGhlYmVhc3Qg
dGhlbgogICAgc2NhbigpCiAgICBmbGVlKCkKICBlbmQKICBtb3ZlKCkKICBpZiB0aGViZWFzdCB0
aGVuIGh1bnQoKSBlbmQKICBsYXkoKQogIHZhbmlzaCgpCiAgY2Vuc3VzKCkKCiAgaWYgYnRucCg0
KSB0aGVuCiAgICBzdGF0cyA9IG5vdCBzdGF0cwogIGVuZAoKICBpZiBidG5wKDUpIHRoZW4KICAg
IGNoaWNrKCkKICBlbmQKZW5kCgpmdW5jdGlvbiBfZHJhdygpCiAgY2xzKDMpCgogIGRyYXcoKQoK
ICBjcHUgPSBzdGF0KDEpCiAgaWYgc3RhdHMgdGhlbgogICAgY29sb3IoMTIpCiAgICBsb2NhbCBm
PSJcXm8xNDAiCiAgICBwcmludChmIC4uICJwb3A6IiAuLiBwb3AgLi4gIi8iIC4uIG1heHBvcCwg
MSwgMTEwKQogICAgcHJpbnQoZiAuLiAiY3B1OiIgLi4gZmxyKGNwdSAqIDEwMDAwKS8xMDAgLi4g
IiUiLCAxLCAxMTYpCiAgICBwcmludChmIC4uICJtZW06IiAuLiBmbHIoc3RhdCgwKSoxMDApLzEw
MCAuLiAia2liIiwgMSwgMTIyKQogICAgcHJpbnQoZiAuLiAi4p2OOmxheSIsIDkwLDExNikKICAg
IHByaW50KGYgLi4gIvCfhb7vuI86dG9nZ2xlIiwgOTAsMTIyKQogIGVuZAplbmQ=
:: lib/eggs.p8/test_eggs.p8
b64$cGljby04IGNhcnRyaWRnZSAvLyBodHRwOi8vd3d3LnBpY28tOC5jb20KdmVyc2lvbiA0Mwpf
X2x1YV9fCi0tZWdncwotLWJ5IGtpa2l0bwoKI2luY2x1ZGUgZWdncy5sdWEKI2luY2x1ZGUgdGVz
dF9lZ2dzLmx1YQoKX19nZnhfXwowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDA4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDg4MDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDcwMDcw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNTc5MDAwMDAwMDAwMDAwMDAwMDAwODgwMDAw
MDAwODg0YzkwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMAowMDA3NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNWE5MDAwMDAwNzcwMDAwMDAwMDAw
MDAwMDAwMDAwMGFjOTAwZGRkMDA0ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDA3NzAwMDAwMDA3MDAwMDAwNWE5MDAwNzcwYWEwMDA2
Nzc3NzcwMDAwMGYwMDAwMDBhYzkwMGRkMGFhMDAwZGRkZGQ0ODAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDcwMDcwMDAwMDc3NzAwMDAw
YWEwMDAwMDc3N2EwMDAwNjc3NzcwMDAwZmZmMDAwMDBhYTAwMDBkYWFhMDAwZDBkNDQ0NDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAw
MDAwMDAwMDY3NzAwMDBhYWEwMDAwMDY2NzcwMDAwNjY2NzAwMDAwNGZmMDAwMGFhYTAwMDAwOWFh
MDAwMDA0NDQ0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMAowMDAwMDAwMDAwMDA2MDAwMDAwOTA5MDAwMDA5MDkwMDAwMDkwOTAwMDAwMDQw
MDAwMDA5MDkwMDAwMDkwOTAwMDAwOTA5MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNTA1MDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDUwNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2NjY2MDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAow
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNjY2NjAwMDAwMDAwMDAwMDAwMDAwMDAw
MDUwNTAwNTA1NjY2NjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA1MDUwMDAwNjY2NjYwMDAw
MDAwMDAwMDAwMDAwMDAwNTY2MDAwNTU1NTU2NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwNTA1MDAwMDY2
NjYwMDA2NjY2NjYwMDAwMDAwMDAwMDA1MDUwMDA1NjY2MDAwNTU1MDA2NTAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDA3
NzAwMDA2NjYwMDAwMDY2NjYwMDAwMDAwNjYwMDA3NzcwMDAwMDY2NjAwMDU1MDY2MDAwMDAwNTU2
NzYwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MAowMDAwMDAwMDA3Nzc5OTcwMDAwNjYwMDAwNjYwNjYwMDAwMDAwNzY1MDc3OTk3NzAwMDA2NjAw
MDAwMDY3NTAwMDAwMDU1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwNzc3NzAwMDAwNzY1MDAwMDAwNzY1MDAwMDA1NTAw
MDA3Nzc3MDAwMDA2NzUwMDAwNTUwMDAwMDAwMDUwNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAow
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAow
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAow
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAow
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAow
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDA0MDAwNAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDBmNDA0ZgowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5OTk5OQowMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA5MTkxOQow
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDA3NzA3NzU3NwowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDA3OTk5Nzc3MAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDk5OTY5MAowMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwNDA0
MApfX2xhYmVsX18KMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMK
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMK
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzZjMzMzMzMzMzMzMzMzMzMzMzMzM3MzMzMzczMzMzMzMzMzMzMzMzMzczMzMzNzMzMzMzMzMz
MzMzMzMzZjMzMzNmMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzNmZmYzMzMzMzMzMzMzMzMzMzMzMzc3NzMzNzc3MzMzMzMzMzMzMzMz
Nzc3MzM3NzczMzMzMzMzMzMzMzNmZmYzM2ZmZjMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMK
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0ZmYzMzMzMzMzMzMzMzMzMzMzMzY3NzMz
Njc3MzMzMzMzMzMzMzMzNjc3MzM2NzczMzMzMzMzMzMzMzM0ZmYzMzRmZjMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzNDMzMzMzMzMz
MzMzMzMzMzMzMzM2MzMzMzYzMzMzMzMzMzMzMzMzMzYzMzMzNjMzMzMzMzMzMzMzMzMzNDMzMzM0
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzM2YzMzMzMzMzMzNmMzMzMzMzMzMzNzMzMzMzMzMzMzMzMzMzMzMzMzM3
MzMzMzMzMzMzMzMzMzMzMzMzM2YzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzZmZmMzMzMzMzM2ZmZjMzMzMzMzM3NzczMzMz
MzMzMzMzMzMzMzMzMzc3NzMzMzMzMzMzMzMzMzMzMzMzZmZmMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzNGZmMzMzMzMzMzRm
ZjMzMzMzMzM2NzczMzMzMzMzMzMzMzMzMzMzMzY3NzMzMzMzMzMzMzMzMzMzMzMzNGZmMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzQzMzMzMzMzMzM0MzMzMzMzMzMzNjMzMzMzMzMzMzMzMzMzMzMzMzM2MzMzMzMzMzMzMzMz
MzMzMzMzMzQzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM2YzMzMzZjMzMzNmMzMzMzMzMzMzNzMz
MzM3MzMzMzczMzMzMzMzMzM3MzMzMzczMzMzNzMzMzMzMzMzMzMzMzMzZjMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzZmZmMzNmZmYz
M2ZmZjMzMzMzMzM3NzczMzc3NzMzNzc3MzMzMzMzMzc3NzMzNzc3MzM3NzczMzMzMzMzMzMzMzNm
ZmYzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzNGZmMzM0ZmYzMzRmZjMzMzMzMzM2NzczMzY3NzMzNjc3MzMzMzMzMzY3NzMzNjc3MzM2
NzczMzMzMzMzMzMzMzM0ZmYzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzQzMzMzNDMzMzM0MzMzMzMzMzMzNjMzMzM2MzMzMzYzMzMz
MzMzMzM2MzMzMzYzMzMzNjMzMzMzMzMzMzMzMzMzNDMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM2YzMzMz
MzMzMzMzMzMzMzMzMzMzNzMzMzMzMzMzMzczMzMzMzMzMzM3MzMzMzMzMzMzNzMzMzMzMzMzMzMz
MzMzMzMzMzNmMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzZmZmMzMzMzMzMzMzMzMzMzMzMzM3NzczMzMzMzMzNzc3MzMzMzMzMzc3NzMzMzMz
MzM3NzczMzMzMzMzMzMzMzMzMzMzM2ZmZjMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzNGZmMzMzMzMzMzMzMzMzMzMzMzM2NzczMzMzMzMzNjc3
MzMzMzMzMzY3NzMzMzMzMzM2NzczMzMzMzMzMzMzMzMzMzMzMzRmZjMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzQzMzMzMzMzMzMzMzMzMzMz
MzMzNjMzMzMzMzMzMzYzMzMzMzMzMzM2MzMzMzMzMzMzNjMzMzMzMzMzMzMzMzMzMzMzMzM0MzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzZjMzMzNmMzMzMzMzMzMzMzMzMzM3MzMzMzczMzMzMzMzMzMzMzMz
MzczMzMzNzMzMzMzMzMzM2YzMzMzZjMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMK
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzNmZmYzM2ZmZjMzMzMzMzMzMzMzMzc3NzMz
Nzc3MzMzMzMzMzMzMzMzNzc3MzM3NzczMzMzMzMzZmZmMzNmZmYzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0ZmYzMzRmZjMz
MzMzMzMzMzMzMzY3NzMzNjc3MzMzMzMzMzMzMzMzNjc3MzM2NzczMzMzMzMzNGZmMzM0ZmYzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzNDMzMzM0MzMzMzMzMzMzMzMzMzM2MzMzMzYzMzMzMzMzMzMzMzMzMzYzMzMzNjMzMzMz
MzMzMzQzMzMzNDMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMK
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMK
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMKM2NjYzMzY2MzY2NjMzMzMzNjY2MzYzMzMzMzYzNjY2MzYzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKM2MxYzNjMWMzYzFjMzNjMzMxMWMzYzMzMzNjMTMxMWMz
YzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKM2NjYzNjM2MzY2NjMzMxMzMz
Y2MzY2NjMzNjMzMzY2MzY2NjMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKM2Mx
MTNjM2MzYzExMzNjMzMzMWMzYzFjMzNjMzMzMWMzYzFjMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMKM2MzMzNjYzEzYzMzMzMxMzNjY2MzY2NjM2MxMzNjY2MzY2NjMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzEzMzMxMTMzMTMzMzMzMzMxMTEzMTExMzEzMzMx
MTEzMTExMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMKMzNjYzNjY2MzYzNjMzMz
MzNjY2MzMzMzM2NjYzNjM2MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzM2NjY2NjMzMzMzMzYzMzM2NjYzNjM2MzMzMzMzMzMzMzMzMzMzMK
M2MxMTNjMWMzYzNjMzNjMzMxMWMzMzMzMzExYzMxM2MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzY2MxYzFjYzMzYzMzYzMzM2MxYzNjM2Mz
MzMzMzMzMzMzMzMzMzMKM2MzMzNjY2MzYzNjMzMxMzMzY2MzMzMzMzMzYzMzYzEzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzY2NjMWNjYzMz
MTMzYzMzM2NjYzNjY2MzMzMzMzMzMzMzMzMzMzMKM2MzMzNjMTEzYzNjMzNjMzMzMWMzMzMzMzMz
YzNjMTMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzY2MxYzFjYzMzYzMzYzMzM2MxYzMxMWMzMzMzMzMzMzMzMzMzMzMKMzFjYzNjMzMzMWNj
MzMxMzNjY2MzM2MzMzMzYzNjM2MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMWNjY2NjMTMzMTMzY2NjM2MzYzNjY2MzMzMzMzMzMzMzMzMz
MzMKMzMxMTMxMzMzMzExMzMzMzMxMTEzMzEzMzMzMTMxMzEzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzExMTExMzMzMzMzMTExMzEzMTMx
MTEzMzMzMzMzMzMzMzMzMzMKM2NjYzNjY2MzY2NjMzMzMzNjY2MzY2NjMzMzMzNjY2MzY2NjM2Mz
YzNjY2MzY2NjMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM2NjY2Nj
MzMzMzMzY2NjMzNjYzMzY2MzM2NjM2MzMzNjY2MzMzMKM2NjYzNjMTEzY2NjMzNjMzMxMWMzMTFj
MzMzMzNjMWMzMTFjM2MzYzMxYzEzYzFjMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzY2MxMTFjYzMzYzMzMWMxM2MxYzNjMTEzYzExM2MzMzNjMTEzMzMKM2MxYzNjYzMz
YzFjMzMxMzMzM2MzMzNjMzMzMzNjY2MzMzNjM2NjMTMzYzMzY2MxMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzY2MzYzNjYzMzMTMzM2MzM2MzYzNjMzMzYzMzM2MzMzNj
YzMzMzMKM2MzYzNjMTMzYzNjMzNjMzMzM2MzMzNjMzMzMzNjMWMzMzNjM2MxYzMzYzMzYzFjMzMz
MzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzY2MzMTNjYzMzYzMzM2MzM2Mz
YzNjM2MzYzNjM2MzMzNjMTMzMzMKM2MzYzNjY2MzYzNjMzMxMzMzM2MzMzNjMzNjMzNjY2MzMzNj
M2MzYzNjY2MzY2NjMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMWNj
Y2NjMTMzMTMzM2MzM2NjMTNjY2MzY2NjM2NjYzNjY2MzMzMKMzEzMTMxMTEzMTMxMzMzMzMzMzEz
MzMxMzMxMzMxMTEzMzMxMzEzMTMxMTEzMTExMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMz
MzMzMzMzMzMzMzMzMzExMTExMzMzMzMzMzEzMzExMzMxMTEzMTExMzExMTMxMTEzMzMKCl9fbWFw
X18KMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwCjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKMDAwNTAwMDAwMDAxMDEwMDAwMDEwMTAw
MDAwNTA1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMAowNTAwMDUwMDAxMDAwMDAwMDEwMDAwMDAwNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCjA1MDUwNTAwMDEwMTAxMDAwMTAxMDEw
MDAwMDUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAKMDUwMDAwMDAwMTAwMDEwMDAxMDAwMTAwMDAwMDA1MDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAowMDA1MDUwMDAwMDEwMTAwMDAwMTAx
MDAwNTA1MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwCjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAKMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMAowMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwCjAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAKMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMApfX3NmeF9fCjAxMDEwMDAwMDk1
MTAwYTUyMDBhNTMwMGM1NTAxMDU1MDEzNTUwMTQ1NTAxMzU1MDE0NTUwMTQ1NTAxNjU0MDE3NTIw
MDA1MDAwMDUwMDAwNTAwMDA1MDAwMDUwMDAwNTAwMDA1MDAwMDUwMDAwNTAwMDA1MDAwMDUwMDAw
NTAwMDA1MDAwMDUwMDAwNTAwMDA1MDAwMDUwMDAwNTAwMDA1MDAwMDUwMAowMDAxMDAwMDEyMTEw
MTExMjAxMTE0MDEwMTUwMTAxNTAwZjE1MDBjMTUwMDgxNTAwNDE1MDAzMTQwMDAxMzAwMDEyMDAw
MTAwMDAxMDAwMDEwMDAwMTAwMDAxMDAwMDEwMDAwMTAwMDAxMDAwMDEwMDAwMTAwMDAxMDAwMDEw
MDAwMTAwMDAxMDAwMDEwMDAwMTAwMDAxMDAwMDEwMDAwMTAwMDAxMDAKOTEwMTAwMDAxYjA1MDFi
MDUwMWEwNTAxOTA1MDE2MDUwMTEwNTAwYTA0MDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
:: lib/eggs.p8/test_eggs.p8.png
b64$iVBORw0KGgoAAAANSUhEUgAAAKAAAADNCAYAAAA-pXupAAAh_UlEQVR4Ae29Paym173d91vr
f6jLQkUcBMgtCAewGJu5EDkfZIAEuLgey7dgAJcqmGSAjOMxooLpVMrS3BsWKViqYJApmISFClbJ
DaIAskMrLK4Na3g4YgAlJpMUKly6UJd5-iv31X7e4Tsvz8z5mMM5M5y9DofPu5-98ey99vqv1erm
zR_wxe333793v-Gk4fXZF7aDx92-6cfY-ePOfxyoqCxaIGdeAoRKyXLsGW7_5ze_tT3rVoC_-d_-
---9w79-XVmePAkFWlQhy8nvS3KLpgdnp1nD4BRkoVWqwMISYXIREjhy7xobvH_5ttLd27FW3N1t
kFQALPDlGlWwjN-759WStN10bzRTAIEmeSLnv-3_B9y8cePgvgBv-3f-w73-4j-7j_9XQA01s2TJ
9gDbDf_VUVIqBdSr2ksW6D4BBUUVyzIY2J0vKNlpGOuVBsdDSDl7DZ6rGUu757d9f7_AZQl92S9L
wJK1GkBV5fvn359vudH9NkI8NaffnsCQsT_t_ZQ1n45rbydtT3PU_Nvvf8A-uHHD4uDFe--wxvWv
LvAcQYMu8hgR9Czv37I2hddfFtATwe33P-hSmY8jPmv8nYawLWlIWBrz5Qu5wEBOc3kP7H-3-Cfc
v6X7Y7VivDsxhY_1-310xt_pz7umxXHn352vdfx2bKle_MnVK5cwKGcmYPw9hgDW_V_uMWJ_tC2v
e-uyLel_-5aIyEDG3PX3-nxJ2h37JSmSdr55tvOfbO4Y9eDYbatAVgljqEAeONv2t-fOXyBkFREq
lyHUA3Pu8wFCpd09SCe--N373t7d6c4-xt45vIs4ePHezRvXHxhQKm0uZsmS7eFaJjtVYpWaDlkv
UVIyGvvzBwFF1vbu2B0G1t2dXADv3f5X-ODmHz7b_f8c4-b7HxwtwGcB771xG976V-D5Z-zgvZ-N
23xGBXh0aD-t4rv10RAfwMvf5b1-40-nbT6jeCYF_INb1zj4128C8F-f_ogf-OtfzJt8XgX43rvv
PPDvYe-23z9q-km_cfOdN-juL-4t-t-fPZvi_3t-eu1Uz915239HtXffPaz9qPWO6juq-ah5T0yA
WzH84Ic-etChdtrb37tjj3p3rOvtzNvij3-_g_fSNf7iFx995ff2_ff_9Bp-8YuPvtI_6Xq7Yjvt
OmfBwXks8jDnOg9h77rqxIPu_bhzd8V11kJ4XAc8FwGexMEed7191-wmCum49qMc6yzueZ5CupAI
Pokj7gvmvXffOfLdcUI_at50vS-fb59bMe2OPy4_98eedZ2zQBy8eO-mjesz1yaeOG6--8HX44AT
ExcawRMTU4ATU4ATE1OAE1OAExNTgBNPJQ4eZ-Lt9z_YDE5w88b1ixHg73HrzXkDzzNu-XxG8MSz
iynAiSnAiSnAiYkpwIkpwImJKcCJKcCJiSnAiSnAiYkpwIkpwImJKcCJKcCJiSnAiSnAiYkpwIkp
wImJKcCJKcCJiSnAiSnAiYkpwIkpwKcd2ns_VygoBCXquRSgwFr-Lujc2Xs__fMji4s5-wILgSUs
T1z8KhVIqvGHD3589fJrZ1rszuFduPby2QSw-XvSl6_yjIoi8kVpMDv-nnwBWLZEpMffwUefcxr9
fHnp4VeHnyIOXrx388b1M3379vsfwK03zx6AF_ZBE_eGWz-ncfRzMRF4ofU-8TThYgQ4sZcIu5Gw
jYjdd3tt6Yg5zyYKH-z4NBm_izuHd_Hay9_My79-oUeJ4VFiec7x0ec8jn4u3gG31fyAAHYrfr99
ziJIHnyyfd4fcPT4iXNywHphzwH3neAhziB9Mxxw4ohI3yv43fb_2Md0wBnBE895BE8815gCnJgC
nHj2UFU1BThxYViWZZkCnJgR-DTg3ptvne96b793oncXtt4R5z1vDqYAT3kZ53UBW2HsCuSodxe2
3hHnPW8OpgBPgQ-fefdc1-v48PMTvbuo9Y4673lz8CRx8KwL8K03XuJn77zLW2_8dC7rXfv4XT7i
h79-PurdRa131HnPm4PpgGe4lPPEUcI4i1i_rvWOOu_zKL5nUoD33nzrfMe9-d757u_81zvhOZ5V
PFMC3F7GcZdy4nGrWM5LNOe_3gnPMQX4hPDhOyeLrZOO_-jw83Pd33mvd9JzTAE_Ibz1xkt8_M67
HPz8Z_cy7trH7-Lx4ecc-PQH57K-817vpOeYAnzCIjzPcdc_Pl_XOe-1TnqOKcAnhHtvvnXmd0eu
9-Z7Z373JNY7KQdTgE9QfLsXcNJ3jxLLrhhO_u5JrHdSDqYAnxA_fOer8XbSd0fh48PPz-zuSax3
Ug6eZRw8S5t9642X_Nk77-LWGy_d_t1RuPbxu3zED3--PO27J7HeSTl4liEOXrx388b1M02_-f4H
cOvNb1RFTpwSt37O4_jnmYpg-mrT995863zXe-u-EVhQQgh0ZPve2--tI-u37fNe76Tte2-_p_e6
3pNq_1na8L3-6C2BdO-N-_R81vsv39MQ4XvHiHT0P_lxpy3K8y7OJ4Hi4IWfXL10OTgCgiVQqEVQ
UVrYURhPvmzfuftZdO1vrO8XoYpAOBEa67GuS491H6P9Rz-7X-NHf-IfCsiff373sdf73rf_vfz1
P-w3Afjzf-4-AiAsICJi-E-fe-Fv5d-5t-_asPNf-bP-SVhf8uQIKaj1vT-4o-z1P-xrwsqf-7P-
WTghjH5aiAD63rf_1hgH_fN--heC7OyLU7f-6Gf-yw4vnz3ueit68OFilO2o3fFkHElGH33B1auv
oQS8_pl6LInXJbf-thjtO4d3EQcv3nucDOfWm19rhQg50NsD-Oxf-Ja33njp3Nb-6I9-yLWP331q
xx3NyYPX_XXwcmLc_jmPox_fj0i_PoTcFx9w7iSfVASnGXcSPs4qvq1-7ONCxHcO_jgXAR5FyJPE
vTffOtG7kxbMvbffO9G7k-LxOOud9mxPm4Ecp49zEeCTrJiHXcbupRz17qSEbIWxK5Cj3p14f4_x
3nb-yynO9qwZyJkEeJEVs48P3-lqlB317qT4_PDzE707KR9nWW--HLt8PM7ZnkYDOXgWI3cXb73x
Ej97513eeuOlh77TKfZ87eN3_Ygf-v75qHcn5eMs653mbGcVyNd5h6dZ_6mI4Md11KMuY-fdack_
ShjHieU819vl47izPesGciIBPk2R_00omMnHKQU4BTL5_Lr4uJAIngKZfDxSgFMgk48nxceRApwC
mXw8KT6eSARPgUw_HinAScgUyEXx4UnIFMhF8vG1RPAUyOTjpHx8LQKcApl8nJSPr0WAUyCTjyca
wVMgk4_z8nEuApwCmXyclY_nMoKnQJ4fPs4kwCmQycd58XEmAU6BTD7Oi4_nIoKnQJ5fPk4kwCmQ
ycfXxceJBDgFMvn4uvi4kAjeJ6RAZWQklTEIF4VtV4FKUpVKqHCVBEalbZ_rKES55FIVKiQVKmwY
c0AGVVkFlkqusQlVSSVVlQptB1VVQSEjS7JLsoUklSXskgqEpRobZ-0I675EqQDZEuUC2TZ2obKM
Cii7PHrGIUQVNVZHrjLCGjs3kseGylAWheySTaHxZwE2lstYdlG27XGqQoJxWBjkWVJhC0MVHgei
uD-UKsklDd4RwriEC1lYFOVCGlxRkmUoFUYymLJkywiVxhntUiGbcbDthsqgQeDKAlUFeNWQTVmW
x4pylVaSx4lUQ11QsrCrXCmlZcDyQnUJNXQ1SS_lIGBJTKIsJDKobYUonSW1WXPJ4iWhS2077Sy1
_dk4xtAiC7BgUGiwUSdL3CZ0YilLoKvDggOxUFAaR6AodEw6Uga1tFiAzU0vS0siFVmKW0ZqRCtF
WoAS6HbLiwWdbiOaVuLENB2sjXZ6WYQdOokIJCSEDtWRFiRCS_1gSaD1qqMWbfWiqEO3Eogii2hh
kUCErGtASx3jwdpilxe8EBypY9GWQ0Ap2oNe3BIaXCIFhK1oWGYwcRVVf3b1yqVAJAmnpZiWoYdW
lEpACgZ1qZ1Ev7r7f4Rr32FzjU66hYVaxEmI3U7UZpSwm3R543qJURE1SktJIishXncHlHCHtkJS
NqEB2_oOjtDYWRTUoxaFHFrC3XZAQrHdaYbnqZIWsRtSthHtRKPcwa0oTttJNNQlxwkRmwMkRMW4
dBARG4Yr8oIkhjKjJi2UJhqjTSfKoMPOUFmIlHGAJHKSWLLGFtLjsEYBx44TJZhSCBlMeO2tHhtr
tWLBkrIDePUQRWm1XJYkdQ_vj1tIKcfdFdVSRkunsSMkhX-yha9c-m5cJiHelKhH5aSWSIoixiVm
UbksLWB-8unhUjr4g1uvX740SGlBTLRx7O4RNEm3NUwguCJaspQ7h4fwt-_mx1XZKF2jbFulGkxC
Mi6xG4tVTNVZPUCpaA1mB0LKEsESragi2yySKnJMRrDIRIqFtAgpZhRry6PqDBv7TrolVxj3FwAi
0Kb6lyG-9ZCwOqCH56mixcg9YjchcSRErBLNUKRGFTWOjGXCoo4YorEgUSH3mMG4ZcdOgCrFG0OL
JPUaFbQicGmoEamtjcM3llc7ZPhMVDZWamnFq7cEVRy5lSDZjTppKqW22iitxi1aXcMbyWrW7mFg
KqRoWEx__Xn-_1dfre7NdtdKHdUjMmpQFkg9zHtJRyqHO5-eVfmg-tHVVy9ZBIHaElliecQVMu54
daEwnB-CncPP4O__HEXRZmQnshMkkgQcKeAyJlZQLNwNslwZYbooGNMiotRRyosShJGWtAv3QhDr
MYd_SY9wrTE7kgHAKg0KaMVWgmw14FFwLiVaYwesYXBOlRBYVpYlGiaEklAaQ4ddJh7aa8aVquzu
lQYLQlymO0irNEEkVtH0IAw7GQGykWirV_umUyPm20pGsTqdUXoj2ksiSmHUUROwFdSKlOEoXm0Y
RW45jkZKsmG5pMqSLoklrNYQmRHVrfuJ3SNmf-mFLl96VZtLVEc20JQlKAbnrRg5LEoqBe6IXx3_
OhX9wa2rV74rUYrVpoeCCZtZPSJOYEEaQ4360_Env4Y-_RsYVyeU7WXct1G3Nz2Rk04SVbIxgSUW
FtUBo0UghG2P8h7XFIhdm6peYlVaS6kJpVHUtFt0YWVTeA3thqTSw8Vbw9cTZRNoBQaFbo2sT42I
gKITCTsKG9kLsYw8NIkpx41SsVsWbmQHRaJJjE0axDhMZNsLyBmHGh9otplsarDuYLwJvJC4hYWj
qCgnitRS01HWZCtCD3deCM74OpjVojfB0EFIPYzCFhlJanmx2nJrkZf0qjjhUAtKGVpCLVyM29lW
Xf-y-9LVS1dUiYa1wgjniIgenqXhWUaMbcfkzuFdlf2tH79__XJHDd1stltCcpzQHnZqkngYjpEl
qX-16V3yve9YrY29N4zvkjSoJAib07WsIk5QnMRuhQohskRHayo2q49FGw9ekkbGcTJufrW4VqIg
xx2NS8iwM1wUIwSCenvstmg6iVS2cY8qwOtqSKVkhOPw2lWTTZqWQsfAmp4V9VLDZJ0i0ohn0Yza
VXdDZLnjOGTkkuhSGdqba20QHWuYqzE9tpIODJsCiMvuRpQRcqxOyyUhRYDHnqVK4yraPTgdJorH
aYm_zDSr1BYGlEB5jXVFjskmXzqkaHWF_sdf_MrV70ZYKFEXbRLG3WOr1CGu0A2WjBLp00-vUtQL
P3n96mtEKpmo5SEGM_p1KG4UKdUUXqvh0zt3ybXvSKTVFmqTyEYjAVHT0KbdeIER1UWcjVOtNxFs
q9NrbHm42fiscIUwAggW0bHjNbyitlIdBNUlKiMwkzUR8LDwECll1IOwUQ8kkiuKK4oULZI2KVm0
m4xNVKJo5BqSN5FrQoYDR1FFiz3K1611_Srb3R4GlFZGWUeK0nGAiIQN14mD27EkOrhkWi0h2cmy
hCq5I8XLeuESSUeFSAJSF0gjjZ24rV49HDudjbv38Fa7x-daI7Sl4QrqTYBlo8pCa0nbEco--Zyr
r13R2IrSjj0_7nJCIzaVNGSz0WOaCIc7n-w6pRe_9ZMrl16zpYZNYjZeC8OEIZGoKTwqEqx4Qb-6
9V352suQzb7NKNKQEBsvoemKjEDJqJHYjWKCsoZEAraHKArUESgEUlH1iJNYUotCdGLVyEkkryMi
IzXJxtmGckZRZ9TxIEUCqYdApAT9VUGnHbUs6DW9SrEyHHlQT40BUVUTV9yiLarJSL-EECFhWelQ
Go6oEMteXRtlOOA4vtSy0448LhT3JmCVpD1qNsMNJamRjJvgRHaRJEBhSVEUuaMlwgrpwiyWRjDY
qBWqY8UaGll9CjreXFBlU5fqjUm55dXc89EXXL303cF5bGtQgFDaQxhRLEWSxzYqYO7cvVtF1Z_9
fvlyrEgoBoGDlgxbjEnFSZYRvjGxIHcO75Jr38EudUJGRMQ4HdvOmkIKnWFDNouCZcaJpNQ205I0
wU4pSVNSKcrKpaIMP3MjOUmnpHRk0U0KCZK2WfOoIZtw35xKIKVaIyODY9rIa2DLodWASh57clSD
HVHQixUUWDZmuERxLDmNbBpUyrrjJBLuWKGjjRxMOpUazaGDDFsN1WoqpU4nreHhyrgFWePjRdJE
GaVMKXKjjOiJpFE1LfcoiVgBymIYDQrCkhY7ThoBilHiJhl50k6VBI4ztkID8j-5vK_8fiXuoIJe
UEUEa1QKW6tZ_R2li8inn95NoT-4ydWrr_LIC4jQKWx5qIkoGqbs3iZAd0vcOfxU_pO-2XInDL_A
cRVicSyr6cjDPIJQy10mo1K6LK8BggocsUQmiRSQa80IuoWrnRaCbqewx3mIEenY0ZoYxBEpjxgZ
N90KlajjEcsrOcMXrVZiyx0vGlZm0SSVYeEx1iLZbaJmw6oZcl1tKdKSTeKU1KP6EtRkmGSsEXyk
Lbvl4JDujNqENZktB8tJsrVzsSxDYoP3kSbN2JuwGJeWCKmVQs7vNdN0W6XBj4kTVsegR0EMsuyx
hSATGg8PRg5D37-8l7565bXh4cEmSwQkLQUPA5DojBhqgVOO-sWduy698K1bVy_-JkLbbFzLwVJv
6rbFIAshLWjsaMiRTz65a137jhOQSvfDaSU5bXncCSP3YUTaJh87jCS05CC1VqsSY9Or36QFUTL_
18PMKaSGYiQ76-_KIFuDBVxWki7VuEBcLS2mR6F0SAnLlfS49o0PRTXstoCkHGljAT2ULpss7VHe
Mg2pjKpHbsBoFGWF7hoWbOw2DCOTWX3doWQg0tj64IZRUyWCrO5E1chOJy5VaLAx2NESDCNjonXX
gkjGJAtapdgy7pG3HtY-6kgebt8Et8tuKREerhb3SG-ln-7LXL1yBS9k1ZtaZWdUH8gYmlFHoagS
oXXn8LOuOnjhH73x2qvDlJMFk1owJWgtKYXhAu1qZTE9SiKffPKp9b1-l6DOpuy6R9oQkFvBLRlQ
JQpFJSMxy6U4GVT2KGScdmRwVMqopjIbPZeEsMKIRhKbkNBlaEllEohHgJezNCW0dAS1yduOxcYJ
HEXlsMQhERhImdUFbLSM3USDehCOgmKrHWQZqzchMSp2nTpII1ogqCo91LWhIiOkcPWIQYygE9Nq
S3QSeSR-UEwX3hxthGWVSFONIBizsJFSM0hfbXGkvKJGTYmkbdwSTgjDVdJe70dLu_24EzlaJCXV
GilDYsmttP_3-4crl16tWFnjpof3l9R0LKcbl8RQbdLDmA8P77qog1uvX7mUBaWsUZOBhGwqedxM
tpncHRtLRfLJp79O-8nLYFURKUUbibRGajZCRlJZg3BJtjXcD9HanGb8nzZhsK5BkHCnokhZp6TV
EkiJFWc4qIc-eTWQQl5QCBtjEAnt1Q3iDaPZJMkScOwQpKoSQNRmU5UGMFmvMyKOWxmOOyyuFVXW
e03c9qLh0IqG1FutikdGOlI3KN3jE6FbFlHAJQuT1cmIgY6tLK1QkdpjWqgMuaXxSAp1jfTzuMYY
BWdkbAGLPBx6jFDGx9taiLCdFlXpBqBXR1wjfuyI0kdf5MqV10yUajK8TapOWlEcYZrYsjq0i1Kc
PvzksxR64SdvXHmVEFt4CUa9iUSP0hlZoqSTkiq46cXozp3Pyn-35RaoMVE3ctRWGDVmJRujyaKG
IeZeEMrSwZGatEgJSA9zGsRGI6_FXJIh3Uo5ipA1SjiNSxGKhosodkq9Rjlxx0bGw9mDcKLAsGVU
oMhL0yEJw5V6KKEUq0doJcHr-cZyoPF6mBoWQXCq4kURXapVU5Y0qkGGyFguNYqzKJHL6u4QRrmq
Vysq0m2LgZiynCwSFUapx9nccqLxn6gkIC-dlMo0prykGfeejXkqw-5QgmQEQiS4kLBaqFB3j2hP
o--9C1_5colh6yRKGdRSiFxGLEhyh0ZaEwL7zuGvUxy88OMrl17DEFJNxUq1N9VpdbDAyuosIwax
Ov2rw8_kv-2dtFB1FFmlJY1KAo9UC2QtCjalNVwxClGwyo1MLyPAbafHRBtliQoTLZ2k0JoooEAk
BG47NHjNHlp0DU5QmSiqRb04iIojULuCW5AeMZeS6OGaLSyFjnucHEIkVRsrI06lMDJu9e7hm0Os
are0iKZxlM1Xmtg9il5J0lJXN8FWWIaA7HjkpRE9wiNruODxtTZJE5cjtcIILrdquN-qCGv6KhIx
FG4TiySxvNbRWtxOLxmZq5EBCwotUqlRKaT-8Rd548qlFu0QYSGNGlSkRG1LohNqvdoSoE8OP01R
B3-2_uVLhDK1JC2NuT2GpVVOJ1KU2HIvvdj2rw4P47-zsofUpCJNS640kdrucTE4MRDZvdlBemNz
NcxRCS2XazAhNinulhdL7m3JjPvbLNc0NcIuwoYksoAmoiRa0homECuhy9DjAkaJJa1KxepxKY1b
mA6lomkUC5uxTWKhtjXKUAsV6GTjLb6-D2Vwjf_qyuH_azQ8Z6FERFY7wL0qB9byqxZAkYwQ6kir
J47Ka9KVckwUJNtJpDgq1ONmWEtTiaXqlnCaxTIBI2jcZLFVSlhDJUk221XGZa11GMdpgz76v_v1
K6-B2ILcDiM2PfwkdCSpEi0q6IxN5c7hXZXrhR9fvXLZdreDJMVAGwOoS_DIwZhOK6Ug59M7n7r-
zssNlEwHDaKNRKLepE4ngtpuaVRF7MZyZWSjQrfRaHQ6NY6qDLM0Cp3hvxIEexiy2uBWQ6GKhdRB
yWqiiVVOaxkJ6LBkKNfuVqzIw9OSEXFuMiwmjrdbcsMIg1bkoIYIFU5kMja0nRosKyKbsR7xKALD
vUNgo-xIHtFFVLHioTor3WmVMgo5w4NDi_G0rWB5LWuHRKR7JEWNaw0JeEguUWRbaUVqkGlAxLTt
pBc8-FIi8TBJbXqbLJYI6KMvfPXSqwmx5B5qj0q0iJQCgzuFaahaM4xfffoZJX-rJ69fuqSmN4II
SbVIQdNORBAjfYLXSAO67nzymfS97xgXWsQQvMgI17TtoFVFHst1AVIysriqs6yybQ9LYAhPaZCa
cY1Ji5iSh6PEarXTGiYFtNXOoqFoqnGgFcAisa2kB-kBu0MjCnooB4aPIoqmvanAHt41EqWyyfmF
MVYVrQWTkLipTTwvkaogLVNpIDVk3rjL0ppWajTclFQHNrFY0KhpqUSpA1aqFVU2Oe7YbbXpirQ4
rlGoUplEwe3InW65KskSUSa4hdwWyKK5b99yms23ooC3VTJsqAMqWazC_OX-2VcvvQoQEpKMX2E0
WX-A_nOUUAJ3PvkUcfDivZs3rnMW3H7-A7j15pnmTnxDcOvnPI5_PBmcuEhMAU5MAU5MAU5MTAFO
TAFOTEwBTkwBngqvvPLh-X-77x7W-6j5jxp3mvETz5ED-u5H339AKLvt-f590fzuR9--Sv9R4tuO
Ocn4iedMgN9_50EX_u31R-fvCui317-af5Rjbtc86fiJ58wBH_VK_-2PEuRR7Uc57knGTzydODiv
hfYd735k7rjWVwSzvnvllQ-hnYc75v5ax42feM4EuCuOXTfaim6-f1_QD7jX9aPbpxk-8ZwJ8LfX
V1cCfvOb7993o1d227-5Pq_88iG-_c1Xo-IB9-rNg2Lb9r_y7V7X_8263lHjv6nYcryLo-jcjt3t
25275W73eVHweRHzux99-wEnesCVjiFzf_5RDnuatb-J4tueffvc5fEogX4lqb6JDrgfqV9xtWNi
e9dBH7X21gW344_K9m86vv3OOPdR-B7Hx-6c4wT7zDjgSVzrODJOU51b8T0v0bvP01aEx3H6KAc8
7n6eKQH_7kff55VXPnygon57-Uvn2vY-jIxXXvnw1NV5nGt_E4W3K7Ltc19U_xzu38muWI8T7DMT
wb_9Di9tD3-9q1Gw379PxgPE7Yh2P0627-afzwMe4HDv-VG-9zk9krs9zp9ZB9w62G517lbffv9R
0bHbvx2-73Bbgrd9u_P3v7f-3O-fd4dnAbs8Hedg_2O2ibHb3l-jKA73_86bs3MR4MMiYz8SHhax
_2OPm3tU9Dxq-LbvUXH1tGPL1-as2-3v8rjP6e7zlVc_fODM2-Z_-3E8njdv5ybA-Y19_50PHx4J
e_3fXv9qlOy2H1bhjxq-S-i2b3fMt9958EKepSje5-ZhnD4qos-C_8O__1QIcH9j_5e73-_o_DiL
4I-qf9Q3jut-mvGws5-lPEdF7Vk5f6oi_NvvfHiuh9lf6ziydwW-nbu7xrMmvt2o3OV2l8fjOD0q
ho8T4z5nj7rTs_Dg3Mi5vvfcYv-9EdGwv85R7a-83ln-kft42H6OmP_0R_9LRwjsURF7FGfbMcdx
8qQ4Ewcv3rt542wr3n7-g2cywibOF4_jn8dywLN_eGJiC08KJqYAJ6YAJyamACemACcmpgAnpgAn
JqYAJ6YAJya_Thw8zuTDw8PJ4ASXL1_eDjgxI3hiYgpw4tnCwXkt9Jcf-_L_7--gj--0gXcnbU9M
AT4WdoX0lx--4lTtiSnAc3HB04hqOuCEvy4HPCqa90U3hTdx7g64K8SHiW_638S5C3BfSKdtT8wI
npiYApyYEXwm-OXHv3ggXv-y41888Dxq-P64R80-qn8-zrfvZrw-pw74OBe-nfuwNfb7958PE-rE
cyTAfRHsutRJxp_2f2IK8CsutRuDx4lnP0pP2z-x7OPgvB3wpO73sLkPc73j_qdjPucC3L-4k7jf
Uc_T9u_-m8KbETwxMQU4MQU4MTEFODEFODExBTjxdOPgvBZ6__237--_6U9-_pX27piHtR_13qO_
edT3zqu9__1HfW-iKXDA3YvY-t4V209-_tOvtE_63lHi213vqPGP2s9J_7dCe9j3pvieIgHuusJZ
5m7-nXW9-fHHifwkRfB1nXfia3LAs17odu6jHO00DnxUVB41-nFEPt3vKRPgURe1fW4ve9-hjnOo
48RzXi60v9_HOepRrj1xdoiDF_-dvHH9TJMPDw8ngxNcvnz5TPNuv--B1_eAExMXGsETEyfBwUVY
78TE7fc-4OaNGwfTAScuTHwzgicuVHxTgBMXKr4pwIkLFd8U4MSFim8KcOJCxQfgmzduHNx_-4PJ
1MQTF999B5winLgI8QHcHzBE_P69Sd3zBbvoXoYXSditXhJqdFhYMQlpQlnqFtAdYQskWDpYoKDG
3PwHf18CQ0KXkqWP_v7-D_xbqpBUVMGgAAAAEHRFWHRMb2RlUE5HADIwMTEwMjIx41m2wQAAAABJ
RU5ErkJggg==
:: lib/error_explorer.lua
b64$LS0tIEBkaWFnbm9zdGljIGRpc2FibGUKLS0gIyBwaWNvdHJvbiBlcnJvciBleHBsb3Jlcgot
LQotLSBieSBraXJhCi0tCi0tIHZlcnNpb24gMC4wLjYKLS0KLS0gYW4gaW50ZXJhY3RpdmUgZXJy
b3Igc2NyZWVuIGZvciBwaWNvdHJvbi4KLS0gb24gZXJyb3IsIHNob3dzIHRoZSBzdGFjaywgbG9j
YWwgdmFyaWFibGVzLAotLSBhbmQgdGhlIHNvdXJjZSBjb2RlIHdoZW4gYXZhaWxhYmxlLgotLQot
LSAjIyB1c2FnZQotLQotLSBgaW5jbHVkZWAgb3IgYHJlcXVpcmVgIGBlcnJvcl9leHBsb3Jlci5s
dWFgCi0tIGluIHlvdXIgcHJvZ3JhbSBfYWZ0ZXJfIGRlZmluaW5nIHlvdXIgYF9pbml0YCwKLS0g
YF91cGRhdGVgLCBhbmQgYF9kcmF3YCBmdW5jdGlvbnMuCi0tCi0tIHByZXNzIGB1cGAgYW5kIGBk
b3duYCB0byBtb3ZlIHVwIGFuZCBkb3duIG9uCi0tIHRoZSBzdGFjaywgcHJlc3MgYHhgIG9yIGBz
cGFjZWAgdG8gdG9nZ2xlIGZvbnQKLS0gc2l6ZS4gY2xpY2sgb24gdGFibGVzIGluIHRoZSB2YXJp
YWJsZSB2aWV3IHRvCi0tIGV4cGFuZCB0aGVtLgotLQotLSAjIyBob3cgaXQgd29ya3MKLS0KLS0g
aW4gb3JkZXIgdG8gY2F0Y2ggZXJyb3JzIGFuZCBpbnNwZWN0IHJ1bnRpbWUKLS0gc3RhdGUsIHRo
aXMgc2NyaXB0IHJlcGxhY2VzIGBfaW5pdGAsIGBfdXBkYXRlYAotLSBhbmQgYF9kcmF3YCBmdW5j
dGlvbnMgd2l0aCBvbmVzIHRoYXQgY2FsbCB0aGUKLS0gb3JpZ2luYWwgb25lcyBpbnNpZGUgYSBj
b3JvdXRpbmUuCi0tCi0tIHdoZW4gdGhlcmUncyBhbiBlcnJvciwgaXQgdXNlcyBsdWEncyBkZWJ1
ZwotLSBsaWJyYXJ5IHRvIGluc3BlY3QgdGhlIGNvcm91dGluZS4gYSBjb3B5Ci0tIG9mIHRoZSBl
cnJvciBpcyBhbHNvIHByaW50ZWQgdG8gdGhlIGNvbnNvbGUKLS0gd2l0aCBwcmludGggaWYgeW91
J3JlIHJ1bm5pbmcgcGljb3Ryb24gZnJvbQotLSB0aGUgY29tbWFuZCBsaW5lLgotLQotLSB0aGUg
Zm9sbG93aW5nIGRlYnVnIGFwaXMgYXJlIHVzZWQ6Ci0tCi0tIC0gYGRlYnVnLmdldGluZm9gCi0t
IC0gYGRlYnVnLmdldGxvY2FsYAotLSAtIGBkZWJ1Zy5nZXR1cHZhbHVlYAotLSAtIGBkZWJ1Zy50
cmFjZWJhY2tgCi0tCi0tICMjIHZlcnNpb24gaGlzdG9yeQotLQotLSB2ZXJzaW9uIDAuMC42Ci0t
IC0gb24gZXJyb3I6Ci0tICAgLSBzaG93IGN1cnNvcgotLSAgIC0gbWFrZSB3aW5kb3cgcmVzaXph
YmxlCi0tIC0gYXV0b21hdGljYWxseSBhZGp1c3QgbGF5b3V0IHRvIHdpbmRvdyBzaXplCi0tIC0g
c3VwcG9ydCB5aWVsZGluZyAoc2luY2UgZmV0Y2ggc29tZXRpbWVzIHlpZWxkcykKLS0KLS0gdmVy
c2lvbiAwLjAuNQotLQotLSAtIGZ1dHVyZSBwcm9vZmluZzogZ3JhY2VmdWxseSBoYW5kbGUgd2hl
bgotLSAgIHZhcmlvdXMgcGFydHMgb2YgdGhlIGBkZWJ1Z2AgbW9kdWxlIGFyZW4ndAotLSAgIGF2
YWlsYWJsZQotLQotLSB2ZXJzaW9uIDAuMC40Ci0tCi0tIC0gYWxzbyBjYXRjaCBlcnJvcnMgaW4g
YF9pbml0YAotLQotLSB2ZXJzaW9uIDAuMC4zCi0tCi0tIC0gYXV0b21hdGljYWxseSBjaG9vc2Ug
dGhlIHJpZ2h0IHN0YWNrIGZyYW1lCi0tICAgYmFzZWQgb24gdGhlIGVycm9yIG1lc3NhZ2UKLS0g
LSBtb3JlIHRob3JvdWdobHkgcHJvdGVjdCBmcm9tIGVycm9ycyBpbiBlcnJvcgotLSAgIGV4cGxv
cmVyIGl0c2VsZgotLQotLSB2ZXJzaW9uIDAuMC4yCi0tCi0tIC0gZG9uJ3QgcmVnZW5lcmF0ZSBz
dGFjayBpbmZvIGV2ZXJ5IGRyYXcKLS0gLSBzY3JvbGwgc3RhY2sgYW5kIHZhcmlhYmxlcyBsaXN0
IHdpdGggbW91c2V3aGVlbAotLSAtIGNsaWNrIG9uIHN0YWNrIHRvIHN3aXRjaCBzdGFjayBmcmFt
ZXMKLS0gLSBjbGljayBvbiB0YWJsZXMgaW4gdmFyaWFibGVzIHZpZXcgdG8gZXhwYW5kIHRoZW0K
LS0gLSBlc2NhcGUgc3RyaW5ncyB3aGVuIHByaW50aW5nIHRoZW0KLS0KLS0gdmVyc2lvbiAwLjAu
MQotLQotLSAtIGFkanVzdCBjb2xvcnMKLS0gLSBjb2RlIGNsZWFudXAKLS0gLSB1c2UgYGJ0bnBg
IGluc3RlYWQgb2YgYGtleXBgCi0tIC0gc2xpZ2h0bHkgbW9yZSB0aG9yb3VnaCBgcmVzZXRgCi0t
IC0gZG9uJ3Qgc2hvdyB0ZW1wb3JhcmllcwotLQotLSB2ZXJzaW9uIDAuMC4wIChwcmVyZWxlYXNl
KQotLQotLSAtIGluaXRpYWwgZGlzY29yZCBiZXRhCgotLSAjIyBsaWNlbnNlCi0tCi0tIENvcHly
aWdodCAyMDI0IEtpcmEgQm9vbQotLQotLSBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBm
cmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5Ci0tIG9mIHRoaXMg
c29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIOKAnFNvZnR3
YXJl4oCdKSwgdG8KLS0gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwg
aW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUKLS0gcmlnaHRzIHRvIHVzZSwgY29weSwg
bW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yCi0t
IHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdo
b20gdGhlIFNvZnR3YXJlIGlzCi0tIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUg
Zm9sbG93aW5nIGNvbmRpdGlvbnM6Ci0tCi0tIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFu
ZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluCi0tIGFsbCBjb3Bp
ZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgotLQotLSBUSEUgU09G
VFdBUkUgSVMgUFJPVklERUQg4oCcQVMgSVPigJ0sIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJ
TkQsIEVYUFJFU1MKLS0gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBU
SEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksCi0tIEZJVE5FU1MgRk9SIEEgUEFSVElD
VUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMCi0tIFRI
RSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBE
QU1BR0VTIE9SIE9USEVSCi0tIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09O
VFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HCi0tIEZST00sIE9VVCBPRiBPUiBJTiBD
T05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIKLS0gREVBTElO
R1MgSU4gVEhFIFNPRlRXQVJFLgoKLS0tLSB1dGlsIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0KCmxvY2FsIGZ1bmN0aW9uIGZpbGVuYW1lX29mKHBhdGgpCiAgIHJldHVy
biBwYXRoOm1hdGNoKCJbXi9dKiQiKQplbmQKCmxvY2FsIGZ1bmN0aW9uIHNhZmVfdG9zdHJpbmco
dmFsdWUpCiAgIGlmIHR5cGUodmFsdWUpID09ICJzdHJpbmciIHRoZW4KICAgICAgcmV0dXJuIHN0
cmluZy5mb3JtYXQoIiVxIiwgdmFsdWUpCiAgIGVsc2UKICAgICAgbG9jYWwgc3VjY2VzcywgdmFs
dWVfc3RyaW5nID0gcGNhbGwodG9zdHJpbmcsIHZhbHVlKQogICAgICByZXR1cm4gc3VjY2VzcyBh
bmQgdmFsdWVfc3RyaW5nCiAgICAgICAgIG9yICgiZXJyb3IgZHVyaW5nIHRvc3RyaW5nOiAiLi50
b3N0cmluZyh2YWx1ZV9zdHJpbmcpKQogICBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBnZXRfbGlu
ZXModGV4dCkKICAgbG9jYWwgbGluZXMgPSB7fQogICBmb3IgbGluZSBpbiB0ZXh0OmdtYXRjaCgi
KC4tKVxyP1xuIikgZG8KICAgICAgdGFibGUuaW5zZXJ0KGxpbmVzLCBsaW5lKQogICBlbmQKICAg
bG9jYWwgbGFzdF9saW5lID0gdGV4dDptYXRjaCgiKFteXG5dKikkIikKICAgaWYgbGFzdF9saW5l
IGFuZCBsYXN0X2xpbmUgfj0gIiIgdGhlbgogICAgICB0YWJsZS5pbnNlcnQobGluZXMsIGxhc3Rf
bGluZSkKICAgZW5kCiAgIHJldHVybiBsaW5lcwplbmQKCmxvY2FsIGZ1bmN0aW9uIGNvbXBhcmVf
a2V5cyhhLCBiKQogICBsb2NhbCB0YSA9IHR5cGUoYS5rZXkpCiAgIGxvY2FsIHRiID0gdHlwZShi
LmtleSkKICAgaWYgdGEgfj0gdGIgdGhlbgogICAgICByZXR1cm4gdGEgPCB0YgogICBlbmQKICAg
aWYgdGEgPT0gIm51bWJlciIgb3IgdGEgPT0gInN0cmluZyIgdGhlbgogICAgICByZXR1cm4gYS5r
ZXkgPCBiLmtleQogICBlbHNlCiAgICAgIHJldHVybiBzYWZlX3Rvc3RyaW5nKGEua2V5KSA8IHNh
ZmVfdG9zdHJpbmcoYi5rZXkpCiAgIGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIHNvcnQodCwgZikK
ICAgLS0gaW5zZXJ0aW9uIHNvcnQKICAgZiA9IGYgb3IgZnVuY3Rpb24oYSwgYikgcmV0dXJuIGEg
PCBiIGVuZAogICBmb3IgaSA9IDEsICN0IC0gMSBkbwogICAgICBsb2NhbCB2YWwgPSB0W2kgKyAx
XQogICAgICBsb2NhbCBqID0gaQogICAgICB3aGlsZSBqID49IDEgYW5kIG5vdCBmKHRbal0sIHZh
bCkgZG8KICAgICAgICAgdFtqICsgMV0gPSB0W2pdCiAgICAgICAgIGogPSBqIC0gMQogICAgICBl
bmQKICAgICAgdFtqICsgMV0gPSB2YWwKICAgZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24gYXBwcm9h
Y2goZnJvbSwgdG8pCiAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiAwLjI1CmVuZAoKbG9j
YWwgZnVuY3Rpb24gcm91bmQodmFsdWUpCiAgIHJldHVybiBtYXRoLmZsb29yKHZhbHVlICsgMC41
KQplbmQKCmxvY2FsIGZ1bmN0aW9uIHBhcnNlX21lc3NhZ2VfZm9yX2xvY2F0aW9uKG1zZykKICAg
bG9jYWwgcGF0aCwgbGluZSwgZXJyID0gbXNnOm1hdGNoKCJeKFteOl0rKTooJWQrKTooLiopJCIp
CiAgIHJldHVybiBwYXRoLCB0b251bWJlcihsaW5lKSwgZXJyCmVuZAoKLS0tLSBzdGF0ZSAtLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCmxvY2FsIF9HID0gX0cKbG9jYWwg
ZXJyb3JfbWVzc2FnZQpsb2NhbCBlcnJvcl90aHJlYWQKbG9jYWwgZXJyb3JfdHJhY2ViYWNrCmxv
Y2FsIGluaXRfZG9uZSA9IGZhbHNlCmxvY2FsIHVzZV9zbWFsbF9mb250ID0gZmFsc2UKbG9jYWwg
bW91c2Vfd2FzX2NsaWNrZWQgPSBmYWxzZQoKLS0gc3RhY2sgdmlldwpsb2NhbCBzdGFja19mcmFt
ZXMgPSB7fQpsb2NhbCBjdXJyZW50X3N0YWNrX2luZGV4ID0gMQpsb2NhbCBob3ZlcmVkX3N0YWNr
X2luZGV4ID0gZmFsc2UKbG9jYWwgbW91c2Vfb3Zlcl9zdGFjayA9IGZhbHNlCmxvY2FsIHN0YWNr
X21heF9zY3JvbGwgPSAwCmxvY2FsIHN0YWNrX3Njcm9sbCA9IDAKbG9jYWwgc3RhY2tfc2Nyb2xs
X3Ntb290aCA9IDAKCi0tIHZhcmlhYmxlcyB2aWV3CmxvY2FsIHZhcmlhYmxlcyA9IHt9CmxvY2Fs
IGhvdmVyZWRfdmFyaWFibGUgPSBmYWxzZQpsb2NhbCB2YXJpYWJsZXNfbWF4X3Njcm9sbCA9IDAK
bG9jYWwgdmFyaWFibGVzX3Njcm9sbCA9IDAKbG9jYWwgdmFyaWFibGVzX3Njcm9sbF9zbW9vdGgg
PSAwCmxvY2FsIG1vdXNlX292ZXJfdmFyaWFibGVzID0gZmFsc2UKCi0tIHNvdXJjZSB2aWV3Cmxv
Y2FsIHNvdXJjZV9saW5lcyA9IHt9CgoKLS0tLSBtYWluIGV2ZW50cyAtLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0KCmxvY2FsIGZ1bmN0aW9uIHJlYnVpbGQoKQogICAtLSByZWJ1aWxk
IHN0YWNrIGZyYW1lIGluZm8KICAgc3RhY2tfZnJhbWVzID0ge30KICAgdmFyaWFibGVzID0ge30K
ICAgc291cmNlX2xpbmVzID0ge30KICAgdmFyaWFibGVzX3Njcm9sbCA9IDAKICAgdmFyaWFibGVz
X3Njcm9sbF9zbW9vdGggPSAwCgogICBmb3IgaSA9IDAsIDIwIGRvCiAgICAgIGxvY2FsIGluZm8g
PSBkZWJ1Zy5nZXRpbmZvKGVycm9yX3RocmVhZCwgaSkKICAgICAgaWYgbm90IGluZm8gdGhlbgog
ICAgICAgICBicmVhawogICAgICBlbmQKCiAgICAgIGlmIGluZm8uc2hvcnRfc3JjIHRoZW4KICAg
ICAgICAgdGFibGUuaW5zZXJ0KHN0YWNrX2ZyYW1lcywgewogICAgICAgICAgICBmaWxlbmFtZSA9
IGZpbGVuYW1lX29mKGluZm8uc2hvcnRfc3JjKSwKICAgICAgICAgICAgcGF0aCA9IGluZm8uc2hv
cnRfc3JjLAogICAgICAgICAgICBsaW5lID0gaW5mby5jdXJyZW50bGluZSwKICAgICAgICAgICAg
ZGVwdGggPSBpLAogICAgICAgICAgICBmbl9uYW1lID0gKGluZm8ubmFtZSBvciAoZmlsZW5hbWVf
b2YoaW5mby5zaG9ydF9zcmMpLi4iOiIuLnRvc3RyaW5nKGluZm8ubGluZWRlZmluZWQpKSksCiAg
ICAgICAgICAgIHNvdXJjZSA9IGluZm8uc291cmNlLAogICAgICAgICB9KQogICAgICBlbmQKICAg
ZW5kCgogICBsb2NhbCBmcmFtZSA9IHN0YWNrX2ZyYW1lc1tjdXJyZW50X3N0YWNrX2luZGV4XQoK
ICAgaWYgbm90IGZyYW1lIHRoZW4KICAgICAgcmV0dXJuCiAgIGVuZAoKICAgLS0gcmVidWlsZCB2
YXJpYWJsZXMKICAgZG8KICAgICAgaWYgZGVidWcuZ2V0bG9jYWwgdGhlbgogICAgICAgICBsb2Nh
bCBsb2NhbF9pbmRleCA9IDEKICAgICAgICAgcmVwZWF0CiAgICAgICAgICAgIGxvY2FsIG5hbWUs
IHZhbHVlID0gZGVidWcuZ2V0bG9jYWwoZXJyb3JfdGhyZWFkLCBmcmFtZS5kZXB0aCwgbG9jYWxf
aW5kZXgpCiAgICAgICAgICAgIGlmIG5hbWUgdGhlbgogICAgICAgICAgICAgICBpZiBuYW1lIH49
ICIodGVtcG9yYXJ5KSIgdGhlbgogICAgICAgICAgICAgICAgICB0YWJsZS5pbnNlcnQodmFyaWFi
bGVzLCB7CiAgICAgICAgICAgICAgICAgICAgIGtleSA9IG5hbWUsCiAgICAgICAgICAgICAgICAg
ICAgIHZhbHVlID0gdmFsdWUsCiAgICAgICAgICAgICAgICAgIH0pCiAgICAgICAgICAgICAgIGVu
ZAogICAgICAgICAgICAgICBsb2NhbF9pbmRleCA9IGxvY2FsX2luZGV4ICsgMQogICAgICAgICAg
ICBlbmQKICAgICAgICAgdW50aWwgbm90IG5hbWUKICAgICAgZWxzZQogICAgICAgICB0YWJsZS5p
bnNlcnQodmFyaWFibGVzLCB7CiAgICAgICAgICAgIGVycm9yID0gIm5vIGRlYnVnLmdldGxvY2Fs
LCBjYW5cJ3Qgc2hvdyBsb2NhbHMiCiAgICAgICAgIH0pCiAgICAgIGVuZAoKICAgICAgaWYgZGVi
dWcuZ2V0dXB2YWx1ZSB0aGVuCiAgICAgICAgIGxvY2FsIGluZm8gPSBkZWJ1Zy5nZXRpbmZvKGVy
cm9yX3RocmVhZCwgZnJhbWUuZGVwdGgpCiAgICAgICAgIGlmIGluZm8gYW5kIGluZm8uZnVuYyB0
aGVuCiAgICAgICAgICAgIGxvY2FsIHVwdmFsdWVfaW5kZXggPSAxCiAgICAgICAgICAgIHJlcGVh
dAogICAgICAgICAgICAgICBsb2NhbCBuYW1lLCB2YWx1ZSA9IGRlYnVnLmdldHVwdmFsdWUoaW5m
by5mdW5jLCB1cHZhbHVlX2luZGV4KQogICAgICAgICAgICAgICBpZiBuYW1lIHRoZW4KICAgICAg
ICAgICAgICAgICAgdGFibGUuaW5zZXJ0KHZhcmlhYmxlcywgewogICAgICAgICAgICAgICAgICAg
ICBrZXkgPSBuYW1lLAogICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLAogICAgICAg
ICAgICAgICAgICB9KQogICAgICAgICAgICAgICAgICB1cHZhbHVlX2luZGV4ID0gdXB2YWx1ZV9p
bmRleCArIDEKICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgIHVudGlsIG5vdCBuYW1lCiAg
ICAgICAgIGVuZAogICAgICBlbHNlCiAgICAgICAgIHRhYmxlLmluc2VydCh2YXJpYWJsZXMsIHsK
ICAgICAgICAgICAgZXJyb3IgPSAibm8gZGVidWcuZ2V0dXB2YWx1ZSwgY2FuXCd0IHNob3cgdXB2
YWx1ZXMiCiAgICAgICAgIH0pCiAgICAgIGVuZAogICBlbmQKCiAgIC0tIHJlYnVpbGQgc291cmNl
IGxpbmVzCiAgIGxvY2FsIHNvdXJjZSA9IGZyYW1lLnNvdXJjZQogICBpZiBzb3VyY2UgdGhlbgog
ICAgICBpZiBzdHJpbmcuc3ViKHNvdXJjZSwgMSwgMSkgPT0gIkAiIHRoZW4KICAgICAgICAgbG9j
YWwgZmlsZW5hbWUgPSBzdHJpbmcuc3ViKHNvdXJjZSwgMiwgI3NvdXJjZSkKICAgICAgICAgc291
cmNlID0gZmV0Y2goZmlsZW5hbWUpCiAgICAgIGVuZAogICAgICBpZiBzb3VyY2UgYW5kIHR5cGUo
c291cmNlKSA9PSAic3RyaW5nIiB0aGVuCiAgICAgICAgIHNvdXJjZV9saW5lcyA9IGdldF9saW5l
cyhzb3VyY2UpCiAgICAgIGVuZAogICBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBlcnJvcl91cGRh
dGUoKQogICBsb2NhbCBsYXN0X2luZGV4ID0gY3VycmVudF9zdGFja19pbmRleAogICBpZiBidG5w
KDUpIG9yIGtleXAgInNwYWNlIiB0aGVuCiAgICAgIHVzZV9zbWFsbF9mb250ID0gbm90IHVzZV9z
bWFsbF9mb250CiAgIGVuZAogICBpZiBidG5wKDIpIHRoZW4KICAgICAgY3VycmVudF9zdGFja19p
bmRleCA9IG1hdGgubWF4KDEsIGN1cnJlbnRfc3RhY2tfaW5kZXggLSAxKQogICAgICBzdGFja19z
Y3JvbGwgPSBtYXRoLm1pbihjdXJyZW50X3N0YWNrX2luZGV4IC0gMSwgc3RhY2tfc2Nyb2xsKQog
ICBlbmQKICAgaWYgYnRucCgzKSB0aGVuCiAgICAgIGN1cnJlbnRfc3RhY2tfaW5kZXggPSBtYXRo
Lm1pbigjc3RhY2tfZnJhbWVzLCBjdXJyZW50X3N0YWNrX2luZGV4ICsgMSkKICAgICAgc3RhY2tf
c2Nyb2xsID0gbWF0aC5tYXgoKGN1cnJlbnRfc3RhY2tfaW5kZXgpIC0gKCNzdGFja19mcmFtZXMg
LSBzdGFja19tYXhfc2Nyb2xsKSwgc3RhY2tfc2Nyb2xsKQogICBlbmQKCiAgIGxvY2FsIF8sIF8s
IGNsaWNrLCBfLCB3aGVlbCA9IG1vdXNlKCkKICAgaWYgbW91c2Vfb3Zlcl9zdGFjayB0aGVuCiAg
ICAgIHN0YWNrX3Njcm9sbCA9IG1hdGgubWF4KDAsIG1hdGgubWluKHN0YWNrX3Njcm9sbCAtIHdo
ZWVsICogMiwgc3RhY2tfbWF4X3Njcm9sbCkpCiAgIGVuZAogICBzdGFja19zY3JvbGxfc21vb3Ro
ID0gYXBwcm9hY2goc3RhY2tfc2Nyb2xsX3Ntb290aCwgc3RhY2tfc2Nyb2xsKQogICBpZiBtb3Vz
ZV9vdmVyX3ZhcmlhYmxlcyB0aGVuCiAgICAgIHZhcmlhYmxlc19zY3JvbGwgPSBtYXRoLm1heCgw
LCBtYXRoLm1pbih2YXJpYWJsZXNfc2Nyb2xsIC0gd2hlZWwgKiAyLCB2YXJpYWJsZXNfbWF4X3Nj
cm9sbCkpCiAgIGVuZAogICB2YXJpYWJsZXNfc2Nyb2xsX3Ntb290aCA9IGFwcHJvYWNoKHZhcmlh
Ymxlc19zY3JvbGxfc21vb3RoLCB2YXJpYWJsZXNfc2Nyb2xsKQoKICAgY2xpY2sgPSBjbGljayB_
PSAwCiAgIGlmIGNsaWNrIGFuZCBub3QgbW91c2Vfd2FzX2NsaWNrZWQgdGhlbgogICAgICBpZiBo
b3ZlcmVkX3N0YWNrX2luZGV4IHRoZW4KICAgICAgICAgY3VycmVudF9zdGFja19pbmRleCA9IGhv
dmVyZWRfc3RhY2tfaW5kZXgKICAgICAgZW5kCiAgICAgIGlmIGhvdmVyZWRfdmFyaWFibGUgYW5k
IHR5cGUoaG92ZXJlZF92YXJpYWJsZS52YWx1ZSkgPT0gInRhYmxlIiB0aGVuCiAgICAgICAgIGlm
IGhvdmVyZWRfdmFyaWFibGUuY29udGVudHMgdGhlbgogICAgICAgICAgICBob3ZlcmVkX3Zhcmlh
YmxlLmNvbnRlbnRzID0gbmlsCiAgICAgICAgIGVsc2UKICAgICAgICAgICAgbG9jYWwgY29udGVu
dHMgPSB7fQogICAgICAgICAgICBob3ZlcmVkX3ZhcmlhYmxlLmNvbnRlbnRzID0gY29udGVudHMK
ICAgICAgICAgICAgZm9yIGssIHYgaW4gcGFpcnMoaG92ZXJlZF92YXJpYWJsZS52YWx1ZSkgZG8K
ICAgICAgICAgICAgICAgdGFibGUuaW5zZXJ0KGNvbnRlbnRzLCB7CiAgICAgICAgICAgICAgICAg
IGtleSA9IGssCiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdiwKICAgICAgICAgICAgICAgfSkK
ICAgICAgICAgICAgZW5kCiAgICAgICAgICAgIHNvcnQoY29udGVudHMsIGNvbXBhcmVfa2V5cykK
ICAgICAgICAgZW5kCiAgICAgIGVuZAogICBlbmQKICAgbW91c2Vfd2FzX2NsaWNrZWQgPSBjbGlj
awoKICAgaWYgY3VycmVudF9zdGFja19pbmRleCB_PSBsYXN0X2luZGV4IHRoZW4KICAgICAgcmVi
dWlsZCgpCiAgIGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIGVycm9yX2RyYXcoKQogICBsb2NhbCBX
ID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpCiAgIGxvY2FsIEggPSBnZXRfZGlzcGxheSgpOmhlaWdo
dCgpCgogICBsb2NhbCBwcmVmaXggPSB1c2Vfc21hbGxfZm9udCBhbmQgIlwwMTQiIG9yICIiCiAg
IGxvY2FsIGZvbnRfaGVpZ2h0ID0gKHVzZV9zbWFsbF9mb250IGFuZCA2IG9yIDExKQogICBsb2Nh
bCBteCwgbXkgPSBtb3VzZSgpCiAgIGxvY2FsIG92ZXJfc2VjdGlvbiA9IGZhbHNlCiAgIGxvY2Fs
IHgwLCB5MCwgeCwgeQoKICAgbG9jYWwgZnVuY3Rpb24gZ29fdG8obmV3X3gsIG5ld195KQogICAg
ICB4MCwgeTAgPSBuZXdfeCwgbmV3X3kKICAgICAgeCwgeSA9IHgwLCB5MAogICBlbmQKCiAgIGxv
Y2FsIGZ1bmN0aW9uIHNlY3Rpb24oc3gsIHN5LCBzdywgc2gpCiAgICAgIG92ZXJfc2VjdGlvbiA9
CiAgICAgICAgIG14ID49IHN4IGFuZCBteCA8IHN4ICsgc3cgYW5kCiAgICAgICAgIG15ID49IHN5
IGFuZCBteSA8IHN5ICsgc2gKICAgICAgY2xpcChzeCwgc3ksIHN3LCBzaCkKICAgICAgZ29fdG8o
c3ggKyAyLCBzeSArIDIpCiAgIGVuZAoKICAgbG9jYWwgZnVuY3Rpb24gcHJpbnRfaG9yaXpvbnRh
bCh0ZXh0LCBjb2xvcikKICAgICAgbG9jYWwgbmV3X3gsIF9uZXdfeSA9IHByaW50KHByZWZpeC4u
dGV4dCwgeCwgeSwgY29sb3IpCiAgICAgIHggPSBuZXdfeAogICBlbmQKCiAgIGxvY2FsIGZ1bmN0
aW9uIHByaW50X2xpbmUodGV4dCwgY29sb3IpCiAgICAgIGxvY2FsIF9uZXdfeCwgbmV3X3kgPSBw
cmludChwcmVmaXguLnRleHQsIHgsIHksIGNvbG9yKQogICAgICB4ID0geDAKICAgICAgeSA9IG5l
d195CiAgIGVuZAoKICAgLS0gZHJhdyBzZXR1cAogICBjbHMoMCkKICAgLS0gbGlnaHRlciBkYXJr
IGdyYXkgZm9yIHJlYWRhYmlsaXR5CiAgIHBhbCg1LCAweGZmNzA3MDcwLCAyKQogICBjb2xvcig1
KQoKICAgLS0gZXJyb3IgbWVzc2FnZQogICBzZWN0aW9uKDAsIDAsIFcsIEggLyAyKQogICBtb3Vz
ZV9vdmVyX3N0YWNrID0gb3Zlcl9zZWN0aW9uCgogICBsb2NhbCBsb2NfcGF0aCwgbG9jX2xpbmUs
IGVyciA9IHBhcnNlX21lc3NhZ2VfZm9yX2xvY2F0aW9uKGVycm9yX21lc3NhZ2UpCiAgIGlmIGxv
Y19wYXRoIHRoZW4KICAgICAgcHJpbnRfbGluZSgiZXJyb3IgYXQgIi4ubG9jX3BhdGguLiI6Ii4u
bG9jX2xpbmUuLiI6IiwgNikKICAgICAgcHJpbnRfbGluZSgiICAiLi5lcnIsIDgpCiAgIGVsc2UK
ICAgICAgcHJpbnRfbGluZSgiZXJyb3I6IiwgNikKICAgICAgcHJpbnRfbGluZSgiICAiLi5lcnJv
cl9tZXNzYWdlLCA4KQogICBlbmQKCiAgIC0tIHN0YWNrIGZyYW1lcwogICBwcmludF9saW5lKCJz
dGFjazoiLCA2KQogICBzZWN0aW9uKDAsIHksIFcsIEggLyAyIC0geSkKICAgbG9jYWwgc3RhY2tf
dG9wX3kgPSB5CiAgIHkgPSB5IC0gcm91bmQoc3RhY2tfc2Nyb2xsX3Ntb290aCAqIGZvbnRfaGVp
Z2h0KQogICBsb2NhbCBsYXN0X2hvdmVyZWRfc3RhY2tfaW5kZXggPSBob3ZlcmVkX3N0YWNrX2lu
ZGV4CiAgIGhvdmVyZWRfc3RhY2tfaW5kZXggPSBmYWxzZQogICBmb3IgaSwgZnJhbWUgaW4gaXBh
aXJzKHN0YWNrX2ZyYW1lcykgZG8KICAgICAgY29sb3IobGFzdF9ob3ZlcmVkX3N0YWNrX2luZGV4
ID09IGkgYW5kIDcgb3IKICAgICAgICAgY3VycmVudF9zdGFja19pbmRleCA9PSBpIGFuZCA2IG9y
IDUpCgogICAgICBsb2NhbCB5X2JlZm9yZSA9IHkKICAgICAgcHJpbnRfbGluZShzdHJpbmcuZm9y
bWF0KCIgICVzOiVkIGluIGZ1bmN0aW9uICVzIiwKICAgICAgICAgZnJhbWUuZmlsZW5hbWUsIGZy
YW1lLmxpbmUsIGZyYW1lLmZuX25hbWUpKQogICAgICBpZiBvdmVyX3NlY3Rpb24gdGhlbgogICAg
ICAgICBpZiBteSA_PSB5X2JlZm9yZSBhbmQgbXkgPCB5IHRoZW4KICAgICAgICAgICAgaG92ZXJl
ZF9zdGFja19pbmRleCA9IGkKICAgICAgICAgZW5kCiAgICAgIGVuZAogICBlbmQKICAgc3RhY2tf
bWF4X3Njcm9sbCA9ICNzdGFja19mcmFtZXMgLSAoSCAvIDIgLSBzdGFja190b3BfeSkgLyBmb250
X2hlaWdodAoKICAgbG9jYWwgZnJhbWUgPSBzdGFja19mcmFtZXNbY3VycmVudF9zdGFja19pbmRl
eF0KICAgaWYgbm90IGZyYW1lIHRoZW4KICAgICAgcmV0dXJuCiAgIGVuZAoKICAgLS0gdmFyaWFi
bGVzCiAgIHNlY3Rpb24oMCwgSCAvIDIsIFcgLyAyLCBIIC8gMikKICAgbW91c2Vfb3Zlcl92YXJp
YWJsZXMgPSBvdmVyX3NlY3Rpb24KICAgcHJpbnRfbGluZSgidmFyaWFibGVzOiIsIDYpCiAgIHNl
Y3Rpb24oMCwgeSwgVyAvIDIsIEggLSB5KQogICBsb2NhbCB2YXJpYWJsZXNfdG9wX3kgPSB5CiAg
IHkgPSB5IC0gcm91bmQodmFyaWFibGVzX3Njcm9sbF9zbW9vdGggKiBmb250X2hlaWdodCkKICAg
bG9jYWwgbGFzdF9ob3ZlcmVkX3ZhcmlhYmxlID0gaG92ZXJlZF92YXJpYWJsZQogICBob3ZlcmVk
X3ZhcmlhYmxlID0gZmFsc2UKICAgbG9jYWwgdmFyaWFibGVfY291bnQgPSAwCiAgIGxvY2FsIGZ1
bmN0aW9uIGRyYXdfdmFyaWFibGUodmFyaWFibGUsIGluZGVudCkKICAgICAgdmFyaWFibGVfY291
bnQgPSB2YXJpYWJsZV9jb3VudCArIDEKICAgICAgbG9jYWwgaG92ZXJlZCA9IHZhcmlhYmxlID09
IGxhc3RfaG92ZXJlZF92YXJpYWJsZQogICAgICBsb2NhbCB5X2JlZm9yZSA9IHkKICAgICAgaWYg
dmFyaWFibGUuZXJyb3IgdGhlbgogICAgICAgICBwcmludF9saW5lKCIgICIuLnZhcmlhYmxlLmVy
cm9yLCA4KQogICAgICBlbHNlCiAgICAgICAgIHByaW50X2hvcml6b250YWwoaW5kZW50Li52YXJp
YWJsZS5rZXksIGhvdmVyZWQgYW5kIDcgb3IgNikKICAgICAgICAgcHJpbnRfaG9yaXpvbnRhbCgi
OiAiLCB2YXJpYWJsZSA9PSBsYXN0X2hvdmVyZWRfdmFyaWFibGUgYW5kIDcgb3IgNSkKICAgICAg
ICAgcHJpbnRfbGluZShzYWZlX3Rvc3RyaW5nKHZhcmlhYmxlLnZhbHVlKSkKICAgICAgZW5kCgog
ICAgICBpZiBvdmVyX3NlY3Rpb24gYW5kIHR5cGUodmFyaWFibGUudmFsdWUpID09ICJ0YWJsZSIg
dGhlbgogICAgICAgICBpZiBteCA_PSAwIGFuZCBteCA8IFcgLyAyIGFuZCBteSA_PSB5X2JlZm9y
ZSBhbmQgbXkgPCB5IHRoZW4KICAgICAgICAgICAgaG92ZXJlZF92YXJpYWJsZSA9IHZhcmlhYmxl
CiAgICAgICAgIGVuZAogICAgICBlbmQKCiAgICAgIGlmIHZhcmlhYmxlLmNvbnRlbnRzIHRoZW4K
ICAgICAgICAgZm9yIF8sIHYgaW4gaXBhaXJzKHZhcmlhYmxlLmNvbnRlbnRzKSBkbwogICAgICAg
ICAgICBkcmF3X3ZhcmlhYmxlKHYsIGluZGVudC4uIiAgIikKICAgICAgICAgZW5kCiAgICAgIGVu
ZAogICBlbmQKICAgZm9yIF8sIHZhcmlhYmxlIGluIGlwYWlycyh2YXJpYWJsZXMpIGRvCiAgICAg
IGRyYXdfdmFyaWFibGUodmFyaWFibGUsICIgICIpCiAgIGVuZAogICB2YXJpYWJsZXNfbWF4X3Nj
cm9sbCA9IHZhcmlhYmxlX2NvdW50IC0gKEggLSB2YXJpYWJsZXNfdG9wX3kpIC8gZm9udF9oZWln
aHQKCiAgIC0tIHNvdXJjZQogICBzZWN0aW9uKFcgLyAyLCBIIC8gMiwgVyAvIDIsIEggLyAyKQog
ICBwcmludF9saW5lKCJzb3VyY2Ugb2YgIi4uZnJhbWUucGF0aC4uIjoiLCA2KQogICBsb2NhbCBj
b250ZXh0ID0gdXNlX3NtYWxsX2ZvbnQgYW5kIDEwIG9yIDUKICAgbG9jYWwgaV9taW4gPSBtYXRo
Lm1heCgxLCBmcmFtZS5saW5lIC0gY29udGV4dCkKICAgbG9jYWwgaV9tYXggPSBtYXRoLm1pbigj
c291cmNlX2xpbmVzLCBmcmFtZS5saW5lICsgY29udGV4dCkKICAgZm9yIGkgPSBpX21pbiwgaV9t
YXggZG8KICAgICAgY29sb3IoaSA9PSBmcmFtZS5saW5lIGFuZCA2IG9yIDUpCiAgICAgIHByaW50
X2hvcml6b250YWwoc3RyaW5nLmZvcm1hdCgiJTRkICIsIGkpKQogICAgICBwcmludF9saW5lKHNv
dXJjZV9saW5lc1tpXSkKICAgZW5kCgogICBjbGlwKCkKZW5kCgotLS0tIHRha2luZyBvdmVyIGR1
cmluZyBlcnJvcnMgLS0tLS0tLS0tLS0tLS0tLS0tLQoKbG9jYWwgZnVuY3Rpb24gcmVzZXQoKQog
ICAtLSBiYXNlZCBvbiByZXNldCgpIGZyb20gL3N5c3RlbS9saWIvaGVhZC5sdWEKICAgLS0gc2Vl
IHRoYXQgZm4gZm9yIGluZm8KICAgd2luZG93IHsKICAgICAgY3Vyc29yID0gMSwKICAgICAgcmVz
aXphYmxlID0gdHJ1ZSwKICAgfQogICBub3RlKCkKICAgLS0gcGljb3Ryb24gc2VnZmF1bHRzIGlm
IHdlIGNhbGwgY2xpcCgpIGR1cmluZyBpbml0CiAgIGlmIGluaXRfZG9uZSB0aGVuCiAgICAgIGNs
aXAoKQogICBlbmQKICAgY2FtZXJhKCkKICAgcGFsKCkKICAgcGFsdCgpCiAgIG1lbXNldCgweDU1
MWYsIDAsIDkpCiAgIHBva2UoMHg1NTA4LCAweDNmKQogICBwb2tlKDB4NTUwOSwgMHgzZikKICAg
cG9rZSgweDU1MGEsIDB4M2YpCiAgIHBva2UoMHg1NTBiLCAweDAwKQogICBjb2xvcig2KQogICBm
aWxscCgpCiAgIHBva2UoMHg1ZjU2LCAweDQwKQogICBwb2tlKDB4NWY1NywgMHg1NikKICAgcG9r
ZSgweDQwMDAsIGdldChmZXRjaCAiL3N5c3RlbS9mb250cy9saWwuZm9udCIpKQogICBwb2tlKDB4
NTYwMCwgZ2V0KGZldGNoICIvc3lzdGVtL2ZvbnRzL3A4LmZvbnQiKSkKICAgcG9rZSgweDU2MDYs
IHBlZWsoMHg1NjAwKSAqIDQpCiAgIHBva2UoMHg1NjA1LCAweDIpCiAgIHBva2UoMHg1ZjI4LCA2
NCkKICAgcG9rZSgweDVmMjksIDY0KQplbmQKCmxvY2FsIGZ1bmN0aW9uIG9uX2Vycm9yKHRocmVh
ZCwgbWVzc2FnZSkKICAgLS0gZG8gdGhpcyBmaXJzdCBpbiBjYXNlIHdlIGhpdCBhbm90aGVyIGVy
cm9yCiAgIGVycm9yX3RyYWNlYmFjayA9IGRlYnVnLnRyYWNlYmFjayh0aHJlYWQsIG1lc3NhZ2Up
CiAgIHByaW50aChlcnJvcl90cmFjZWJhY2spCgogICBlcnJvcl90aHJlYWQgPSB0aHJlYWQKICAg
ZXJyb3JfbWVzc2FnZSA9IHRvc3RyaW5nKG1lc3NhZ2UpCiAgIHJlc2V0KCkKICAgcmVidWlsZCgp
CiAgIC0tIGp1bXAgdG8gdGhlIHByb3BlciBzdGFjayBmcmFtZSBpZiB3ZSBjYW4KICAgbG9jYWwg
bG9jX3BhdGgsIGxvY19saW5lID0gcGFyc2VfbWVzc2FnZV9mb3JfbG9jYXRpb24oZXJyb3JfbWVz
c2FnZSkKICAgZm9yIGksIGZyYW1lIGluIGlwYWlycyhzdGFja19mcmFtZXMpIGRvCiAgICAgIGlm
IGZyYW1lLnBhdGggPT0gbG9jX3BhdGggYW5kIGZyYW1lLmxpbmUgPT0gbG9jX2xpbmUgdGhlbgog
ICAgICAgICBjdXJyZW50X3N0YWNrX2luZGV4ID0gaQogICAgICAgICByZWJ1aWxkKCkKICAgICAg
ICAgYnJlYWsKICAgICAgZW5kCiAgIGVuZAplbmQKCi0tLS0gaW5zdGFsbCBtYWluIGV2ZW50cyB0
aGF0IGNhdGNoIGVycm9ycyAtLS0tLS0tCgpsb2NhbCB1c2VyX2luaXQgPSByYXdnZXQoX0csICJf
aW5pdCIpCmxvY2FsIHVzZXJfdXBkYXRlID0gcmF3Z2V0KF9HLCAiX3VwZGF0ZSIpCmxvY2FsIHVz
ZXJfZHJhdyA9IHJhd2dldChfRywgIl9kcmF3IikKCmFzc2VydCh1c2VyX2RyYXcgYW5kIHVzZXJf
dXBkYXRlLAogICAicGxlYXNlIGluY2x1ZGUgZXJyb3JfZXhwbG9yZXIgYWZ0ZXIgZGVmaW5pbmcg
Ym90aCBfdXBkYXRlIGFuZCBfZHJhdyIpCgppZiBub3QgcmF3Z2V0KF9HLCAiZGVidWciKSBvciBu
b3QgZGVidWcudHJhY2ViYWNrIG9yIG5vdCBkZWJ1Zy5nZXRpbmZvIHRoZW4KICAgcHJpbnRoICJl
cnJvciBleHBsb3JlcjogZGVidWcgbW9kdWxlIG5vdCBhdmFpbGFibGUsIGVycm9yIGV4cGxvcmVy
IHdpbGwgYmUgZGlzYWJsZWQiCiAgIHJldHVybgplbmQKCmxvY2FsIGZ1bmN0aW9uIGNhbGxfZXJy
b3JfZXZlbnQoZm4sIC4uLikKICAgLS0gaWYgdGhlcmUncyBhbiBlcnJvciBpbiBvdXIgdXBkYXRl
IG9yIGRyYXcsIHRocm93IHRoZQogICAtLSBvcmlnaW5hbCBlcnJvciBhcyB3ZWxsIGFzIHRoZSBu
ZXcgZXJyb3IKICAgbG9jYWwgc3VjY2VzcywgZXJyID0gcGNhbGwoZm4sIC4uLikKICAgaWYgbm90
IHN1Y2Nlc3MgdGhlbgogICAgICBlcnJvcihlcnJvcl90cmFjZWJhY2suLiJcblxuZXJyb3IgZHVy
aW5nIGVycm9yIGhhbmRsaW5nOiAiLi50b3N0cmluZyhlcnIpKQogICBlbmQKZW5kCgpsb2NhbCBm
dW5jdGlvbiBjYWxsX3Byb3RlY3RlZChmbikKICAgLS0gbmVlZCB0byB1c2UgY29yZXN1bWUgZXRj
LiBhbmQgbm90IGNvcm91dGluZS5yZXN1bWUgZXRjLgogICAtLSBmb3IgcGljb3Ryb24gY29tcGF0
aWJpbGl0eQogICBsb2NhbCB0aHJlYWQgPSBjb2NyZWF0ZShmbikKICAgbG9jYWwgc3VjY2Vzcywg
bWVzc2FnZSA9IGNvcmVzdW1lKHRocmVhZCkKICAgd2hpbGUgY29zdGF0dXModGhyZWFkKSB_PSAi
ZGVhZCIgZG8KICAgICAgeWllbGQoKQogICAgICBzdWNjZXNzLCBtZXNzYWdlID0gY29yZXN1bWUo
dGhyZWFkKQogICBlbmQKICAgaWYgbm90IHN1Y2Nlc3MgdGhlbgogICAgICBjYWxsX2Vycm9yX2V2
ZW50KG9uX2Vycm9yLCB0aHJlYWQsIG1lc3NhZ2UpCiAgIGVuZAplbmQKCmlmIHVzZXJfaW5pdCB0
aGVuCiAgIGZ1bmN0aW9uIF9pbml0KCkKICAgICAgY2FsbF9wcm90ZWN0ZWQodXNlcl9pbml0KQog
ICAgICBpbml0X2RvbmUgPSB0cnVlCiAgIGVuZAplbHNlCiAgIGluaXRfZG9uZSA9IHRydWUKZW5k
CgpmdW5jdGlvbiBfdXBkYXRlKCkKICAgaWYgZXJyb3JfdGhyZWFkIHRoZW4KICAgICAgY2FsbF9l
cnJvcl9ldmVudChlcnJvcl91cGRhdGUpCiAgIGVsc2UKICAgICAgY2FsbF9wcm90ZWN0ZWQodXNl
cl91cGRhdGUpCiAgIGVuZAplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKICAgaWYgZXJyb3JfdGhyZWFk
IHRoZW4KICAgICAgY2FsbF9lcnJvcl9ldmVudChlcnJvcl9kcmF3KQogICBlbHNlCiAgICAgIGNh
bGxfcHJvdGVjdGVkKHVzZXJfZHJhdykKICAgZW5kCmVuZA==
:: lib/lua-star/.info.pod
--[[pod,created="2026-01-04 08:23:37",modified="2026-01-04 08:44:13"]]
:: lib/lua-state-machine/.info.pod
--[[pod,created="2026-01-04 08:23:37",modified="2026-01-04 08:44:13"]]
:: lib/lua-state-machine/LICENSE
b64$Q29weXJpZ2h0IChjKSAyMDEyIEt5bGUgQ29ucm95CgpQZXJtaXNzaW9uIGlzIGhlcmVieSBn
cmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5Cm9m
IHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlICJT
b2Z0d2FyZSIpLCB0byBkZWFsCmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBp
bmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMKdG8gdXNlLCBjb3B5LCBtb2Rp
ZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbApj
b3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUg
U29mdHdhcmUgaXMKZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcg
Y29uZGl0aW9uczoKClRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Np
b24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbApjb3BpZXMgb3Igc3Vic3RhbnRpYWwg
cG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgoKVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJ
UyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1IKSU1QTElFRCwgSU5D
TFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJ
VFksCkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQu
IElOIE5PIEVWRU5UIFNIQUxMIFRIRQpBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJ
QUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSCkxJQUJJTElUWSwgV0hFVEhFUiBJ
TiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00s
Ck9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1Ig
T1RIRVIgREVBTElOR1MgSU4gVEhFClNPRlRXQVJFLg==
:: lib/lua-state-machine/README.md
b64$THVhIEZpbml0ZSBTdGF0ZSBNYWNoaW5lCj09PT09PT09PT09PT09PT09PT09PT09PQoKVGhp
cyBzdGFuZGFsb25lIGx1YSBtb2R1bGUgcHJvdmlkZXMgYSBmaW5pdGUgc3RhdGUgbWFjaGluZSBm
b3IgeW91ciBwbGVhc3VyZS4KQmFzZWQgKipoZWF2aWx5Kiogb24gSmFrZSBHb3Jkb24ncwpbamF2
YXNjcmlwdC1zdGF0ZS1tYWNoaW5lXShodHRwczovL2dpdGh1Yi5jb20vamFrZXNnb3Jkb24vamF2
YXNjcmlwdC1zdGF0ZS1tYWNoaW5lKS4KCkRvd25sb2FkCj09PT09PT09CgpZb3UgY2FuIGRvd25s
b2FkIFtzdGF0ZW1hY2hpbmUubHVhXShodHRwczovL2dpdGh1Yi5jb20va3lsZWNvbnJveS9sdWEt
c3RhdGUtbWFjaGluZS9yYXcvbWFzdGVyL3N0YXRlbWFjaGluZS5sdWEpLgoKQWx0ZXJuYXRpdmVs
eToKCiAgICBnaXQgY2xvbmUgZ2l0QGdpdGh1Yi5jb206a3lsZWNvbnJveS9sdWEtc3RhdGUtbWFj
aGluZQoKClVzYWdlCj09PT09CgpJbiBpdHMgc2ltcGxlc3QgZm9ybSwgY3JlYXRlIGEgc3RhbmRh
bG9uZSBzdGF0ZSBtYWNoaW5lIHVzaW5nOgoKYGBgbHVhCmxvY2FsIG1hY2hpbmUgPSByZXF1aXJl
KCdzdGF0ZW1hY2hpbmUnKQoKbG9jYWwgZnNtID0gbWFjaGluZS5jcmVhdGUoewogIGluaXRpYWwg
PSAnZ3JlZW4nLAogIGV2ZW50cyA9IHsKICAgIHsgbmFtZSA9ICd3YXJuJywgIGZyb20gPSAnZ3Jl
ZW4nLCAgdG8gPSAneWVsbG93JyB9LAogICAgeyBuYW1lID0gJ3BhbmljJywgZnJvbSA9ICd5ZWxs
b3cnLCB0byA9ICdyZWQnICAgIH0sCiAgICB7IG5hbWUgPSAnY2FsbScsICBmcm9tID0gJ3JlZCcs
ICAgIHRvID0gJ3llbGxvdycgfSwKICAgIHsgbmFtZSA9ICdjbGVhcicsIGZyb20gPSAneWVsbG93
JywgdG8gPSAnZ3JlZW4nICB9Cn19KQpgYGAKCi4uLiB3aWxsIGNyZWF0ZSBhbiBvYmplY3Qgd2l0
aCBhIG1ldGhvZCBmb3IgZWFjaCBldmVudDoKCiAqIGZzbTp3YXJuKCkgIC0gdHJhbnNpdGlvbiBm
cm9tICdncmVlbicgdG8gJ3llbGxvdycKICogZnNtOnBhbmljKCkgLSB0cmFuc2l0aW9uIGZyb20g
J3llbGxvdycgdG8gJ3JlZCcKICogZnNtOmNhbG0oKSAgLSB0cmFuc2l0aW9uIGZyb20gJ3JlZCcg
dG8gJ3llbGxvdycKICogZnNtOmNsZWFyKCkgLSB0cmFuc2l0aW9uIGZyb20gJ3llbGxvdycgdG8g
J2dyZWVuJwoKYWxvbmcgd2l0aCB0aGUgZm9sbG93aW5nIG1lbWJlcnM6CgogKiBmc20uY3VycmVu
dCAgIC0gY29udGFpbnMgdGhlIGN1cnJlbnQgc3RhdGUKICogZnNtLmN1cnJlbnRUcmFuc2l0aW9u
aW5nRXZlbnQgLSBjb250YWlucyB0aGUgY3VycmVudCBldmVudCB0aGF0IGlzIGluIGEgdHJhbnNp
dGlvbi4KICogZnNtOmlzKHMpICAgICAtIHJldHVybiB0cnVlIGlmIHN0YXRlIGBzYCBpcyB0aGUg
Y3VycmVudCBzdGF0ZQogKiBmc206Y2FuKGUpICAgIC0gcmV0dXJuIHRydWUgaWYgZXZlbnQgYGVg
IGNhbiBiZSBmaXJlZCBpbiB0aGUgY3VycmVudCBzdGF0ZQogKiBmc206Y2Fubm90KGUpIC0gcmV0
dXJuIHRydWUgaWYgZXZlbnQgYGVgIGNhbm5vdCBiZSBmaXJlZCBpbiB0aGUgY3VycmVudCBzdGF0
ZQoKTXVsdGlwbGUgJ2Zyb20nIGFuZCAndG8nIHN0YXRlcyBmb3IgYSBzaW5nbGUgZXZlbnQKPT09
PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0KCklmIGFuIGV2
ZW50IGlzIGFsbG93ZWQgKipmcm9tKiogbXVsdGlwbGUgc3RhdGVzLCBhbmQgYWx3YXlzIHRyYW5z
aXRpb25zIHRvIHRoZSBzYW1lCnN0YXRlLCB0aGVuIHNpbXBseSBwcm92aWRlIGFuIGFycmF5IG9m
IHN0YXRlcyBpbiB0aGUgYGZyb21gIGF0dHJpYnV0ZSBvZiBhbiBldmVudC4gSG93ZXZlciwKaWYg
YW4gZXZlbnQgaXMgYWxsb3dlZCBmcm9tIG11bHRpcGxlIHN0YXRlcywgYnV0IHNob3VsZCB0cmFu
c2l0aW9uICoqdG8qKiBhIGRpZmZlcmVudApzdGF0ZSBkZXBlbmRpbmcgb24gdGhlIGN1cnJlbnQg
c3RhdGUsIHRoZW4gcHJvdmlkZSBtdWx0aXBsZSBldmVudCBlbnRyaWVzIHdpdGgKdGhlIHNhbWUg
bmFtZToKCmBgYGx1YQpsb2NhbCBtYWNoaW5lID0gcmVxdWlyZSgnc3RhdGVtYWNoaW5lJykKCmxv
Y2FsIGZzbSA9IG1hY2hpbmUuY3JlYXRlKHsKICBpbml0aWFsID0gJ2h1bmdyeScsCiAgZXZlbnRz
ID0gewogICAgeyBuYW1lID0gJ2VhdCcsICBmcm9tID0gJ2h1bmdyeScsICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICB0byA9ICdzYXRpc2ZpZWQnIH0sCiAgICB7IG5hbWUgPSAnZWF0Jywg
IGZyb20gPSAnc2F0aXNmaWVkJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gJ2Z1
bGwnICAgICAgfSwKICAgIHsgbmFtZSA9ICdlYXQnLCAgZnJvbSA9ICdmdWxsJywgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSAnc2ljaycgICAgICB9LAogICAgeyBuYW1lID0g
J3Jlc3QnLCBmcm9tID0geydodW5ncnknLCAnc2F0aXNmaWVkJywgJ2Z1bGwnLCAnc2ljayd9LCB0
byA9ICdodW5ncnknICAgIH0sCn19KQpgYGAKClRoaXMgZXhhbXBsZSB3aWxsIGNyZWF0ZSBhbiBv
YmplY3Qgd2l0aCAyIGV2ZW50IG1ldGhvZHM6CgogKiBmc206ZWF0KCkKICogZnNtOnJlc3QoKQoK
VGhlIGByZXN0YCBldmVudCB3aWxsIGFsd2F5cyB0cmFuc2l0aW9uIHRvIHRoZSBgaHVuZ3J5YCBz
dGF0ZSwgd2hpbGUgdGhlIGBlYXRgIGV2ZW50CndpbGwgdHJhbnNpdGlvbiB0byBhIHN0YXRlIHRo
YXQgaXMgZGVwZW5kZW50IG9uIHRoZSBjdXJyZW50IHN0YXRlLgoKPj4gTk9URTogVGhlIGByZXN0
YCBldmVudCBjb3VsZCB1c2UgYSB3aWxkY2FyZCAnKicgZm9yIHRoZSAnZnJvbScgc3RhdGUgaWYg
aXQgc2hvdWxkIGJlCmFsbG93ZWQgZnJvbSBhbnkgY3VycmVudCBzdGF0ZS4KCj4_IE5PVEU6IFRo
ZSBgcmVzdGAgZXZlbnQgaW4gdGhlIGFib3ZlIGV4YW1wbGUgY2FuIGFsc28gYmUgc3BlY2lmaWVk
IGFzIG11bHRpcGxlIGV2ZW50cyB3aXRoCnRoZSBzYW1lIG5hbWUgaWYgeW91IHByZWZlciB0aGUg
dmVyYm9zZSBhcHByb2FjaC4KCkNhbGxiYWNrcwo9PT09PT09PT0KCjQgY2FsbGJhY2tzIGFyZSBh
dmFpbGFibGUgaWYgeW91ciBzdGF0ZSBtYWNoaW5lIGhhcyBtZXRob2RzIHVzaW5nIHRoZSBmb2xs
b3dpbmcgbmFtaW5nIGNvbnZlbnRpb25zOgoKICogb25iZWZvcmUqKmV2ZW50KiogLSBmaXJlZCBi
ZWZvcmUgdGhlIGV2ZW50CiAqIG9ubGVhdmUqKnN0YXRlKiogIC0gZmlyZWQgd2hlbiBsZWF2aW5n
IHRoZSBvbGQgc3RhdGUKICogb25lbnRlcioqc3RhdGUqKiAgLSBmaXJlZCB3aGVuIGVudGVyaW5n
IHRoZSBuZXcgc3RhdGUKICogb25hZnRlcioqZXZlbnQqKiAgLSBmaXJlZCBhZnRlciB0aGUgZXZl
bnQKCllvdSBjYW4gYWZmZWN0IHRoZSBldmVudCBpbiAzIHdheXM6CgogKiByZXR1cm4gYGZhbHNl
YCBmcm9tIGFuIGBvbmJlZm9yZWV2ZW50YCBoYW5kbGVyIHRvIGNhbmNlbCB0aGUgZXZlbnQuCiAq
IHJldHVybiBgZmFsc2VgIGZyb20gYW4gYG9ubGVhdmVzdGF0ZWAgaGFuZGxlciB0byBjYW5jZWwg
dGhlIGV2ZW50LgogKiByZXR1cm4gYEFTWU5DYCBmcm9tIGFuIGBvbmxlYXZlc3RhdGVgIG9yIGBv
bmVudGVyc3RhdGVgIGhhbmRsZXIgdG8gcGVyZm9ybSBhbiBhc3luY2hyb25vdXMgc3RhdGUgdHJh
bnNpdGlvbiAoc2VlIG5leHQgc2VjdGlvbikKCkZvciBjb252ZW5pZW5jZSwgdGhlIDIgbW9zdCB1
c2VmdWwgY2FsbGJhY2tzIGNhbiBiZSBzaG9ydGVuZWQ6CgogKiBvbioqZXZlbnQqKiAtIGNvbnZl
bmllbmNlIHNob3J0aGFuZCBmb3Igb25hZnRlcioqZXZlbnQqKgogKiBvbioqc3RhdGUqKiAtIGNv
bnZlbmllbmNlIHNob3J0aGFuZCBmb3Igb25lbnRlcioqc3RhdGUqKgoKSW4gYWRkaXRpb24sIGEg
Z2VuZXJpYyBgb25zdGF0ZWNoYW5nZSgpYCBjYWxsYmFjayBjYW4gYmUgdXNlZCB0byBjYWxsIGEg
c2luZ2xlIGZ1bmN0aW9uIGZvciBfYWxsXyBzdGF0ZSBjaGFuZ2VzOgoKQWxsIGNhbGxiYWNrcyB3
aWxsIGJlIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHM6CgogKiAqKnNlbGYqKgogKiAqKmV2ZW50
KiogbmFtZQogKiAqKmZyb20qKiBzdGF0ZQogKiAqKnRvKiogc3RhdGUKICogXyhmb2xsb3dlZCBi
eSBhbnkgYXJndW1lbnRzIHlvdSBwYXNzZWQgaW50byB0aGUgb3JpZ2luYWwgZXZlbnQgbWV0aG9k
KV8KCkNhbGxiYWNrcyBjYW4gYmUgc3BlY2lmaWVkIHdoZW4gdGhlIHN0YXRlIG1hY2hpbmUgaXMg
Zmlyc3QgY3JlYXRlZDoKCmBgYGx1YQpsb2NhbCBtYWNoaW5lID0gcmVxdWlyZSgnc3RhdGVtYWNo
aW5lJykKCmxvY2FsIGZzbSA9IG1hY2hpbmUuY3JlYXRlKHsKICBpbml0aWFsID0gJ2dyZWVuJywK
ICBldmVudHMgPSB7CiAgICB7IG5hbWUgPSAnd2FybicsICBmcm9tID0gJ2dyZWVuJywgIHRvID0g
J3llbGxvdycgfSwKICAgIHsgbmFtZSA9ICdwYW5pYycsIGZyb20gPSAneWVsbG93JywgdG8gPSAn
cmVkJyAgICB9LAogICAgeyBuYW1lID0gJ2NhbG0nLCAgZnJvbSA9ICdyZWQnLCAgICB0byA9ICd5
ZWxsb3cnIH0sCiAgICB7IG5hbWUgPSAnY2xlYXInLCBmcm9tID0gJ3llbGxvdycsIHRvID0gJ2dy
ZWVuJyAgfQogIH0sCiAgY2FsbGJhY2tzID0gewogICAgb25wYW5pYyA9ICBmdW5jdGlvbihzZWxm
LCBldmVudCwgZnJvbSwgdG8sIG1zZykgcHJpbnQoJ3BhbmljISAnIC4uIG1zZykgICAgZW5kLAog
ICAgb25jbGVhciA9ICBmdW5jdGlvbihzZWxmLCBldmVudCwgZnJvbSwgdG8sIG1zZykgcHJpbnQo
J3RoYW5rcyB0byAnIC4uIG1zZykgZW5kLAogICAgb25ncmVlbiA9ICBmdW5jdGlvbihzZWxmLCBl
dmVudCwgZnJvbSwgdG8pICAgICAgcHJpbnQoJ2dyZWVuIGxpZ2h0JykgICAgICAgZW5kLAogICAg
b255ZWxsb3cgPSBmdW5jdGlvbihzZWxmLCBldmVudCwgZnJvbSwgdG8pICAgICAgcHJpbnQoJ3ll
bGxvdyBsaWdodCcpICAgICAgZW5kLAogICAgb25yZWQgPSAgICBmdW5jdGlvbihzZWxmLCBldmVu
dCwgZnJvbSwgdG8pICAgICAgcHJpbnQoJ3JlZCBsaWdodCcpICAgICAgICAgZW5kLAogIH0KfSkK
CmZzbTp3YXJuKCkKZnNtOnBhbmljKCdraWxsZXIgYmVlcycpCmZzbTpjYWxtKCkKZnNtOmNsZWFy
KCdzZWRhdGl2ZXMgaW4gdGhlIGhvbmV5IHBvdHMnKQouLi4KYGBgCgpBZGRpdGlvbmFsbHksIHRo
ZXkgY2FuIGJlIGFkZGVkIGFuZCByZW1vdmVkIGZyb20gdGhlIHN0YXRlIG1hY2hpbmUgYXQgYW55
IHRpbWU6CgpgYGBsdWEKZnNtLm9uZ3JlZW4gICAgICAgPSBuaWwKZnNtLm9ueWVsbG93ICAgICAg
PSBuaWwKZnNtLm9ucmVkICAgICAgICAgPSBuaWwKZnNtLm9uc3RhdGVjaGFuZ2UgPSBmdW5jdGlv
bihzZWxmLCBldmVudCwgZnJvbSwgdG8pIHByaW50KHRvKSBlbmQKYGBgCgpvcgpgYGBsdWEKZnVu
Y3Rpb24gZnNtOm9uc3RhdGVjaGFuZ2UoZXZlbnQsIGZyb20sIHRvKSBwcmludCh0bykgZW5kCmBg
YAoKQXN5bmNocm9ub3VzIFN0YXRlIFRyYW5zaXRpb25zCj09PT09PT09PT09PT09PT09PT09PT09
PT09PT09PQoKU29tZXRpbWVzLCB5b3UgbmVlZCB0byBleGVjdXRlIHNvbWUgYXN5bmNocm9ub3Vz
IGNvZGUgZHVyaW5nIGEgc3RhdGUgdHJhbnNpdGlvbiBhbmQgZW5zdXJlIHRoZQpuZXcgc3RhdGUg
aXMgbm90IGVudGVyZWQgdW50aWwgeW91ciBjb2RlIGhhcyBjb21wbGV0ZWQuCgpBIGdvb2QgZXhh
bXBsZSBvZiB0aGlzIGlzIHdoZW4geW91IHRyYW5zaXRpb24gb3V0IG9mIGEgYG1lbnVgIHN0YXRl
LCBwZXJoYXBzIHlvdSB3YW50IHRvIGdyYWR1YWxseQpmYWRlIHRoZSBtZW51IGF3YXksIG9yIHNs
aWRlIGl0IG9mZiB0aGUgc2NyZWVuIGFuZCBkb24ndCB3YW50IHRvIHRyYW5zaXRpb24gdG8geW91
ciBgZ2FtZWAgc3RhdGUKdW50aWwgYWZ0ZXIgdGhhdCBhbmltYXRpb24gaGFzIGJlZW4gcGVyZm9y
bWVkLgoKWW91IGNhbiBub3cgcmV0dXJuIGBBU1lOQ2AgZnJvbSB5b3VyIGBvbmxlYXZlc3RhdGVg
IGFuZC9vciBgb25lbnRlcnN0YXRlYCBoYW5kbGVycyBhbmQgdGhlIHN0YXRlIG1hY2hpbmUKd2ls
bCBiZSBfJ3B1dCBvbiBob2xkJ18gdW50aWwgeW91IGFyZSByZWFkeSB0byB0cmlnZ2VyIHRoZSB0
cmFuc2l0aW9uIHVzaW5nIHRoZSBuZXcgYHRyYW5zaXRpb24oZXZlbnROYW1lKWAKbWV0aG9kLgoK
SWYgYW5vdGhlciBldmVudCBpcyB0cmlnZ2VyZWQgZHVyaW5nIGEgc3RhdGUgbWFjaGluZSB0cmFu
c2l0aW9uLCB0aGUgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQgcmVsYXRpdmUgdG8gdGhlCnN0YXRl
IHRoZSBtYWNoaW5lIHdhcyB0cmFuc2l0aW9uaW5nIHRvIG9yIGZyb20uIEFueSBjYWxscyB0byBg
dHJhbnNpdGlvbmAgd2l0aCB0aGUgY2FuY2VsbGVkIGFzeW5jIGV2ZW50IG5hbWUKd2lsbCBiZSBp
bnZhbGlkYXRlZC4KCkR1cmluZyBhIHN0YXRlIGNoYW5nZSwgYGFzeW5jU3RhdGVgIHdpbGwgdHJh
bnNpdGlvbiBmcm9tIGBOT05FYCB0byBgW2V2ZW50XVdhaXRpbmdPbkxlYXZlYCB0byBgW2V2ZW50
XVdhaXRpbmdPbkVudGVyYCwKbG9vcGluZyBiYWNrIHRvIGBOT05FYC4gSWYgdGhlIHN0YXRlIG1h
Y2hpbmUgaXMgcHV0IG9uIGhvbGQsIGBhc3luY1N0YXRlYCB3aWxsIHBhdXNlIGRlcGVuZGluZyBv
biB3aGljaCBoYW5kbGVyCnlvdSByZXR1cm5lZCBgQVNZTkNgIGZyb20uCgpFeGFtcGxlIG9mIGFz
eW5jaHJvbm91cyB0cmFuc2l0aW9uczoKCmBgYGx1YQpsb2NhbCBtYWNoaW5lID0gcmVxdWlyZSgn
c3RhdGVtYWNoaW5lJykKbG9jYWwgbWFuYWdlciA9IHJlcXVpcmUoJ1NjZW5lTWFuYWdlcicpCgps
b2NhbCBmc20gPSBtYWNoaW5lLmNyZWF0ZSh7CgogIGluaXRpYWwgPSAnbWVudScsCgogIGV2ZW50
cyA9IHsKICAgIHsgbmFtZSA9ICdwbGF5JywgZnJvbSA9ICdtZW51JywgdG8gPSAnZ2FtZScgfSwK
ICAgIHsgbmFtZSA9ICdxdWl0JywgZnJvbSA9ICdnYW1lJywgdG8gPSAnbWVudScgfQogIH0sCgog
IGNhbGxiYWNrcyA9IHsKCiAgICBvbmVudGVybWVudSA9IGZ1bmN0aW9uKCkgbWFuYWdlci5zd2l0
Y2goJ21lbnUnKSBlbmQsCiAgICBvbmVudGVyZ2FtZSA9IGZ1bmN0aW9uKCkgbWFuYWdlci5zd2l0
Y2goJ2dhbWUnKSBlbmQsCgogICAgb25sZWF2ZW1lbnUgPSBmdW5jdGlvbihmc20sIG5hbWUsIGZy
b20sIHRvKQogICAgICBtYW5hZ2VyLmZhZGUoJ2Zhc3QnLCBmdW5jdGlvbigpCiAgICAgICAgZnNt
OnRyYW5zaXRpb24obmFtZSkKICAgICAgZW5kKQogICAgICByZXR1cm4gZnNtLkFTWU5DIC0tIHRl
bGwgbWFjaGluZSB0byBkZWZlciBuZXh0IHN0YXRlIHVudGlsIHdlIGNhbGwgdHJhbnNpdGlvbiAo
aW4gZmFkZU91dCBjYWxsYmFjayBhYm92ZSkKICAgIGVuZCwKCiAgICBvbmxlYXZlZ2FtZSA9IGZ1
bmN0aW9uKGZzbSwgbmFtZSwgZnJvbSwgdG8pCiAgICAgIG1hbmFnZXIuc2xpZGUoJ3Nsb3cnLCBm
dW5jdGlvbigpCiAgICAgICAgZnNtOnRyYW5zaXRpb24obmFtZSkKICAgICAgZW5kKQogICAgICBy
ZXR1cm4gZnNtLkFTWU5DIC0tIHRlbGwgbWFjaGluZSB0byBkZWZlciBuZXh0IHN0YXRlIHVudGls
IHdlIGNhbGwgdHJhbnNpdGlvbiAoaW4gc2xpZGVEb3duIGNhbGxiYWNrIGFib3ZlKQogICAgZW5k
LAogIH0KfSkKYGBgCgpJZiB5b3UgZGVjaWRlIHRvIGNhbmNlbCB0aGUgYXN5bmMgZXZlbnQsIHlv
dSBjYW4gY2FsbCBgZnNtLmNhbmNlbFRyYW5zaXRpb24oZXZlbnROYW1lKWAKCkluaXRpYWxpemF0
aW9uIE9wdGlvbnMKPT09PT09PT09PT09PT09PT09PT09PQoKSG93IHRoZSBzdGF0ZSBtYWNoaW5l
IHNob3VsZCBpbml0aWFsaXplIGNhbiBkZXBlbmQgb24geW91ciBhcHBsaWNhdGlvbiByZXF1aXJl
bWVudHMsIHNvCnRoZSBsaWJyYXJ5IHByb3ZpZGVzIGEgbnVtYmVyIG9mIHNpbXBsZSBvcHRpb25z
LgoKQnkgZGVmYXVsdCwgaWYgeW91IGRvbnQgc3BlY2lmeSBhbnkgaW5pdGlhbCBzdGF0ZSwgdGhl
IHN0YXRlIG1hY2hpbmUgd2lsbCBiZSBpbiB0aGUgYCdub25lJ2AKc3RhdGUgYW5kIHlvdSB3b3Vs
ZCBuZWVkIHRvIHByb3ZpZGUgYW4gZXZlbnQgdG8gdGFrZSBpdCBvdXQgb2YgdGhpcyBzdGF0ZToK
CmBgYGx1YQpsb2NhbCBtYWNoaW5lID0gcmVxdWlyZSgnc3RhdGVtYWNoaW5lJykKCmxvY2FsIGZz
bSA9IG1hY2hpbmUuY3JlYXRlKHsKICBldmVudHMgPSB7CiAgICB7IG5hbWUgPSAnc3RhcnR1cCcs
IGZyb20gPSAnbm9uZScsICB0byA9ICdncmVlbicgfSwKICAgIHsgbmFtZSA9ICdwYW5pYycsICAg
ZnJvbSA9ICdncmVlbicsIHRvID0gJ3JlZCcgICB9LAogICAgeyBuYW1lID0gJ2NhbG0nLCAgICBm
cm9tID0gJ3JlZCcsICAgdG8gPSAnZ3JlZW4nIH0sCn19KQoKcHJpbnQoZnNtLmN1cnJlbnQpIC0t
ICJub25lIgpmc206c3RhcnR1cCgpCnByaW50KGZzbS5jdXJyZW50KSAtLSAiZ3JlZW4iCmBgYAoK
SWYgeW91IHNwZWNpZnkgdGhlIG5hbWUgb2YgeW91ciBpbml0aWFsIGV2ZW50IChhcyBpbiBhbGwg
dGhlIGVhcmxpZXIgZXhhbXBsZXMpLCB0aGVuIGFuCmltcGxpY2l0IGBzdGFydHVwYCBldmVudCB3
aWxsIGJlIGNyZWF0ZWQgZm9yIHlvdSBhbmQgZmlyZWQgd2hlbiB0aGUgc3RhdGUgbWFjaGluZSBp
cyBjb25zdHJ1Y3RlZC4KCmBgYGx1YQpsb2NhbCBtYWNoaW5lID0gcmVxdWlyZSgnc3RhdGVtYWNo
aW5lJykKCmxvY2FsIGZzbSA9IG1hY2hpbmUuY3JlYXRlKHsKICBpbml0YWwgPSAnZ3JlZW4nLAog
IGV2ZW50cyA9IHsKICAgIHsgbmFtZSA9ICdwYW5pYycsICAgZnJvbSA9ICdncmVlbicsIHRvID0g
J3JlZCcgICB9LAogICAgeyBuYW1lID0gJ2NhbG0nLCAgICBmcm9tID0gJ3JlZCcsICAgdG8gPSAn
Z3JlZW4nIH0sCn19KQpwcmludChmc20uY3VycmVudCkgLS0gImdyZWVuIgpgYGA=
:: lib/lua-state-machine/spec/.info.pod
--[[pod,created="2026-01-04 08:23:37",modified="2026-01-04 08:44:13"]]
:: lib/lua-state-machine/statemachine-1.0.0-1.rockspec
b64$cGFja2FnZSA9ICJzdGF0ZW1hY2hpbmUiCnZlcnNpb24gPSAiMS4wLjAtMSIKc291cmNlID0g
ewogIHVybCA9ICJodHRwczovL2dpdGh1Yi5jb20va3lsZWNvbnJveS9sdWEtc3RhdGUtbWFjaGlu
ZS9hcmNoaXZlL3YxLjAuMC50YXIuZ3oiLAogIGRpciA9ICJsdWEtc3RhdGUtbWFjaGluZS0xLjAu
MCIKfQpkZXNjcmlwdGlvbiA9IHsKICAgc3VtbWFyeSA9ICJBIGZpbml0ZSBzdGF0ZSBtYWNoaW5l
IG1pY3JvIGZyYW1ld29yayIsCiAgIGRldGFpbGVkID0gW1sKICAgICAgVGhpcyBzdGFuZGFsb25l
IG1vZHVsZSBwcm92aWRlcyBhIGZpbml0ZSBzdGF0ZSBtYWNoaW5lIGZvciB5b3VyIHBsZWFzdXJl
LiAKICAgXV0sCiAgIGhvbWVwYWdlID0gImh0dHBzOi8vZ2l0aHViLmNvbS9reWxlY29ucm95L2x1
YS1zdGF0ZS1tYWNoaW5lIiwKICAgbGljZW5zZSA9ICJNSVQvWDExIgp9CmRlcGVuZGVuY2llcyA9
IHsKICAgImx1YSA_PSA1LjEiCn0KYnVpbGQgPSB7CiAgdHlwZSA9ICJidWlsdGluIiwKICBtb2R1
bGVzID0gewogICAgWyJzdGF0ZW1hY2hpbmUiXSA9ICJzdGF0ZW1hY2hpbmUubHVhIgogIH0sCiAg
Y29weV9kaXJlY3RvcmllcyA9IHt9Cn0K
:: lib/lua-state-machine/stoplight.dot.ref
b64$ZGlncmFwaCB7CmdyZWVuIC0_IHllbGxvdyBbbGFiZWw9d2Fybl07CnllbGxvdyAtPiByZWQg
W2xhYmVsPXBhbmljXTsKcmVkIC0_IHllbGxvdyBbbGFiZWw9Y2FsbV07CnllbGxvdyAtPiBncmVl
biBbbGFiZWw9Y2xlYXJdOwp9
:: lib/middleclass.lua
b64$bG9jYWwgbWlkZGxlY2xhc3MgPSB7CiAgIF9WRVJTSU9OICAgICA9ICJtaWRkbGVjbGFzcyB2
NC4xLjEiLAogICBfREVTQ1JJUFRJT04gPSAiT2JqZWN0IE9yaWVudGF0aW9uIGZvciBMdWEiLAog
ICBfVVJMICAgICAgICAgPSAiaHR0cHM6Ly9naXRodWIuY29tL2tpa2l0by9taWRkbGVjbGFzcyIs
CiAgIF9MSUNFTlNFICAgICA9IFtbCiAgICAgIE1JVCBMSUNFTlNFCgogICAgICBDb3B5cmlnaHQg
KGMpIDIwMTEgRW5yaXF1ZSBHYXJjw61hIENvdGEKCiAgICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5
IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCiAgICAg
IGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVz
ICh0aGUKICAgICAgIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQg
cmVzdHJpY3Rpb24sIGluY2x1ZGluZwogICAgICB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0
cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCiAgICAgIGRpc3RyaWJ1dGUs
IHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0bwog
ICAgICBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8g
ZG8gc28sIHN1YmplY3QgdG8KICAgICAgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOgoKICAgICAg
VGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hh
bGwgYmUgaW5jbHVkZWQKICAgICAgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9u
cyBvZiB0aGUgU29mdHdhcmUuCgogICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElT
IiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwogICAgICBPUiBJTVBMSUVE
LCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCiAgICAgIE1F
UkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklO
RlJJTkdFTUVOVC4KICAgICAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJ
R0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkKICAgICAgQ0xBSU0sIERBTUFHRVMgT1IgT1RI
RVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwKICAgICAgVE9S
VCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lU
SCBUSEUKICAgICAgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUg
U09GVFdBUkUuCiAgICBdXQp9Cgpsb2NhbCBmdW5jdGlvbiBfY3JlYXRlSW5kZXhXcmFwcGVyKGFD
bGFzcywgZikKICAgaWYgZiA9PSBuaWwgdGhlbgogICAgICByZXR1cm4gYUNsYXNzLl9faW5zdGFu
Y2VEaWN0CiAgIGVsc2VpZiB0eXBlKGYpID09ICJmdW5jdGlvbiIgdGhlbgogICAgICByZXR1cm4g
ZnVuY3Rpb24oc2VsZiwgbmFtZSkKICAgICAgICAgbG9jYWwgdmFsdWUgPSBhQ2xhc3MuX19pbnN0
YW5jZURpY3RbbmFtZV0KCiAgICAgICAgIGlmIHZhbHVlIH49IG5pbCB0aGVuCiAgICAgICAgICAg
IHJldHVybiB2YWx1ZQogICAgICAgICBlbHNlCiAgICAgICAgICAgIHJldHVybiAoZihzZWxmLCBu
YW1lKSkKICAgICAgICAgZW5kCiAgICAgIGVuZAogICBlbHNlIC0tIGlmICB0eXBlKGYpID09ICJ0
YWJsZSIgdGhlbgogICAgICByZXR1cm4gZnVuY3Rpb24oc2VsZiwgbmFtZSkKICAgICAgICAgbG9j
YWwgdmFsdWUgPSBhQ2xhc3MuX19pbnN0YW5jZURpY3RbbmFtZV0KCiAgICAgICAgIGlmIHZhbHVl
IH49IG5pbCB0aGVuCiAgICAgICAgICAgIHJldHVybiB2YWx1ZQogICAgICAgICBlbHNlCiAgICAg
ICAgICAgIHJldHVybiBmW25hbWVdCiAgICAgICAgIGVuZAogICAgICBlbmQKICAgZW5kCmVuZAoK
bG9jYWwgZnVuY3Rpb24gX3Byb3BhZ2F0ZUluc3RhbmNlTWV0aG9kKGFDbGFzcywgbmFtZSwgZikK
ICAgZiA9IG5hbWUgPT0gIl9faW5kZXgiIGFuZCBfY3JlYXRlSW5kZXhXcmFwcGVyKGFDbGFzcywg
Zikgb3IgZgogICBhQ2xhc3MuX19pbnN0YW5jZURpY3RbbmFtZV0gPSBmCgogICBmb3Igc3ViY2xh
c3MgaW4gcGFpcnMoYUNsYXNzLnN1YmNsYXNzZXMpIGRvCiAgICAgIGlmIHJhd2dldChzdWJjbGFz
cy5fX2RlY2xhcmVkTWV0aG9kcywgbmFtZSkgPT0gbmlsIHRoZW4KICAgICAgICAgX3Byb3BhZ2F0
ZUluc3RhbmNlTWV0aG9kKHN1YmNsYXNzLCBuYW1lLCBmKQogICAgICBlbmQKICAgZW5kCmVuZAoK
bG9jYWwgZnVuY3Rpb24gX2RlY2xhcmVJbnN0YW5jZU1ldGhvZChhQ2xhc3MsIG5hbWUsIGYpCiAg
IGFDbGFzcy5fX2RlY2xhcmVkTWV0aG9kc1tuYW1lXSA9IGYKCiAgIGlmIGYgPT0gbmlsIGFuZCBh
Q2xhc3Muc3VwZXIgdGhlbgogICAgICBmID0gYUNsYXNzLnN1cGVyLl9faW5zdGFuY2VEaWN0W25h
bWVdCiAgIGVuZAoKICAgX3Byb3BhZ2F0ZUluc3RhbmNlTWV0aG9kKGFDbGFzcywgbmFtZSwgZikK
ZW5kCgpsb2NhbCBmdW5jdGlvbiBfdG9zdHJpbmcoc2VsZikgcmV0dXJuICJjbGFzcyAiLi5zZWxm
Lm5hbWUgZW5kCmxvY2FsIGZ1bmN0aW9uIF9jYWxsKHNlbGYsIC4uLikgcmV0dXJuIHNlbGY6bmV3
KC4uLikgZW5kCgpsb2NhbCBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MobmFtZSwgc3VwZXIpCiAgIGxv
Y2FsIGRpY3QgPSB7fQogICBkaWN0Ll9faW5kZXggPSBkaWN0CgogICBsb2NhbCBhQ2xhc3MgPSB7
CiAgICAgIG5hbWUgPSBuYW1lLAogICAgICBzdXBlciA9IHN1cGVyLAogICAgICBzdGF0aWMgPSB7
fSwKICAgICAgX19pbnN0YW5jZURpY3QgPSBkaWN0LAogICAgICBfX2RlY2xhcmVkTWV0aG9kcyA9
IHt9LAogICAgICBzdWJjbGFzc2VzID0gc2V0bWV0YXRhYmxlKHt9LCB7X19tb2RlID0gImsifSkK
ICAgfQoKICAgaWYgc3VwZXIgdGhlbgogICAgICBzZXRtZXRhdGFibGUoYUNsYXNzLnN0YXRpYywg
ewogICAgICAgICBfX2luZGV4ID0gZnVuY3Rpb24oXywgaykKICAgICAgICAgICAgbG9jYWwgcmVz
dWx0ID0gcmF3Z2V0KGRpY3QsIGspCiAgICAgICAgICAgIGlmIHJlc3VsdCA9PSBuaWwgdGhlbgog
ICAgICAgICAgICAgICByZXR1cm4gc3VwZXIuc3RhdGljW2tdCiAgICAgICAgICAgIGVuZAogICAg
ICAgICAgICByZXR1cm4gcmVzdWx0CiAgICAgICAgIGVuZAogICAgICB9KQogICBlbHNlCiAgICAg
IHNldG1ldGF0YWJsZShhQ2xhc3Muc3RhdGljLCB7X19pbmRleCA9IGZ1bmN0aW9uKF8sIGspIHJl
dHVybiByYXdnZXQoZGljdCwgaykgZW5kfSkKICAgZW5kCgogICBzZXRtZXRhdGFibGUoYUNsYXNz
LCB7CiAgICAgIF9faW5kZXggPSBhQ2xhc3Muc3RhdGljLAogICAgICBfX3Rvc3RyaW5nID0gX3Rv
c3RyaW5nLAogICAgICBfX2NhbGwgPSBfY2FsbCwKICAgICAgX19uZXdpbmRleCA9IF9kZWNsYXJl
SW5zdGFuY2VNZXRob2QKICAgfSkKCiAgIHJldHVybiBhQ2xhc3MKZW5kCgpsb2NhbCBmdW5jdGlv
biBfaW5jbHVkZU1peGluKGFDbGFzcywgbWl4aW4pCiAgIGFzc2VydCh0eXBlKG1peGluKSA9PSAi
dGFibGUiLCAibWl4aW4gbXVzdCBiZSBhIHRhYmxlIikKCiAgIGZvciBuYW1lLCBtZXRob2QgaW4g
cGFpcnMobWl4aW4pIGRvCiAgICAgIGlmIG5hbWUgfj0gImluY2x1ZGVkIiBhbmQgbmFtZSB_PSAi
c3RhdGljIiB0aGVuIGFDbGFzc1tuYW1lXSA9IG1ldGhvZCBlbmQKICAgZW5kCgogICBmb3IgbmFt
ZSwgbWV0aG9kIGluIHBhaXJzKG1peGluLnN0YXRpYyBvciB7fSkgZG8KICAgICAgYUNsYXNzLnN0
YXRpY1tuYW1lXSA9IG1ldGhvZAogICBlbmQKCiAgIGlmIHR5cGUobWl4aW4uaW5jbHVkZWQpID09
ICJmdW5jdGlvbiIgdGhlbiBtaXhpbjppbmNsdWRlZChhQ2xhc3MpIGVuZAogICByZXR1cm4gYUNs
YXNzCmVuZAoKbG9jYWwgRGVmYXVsdE1peGluID0gewogICBfX3Rvc3RyaW5nICAgPSBmdW5jdGlv
bihzZWxmKSByZXR1cm4gImluc3RhbmNlIG9mICIuLnRvc3RyaW5nKHNlbGYuY2xhc3MpIGVuZCwK
CiAgIGluaXRpYWxpemUgICA9IGZ1bmN0aW9uKHNlbGYsIC4uLikgZW5kLAoKICAgaXNJbnN0YW5j
ZU9mID0gZnVuY3Rpb24oc2VsZiwgYUNsYXNzKQogICAgICByZXR1cm4gdHlwZShhQ2xhc3MpID09
ICJ0YWJsZSIKICAgICAgICAgYW5kIHR5cGUoc2VsZikgPT0gInRhYmxlIgogICAgICAgICBhbmQg
KHNlbGYuY2xhc3MgPT0gYUNsYXNzCiAgICAgICAgICAgIG9yIHR5cGUoc2VsZi5jbGFzcykgPT0g
InRhYmxlIgogICAgICAgICAgICBhbmQgdHlwZShzZWxmLmNsYXNzLmlzU3ViY2xhc3NPZikgPT0g
ImZ1bmN0aW9uIgogICAgICAgICAgICBhbmQgc2VsZi5jbGFzczppc1N1YmNsYXNzT2YoYUNsYXNz
KSkKICAgZW5kLAoKICAgc3RhdGljICAgICAgID0gewogICAgICBhbGxvY2F0ZSA9IGZ1bmN0aW9u
KHNlbGYpCiAgICAgICAgIGFzc2VydCh0eXBlKHNlbGYpID09ICJ0YWJsZSIsICJNYWtlIHN1cmUg
dGhhdCB5b3UgYXJlIHVzaW5nICdDbGFzczphbGxvY2F0ZScgaW5zdGVhZCBvZiAnQ2xhc3MuYWxs
b2NhdGUnIikKICAgICAgICAgcmV0dXJuIHNldG1ldGF0YWJsZSh7Y2xhc3MgPSBzZWxmfSwgc2Vs
Zi5fX2luc3RhbmNlRGljdCkKICAgICAgZW5kLAoKICAgICAgbmV3ID0gZnVuY3Rpb24oc2VsZiwg
Li4uKQogICAgICAgICBhc3NlcnQodHlwZShzZWxmKSA9PSAidGFibGUiLCAiTWFrZSBzdXJlIHRo
YXQgeW91IGFyZSB1c2luZyAnQ2xhc3M6bmV3JyBpbnN0ZWFkIG9mICdDbGFzcy5uZXcnIikKICAg
ICAgICAgbG9jYWwgaW5zdGFuY2UgPSBzZWxmOmFsbG9jYXRlKCkKICAgICAgICAgaW5zdGFuY2U6
aW5pdGlhbGl6ZSguLi4pCiAgICAgICAgIHJldHVybiBpbnN0YW5jZQogICAgICBlbmQsCgogICAg
ICBzdWJjbGFzcyA9IGZ1bmN0aW9uKHNlbGYsIG5hbWUpCiAgICAgICAgIGFzc2VydCh0eXBlKHNl
bGYpID09ICJ0YWJsZSIsICJNYWtlIHN1cmUgdGhhdCB5b3UgYXJlIHVzaW5nICdDbGFzczpzdWJj
bGFzcycgaW5zdGVhZCBvZiAnQ2xhc3Muc3ViY2xhc3MnIikKICAgICAgICAgYXNzZXJ0KHR5cGUo
bmFtZSkgPT0gInN0cmluZyIsICJZb3UgbXVzdCBwcm92aWRlIGEgbmFtZShzdHJpbmcpIGZvciB5
b3VyIGNsYXNzIikKCiAgICAgICAgIGxvY2FsIHN1YmNsYXNzID0gX2NyZWF0ZUNsYXNzKG5hbWUs
IHNlbGYpCgogICAgICAgICBmb3IgbWV0aG9kTmFtZSwgZiBpbiBwYWlycyhzZWxmLl9faW5zdGFu
Y2VEaWN0KSBkbwogICAgICAgICAgICBpZiBub3QgKG1ldGhvZE5hbWUgPT0gIl9faW5kZXgiIGFu
ZCB0eXBlKGYpID09ICJ0YWJsZSIpIHRoZW4KICAgICAgICAgICAgICAgX3Byb3BhZ2F0ZUluc3Rh
bmNlTWV0aG9kKHN1YmNsYXNzLCBtZXRob2ROYW1lLCBmKQogICAgICAgICAgICBlbmQKICAgICAg
ICAgZW5kCiAgICAgICAgIHN1YmNsYXNzLmluaXRpYWxpemUgPSBmdW5jdGlvbihpbnN0YW5jZSwg
Li4uKSByZXR1cm4gc2VsZi5pbml0aWFsaXplKGluc3RhbmNlLCAuLi4pIGVuZAoKICAgICAgICAg
c2VsZi5zdWJjbGFzc2VzW3N1YmNsYXNzXSA9IHRydWUKICAgICAgICAgc2VsZjpzdWJjbGFzc2Vk
KHN1YmNsYXNzKQoKICAgICAgICAgcmV0dXJuIHN1YmNsYXNzCiAgICAgIGVuZCwKCiAgICAgIHN1
YmNsYXNzZWQgPSBmdW5jdGlvbihzZWxmLCBvdGhlcikgZW5kLAoKICAgICAgaXNTdWJjbGFzc09m
ID0gZnVuY3Rpb24oc2VsZiwgb3RoZXIpCiAgICAgICAgIHJldHVybiB0eXBlKG90aGVyKSA9PSAi
dGFibGUiIGFuZAogICAgICAgICAgICB0eXBlKHNlbGYuc3VwZXIpID09ICJ0YWJsZSIgYW5kCiAg
ICAgICAgICAgIChzZWxmLnN1cGVyID09IG90aGVyIG9yIHNlbGYuc3VwZXI6aXNTdWJjbGFzc09m
KG90aGVyKSkKICAgICAgZW5kLAoKICAgICAgaW5jbHVkZSA9IGZ1bmN0aW9uKHNlbGYsIC4uLikK
ICAgICAgICAgYXNzZXJ0KHR5cGUoc2VsZikgPT0gInRhYmxlIiwgIk1ha2Ugc3VyZSB5b3UgdGhh
dCB5b3UgYXJlIHVzaW5nICdDbGFzczppbmNsdWRlJyBpbnN0ZWFkIG9mICdDbGFzcy5pbmNsdWRl
JyIpCiAgICAgICAgIGZvciBfLCBtaXhpbiBpbiBpcGFpcnMoey4uLn0pIGRvIF9pbmNsdWRlTWl4
aW4oc2VsZiwgbWl4aW4pIGVuZAogICAgICAgICByZXR1cm4gc2VsZgogICAgICBlbmQKICAgfQp9
CgpmdW5jdGlvbiBtaWRkbGVjbGFzcy5jbGFzcyhuYW1lLCBzdXBlcikKICAgYXNzZXJ0KHR5cGUo
bmFtZSkgPT0gInN0cmluZyIsICJBIG5hbWUgKHN0cmluZykgaXMgbmVlZGVkIGZvciB0aGUgbmV3
IGNsYXNzIikKICAgcmV0dXJuIHN1cGVyIGFuZCBzdXBlcjpzdWJjbGFzcyhuYW1lKSBvciBfaW5j
bHVkZU1peGluKF9jcmVhdGVDbGFzcyhuYW1lKSwgRGVmYXVsdE1peGluKQplbmQKCnNldG1ldGF0
YWJsZShtaWRkbGVjbGFzcywge19fY2FsbCA9IGZ1bmN0aW9uKF8sIC4uLikgcmV0dXJuIG1pZGRs
ZWNsYXNzLmNsYXNzKC4uLikgZW5kfSkKCnJldHVybiBtaWRkbGVjbGFzcw==
:: lib/stateful.lua
b64$LS0tIEBzY3JpcHQgc3RhdGVmdWwubHVhCmxvY2FsIFN0YXRlZnVsID0gewogICBfVkVSU0lP
TiAgICAgPSAiU3RhdGVmdWwgMS4wLjUgKDIwMTctMDgpIiwKICAgX0RFU0NSSVBUSU9OID0gIlN0
YXRlZnVsIGNsYXNzZXMgZm9yIG1pZGRsZWNsYXNzIiwKICAgX1VSTCAgICAgICAgID0gImh0dHBz
Oi8vZ2l0aHViLmNvbS9raWtpdG8vc3RhdGVmdWwubHVhIiwKICAgX0xJQ0VOU0UgICAgID0gW1sK
ICBNSVQgTElDRU5TRQoKICBDb3B5cmlnaHQgKGMpIDIwMTcgRW5yaXF1ZSBHYXJjw61hIENvdGEK
CiAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBw
ZXJzb24gb2J0YWluaW5nIGEKICBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQg
ZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCiAgIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNv
ZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwogIHdpdGhvdXQgbGltaXRhdGlv
biB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKICBkaXN0
cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBh
bmQgdG8KICBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQg
dG8gZG8gc28sIHN1YmplY3QgdG8KICAgIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczoKCiAgICBU
aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFs
bCBiZSBpbmNsdWRlZAogICAgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBv
ZiB0aGUgU29mdHdhcmUuCgogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJ
VEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKICAgIE9SIElNUExJRUQsIElOQ0xV
RElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKICAgIE1FUkNIQU5UQUJJ
TElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVO
VC4KICAgIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJT
IEJFIExJQUJMRSBGT1IgQU5ZCiAgICBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFks
IFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULAogICAgVE9SVCBPUiBPVEhFUldJU0Us
IEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUKICAgIFNPRlRX
QVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgogICAgXV0K
fQoKLS0gcmVxdWlyZXMgbWlkZGxlY2xhc3MgPjIuMApTdGF0ZWZ1bC5zdGF0aWMgPSB7fQoKbG9j
YWwgX2NhbGxiYWNrcyA9IHsKICAgZW50ZXJlZFN0YXRlID0gMSwKICAgZXhpdGVkU3RhdGUgPSAx
LAogICBwdXNoZWRTdGF0ZSA9IDEsCiAgIHBvcHBlZFN0YXRlID0gMSwKICAgcGF1c2VkU3RhdGUg
PSAxLAogICBjb250aW51ZWRTdGF0ZSA9IDEKfQoKbG9jYWwgX0Jhc2VTdGF0ZSA9IHt9Cgpsb2Nh
bCBmdW5jdGlvbiBfYWRkU3RhdGVzVG9DbGFzcyhrbGFzcywgc3VwZXJTdGF0ZXMpCiAgIGtsYXNz
LnN0YXRpYy5zdGF0ZXMgPSB7fQogICBmb3Igc3RhdGVOYW1lLCBzdGF0ZSBpbiBwYWlycyhzdXBl
clN0YXRlcyBvciB7fSkgZG8KICAgICAga2xhc3M6YWRkU3RhdGUoc3RhdGVOYW1lLCBzdGF0ZSkK
ICAgZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24gX2dldFN0YXRlZnVsTWV0aG9kKGluc3RhbmNlLCBu
YW1lKQogICBpZiBub3QgX2NhbGxiYWNrc1tuYW1lXSB0aGVuCiAgICAgIGxvY2FsIHN0YWNrID0g
cmF3Z2V0KGluc3RhbmNlLCAiX19zdGF0ZVN0YWNrIikKICAgICAgaWYgbm90IHN0YWNrIHRoZW4g
cmV0dXJuIGVuZAogICAgICBmb3IgaSA9ICNzdGFjaywgMSwgLTEgZG8KICAgICAgICAgaWYgc3Rh
Y2tbaV1bbmFtZV0gdGhlbiByZXR1cm4gc3RhY2tbaV1bbmFtZV0gZW5kCiAgICAgIGVuZAogICBl
bmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBfZ2V0TmV3SW5zdGFuY2VJbmRleChwcmV2SW5kZXgpCiAg
IGlmIHR5cGUocHJldkluZGV4KSA9PSAiZnVuY3Rpb24iIHRoZW4KICAgICAgcmV0dXJuIGZ1bmN0
aW9uKGluc3RhbmNlLCBuYW1lKSByZXR1cm4gX2dldFN0YXRlZnVsTWV0aG9kKGluc3RhbmNlLCBu
YW1lKSBvciBwcmV2SW5kZXgoaW5zdGFuY2UsIG5hbWUpIGVuZAogICBlbmQKICAgcmV0dXJuIGZ1
bmN0aW9uKGluc3RhbmNlLCBuYW1lKSByZXR1cm4gX2dldFN0YXRlZnVsTWV0aG9kKGluc3RhbmNl
LCBuYW1lKSBvciBwcmV2SW5kZXhbbmFtZV0gZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24gX2dldE5l
d0FsbG9jYXRlTWV0aG9kKG9sZEFsbG9jYXRlTWV0aG9kKQogICByZXR1cm4gZnVuY3Rpb24oa2xh
c3MsIC4uLikKICAgICAgbG9jYWwgaW5zdGFuY2UgPSBvbGRBbGxvY2F0ZU1ldGhvZChrbGFzcywg
Li4uKQogICAgICBpbnN0YW5jZS5fX3N0YXRlU3RhY2sgPSB7fQogICAgICByZXR1cm4gaW5zdGFu
Y2UKICAgZW5kCmVuZAoKbG9jYWwgZnVuY3Rpb24gX21vZGlmeUluc3RhbmNlSW5kZXgoa2xhc3Mp
CiAgIGtsYXNzLl9faW5zdGFuY2VEaWN0Ll9faW5kZXggPSBfZ2V0TmV3SW5zdGFuY2VJbmRleChr
bGFzcy5fX2luc3RhbmNlRGljdC5fX2luZGV4KQplbmQKCmxvY2FsIGZ1bmN0aW9uIF9nZXROZXdT
dWJjbGFzc01ldGhvZChwcmV2U3ViY2xhc3MpCiAgIHJldHVybiBmdW5jdGlvbihrbGFzcywgbmFt
ZSkKICAgICAgbG9jYWwgc3ViY2xhc3MgPSBwcmV2U3ViY2xhc3Moa2xhc3MsIG5hbWUpCiAgICAg
IF9hZGRTdGF0ZXNUb0NsYXNzKHN1YmNsYXNzLCBrbGFzcy5zdGF0ZXMpCiAgICAgIF9tb2RpZnlJ
bnN0YW5jZUluZGV4KHN1YmNsYXNzKQogICAgICByZXR1cm4gc3ViY2xhc3MKICAgZW5kCmVuZAoK
bG9jYWwgZnVuY3Rpb24gX21vZGlmeVN1YmNsYXNzTWV0aG9kKGtsYXNzKQogICBrbGFzcy5zdGF0
aWMuc3ViY2xhc3MgPSBfZ2V0TmV3U3ViY2xhc3NNZXRob2Qoa2xhc3Muc3RhdGljLnN1YmNsYXNz
KQplbmQKCmxvY2FsIGZ1bmN0aW9uIF9tb2RpZnlBbGxvY2F0ZU1ldGhvZChrbGFzcykKICAga2xh
c3Muc3RhdGljLmFsbG9jYXRlID0gX2dldE5ld0FsbG9jYXRlTWV0aG9kKGtsYXNzLnN0YXRpYy5h
bGxvY2F0ZSkKZW5kCgpsb2NhbCBmdW5jdGlvbiBfYXNzZXJ0VHlwZSh2YWwsIG5hbWUsIGV4cGVj
dGVkX3R5cGUsIHR5cGVfdG9fcykKICAgaWYgdHlwZSh2YWwpIH49IGV4cGVjdGVkX3R5cGUgdGhl
bgogICAgICBlcnJvcigiRXhwZWN0ZWQgIi4ubmFtZS4uIiB0byBiZSBvZiB0eXBlICIuLgogICAg
ICAgICAodHlwZV90b19zIG9yIGV4cGVjdGVkX3R5cGUpLi4iLiBXYXMgIi4uCiAgICAgICAgIHRv
c3RyaW5nKHZhbCkuLiIoIi4udHlwZSh2YWwpLi4iKSIpCiAgIGVuZAplbmQKCmxvY2FsIGZ1bmN0
aW9uIF9hc3NlcnRJbmV4aXN0aW5nU3RhdGUoa2xhc3MsIHN0YXRlTmFtZSkKICAgaWYga2xhc3Mu
c3RhdGVzW3N0YXRlTmFtZV0gfj0gbmlsIHRoZW4KICAgICAgZXJyb3IoIlN0YXRlICIuLnRvc3Ry
aW5nKHN0YXRlTmFtZSkuLiIgYWxyZWFkeSBleGlzdHMgb24gIi4udG9zdHJpbmcoa2xhc3MpKQog
ICBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBfYXNzZXJ0RXhpc3RpbmdTdGF0ZShzZWxmLCBzdGF0
ZSwgc3RhdGVOYW1lKQogICBpZiBub3Qgc3RhdGUgdGhlbgogICAgICBlcnJvcigiVGhlIHN0YXRl
ICIuLnN0YXRlTmFtZS4uIiB3YXMgbm90IGZvdW5kIGluICIuLnRvc3RyaW5nKHNlbGYuY2xhc3Mp
KQogICBlbmQKZW5kCgpsb2NhbCBmdW5jdGlvbiBfaW52b2tlQ2FsbGJhY2soc2VsZiwgc3RhdGUs
IGNhbGxiYWNrTmFtZSwgLi4uKQogICBpZiBzdGF0ZSBhbmQgc3RhdGVbY2FsbGJhY2tOYW1lXSB0
aGVuIHN0YXRlW2NhbGxiYWNrTmFtZV0oc2VsZiwgLi4uKSBlbmQKZW5kCgpsb2NhbCBmdW5jdGlv
biBfZ2V0Q3VycmVudFN0YXRlKHNlbGYpCiAgIHJldHVybiBzZWxmLl9fc3RhdGVTdGFja1sjc2Vs
Zi5fX3N0YXRlU3RhY2tdCmVuZAoKbG9jYWwgZnVuY3Rpb24gX2dldFN0YXRlRnJvbUNsYXNzQnlO
YW1lKHNlbGYsIHN0YXRlTmFtZSkKICAgbG9jYWwgc3RhdGUgPSBzZWxmLmNsYXNzLnN0YXRpYy5z
dGF0ZXNbc3RhdGVOYW1lXQogICBfYXNzZXJ0RXhpc3RpbmdTdGF0ZShzZWxmLCBzdGF0ZSwgc3Rh
dGVOYW1lKQogICByZXR1cm4gc3RhdGUKZW5kCgpsb2NhbCBmdW5jdGlvbiBfZ2V0U3RhdGVJbmRl
eEZyb21TdGFja0J5TmFtZShzZWxmLCBzdGF0ZU5hbWUpCiAgIGlmIHN0YXRlTmFtZSA9PSBuaWwg
dGhlbiByZXR1cm4gI3NlbGYuX19zdGF0ZVN0YWNrIGVuZAogICBsb2NhbCB0YXJnZXQgPSBfZ2V0
U3RhdGVGcm9tQ2xhc3NCeU5hbWUoc2VsZiwgc3RhdGVOYW1lKQogICBmb3IgaSA9ICNzZWxmLl9f
c3RhdGVTdGFjaywgMSwgLTEgZG8KICAgICAgaWYgc2VsZi5fX3N0YXRlU3RhY2tbaV0gPT0gdGFy
Z2V0IHRoZW4gcmV0dXJuIGkgZW5kCiAgIGVuZAplbmQKCmxvY2FsIGZ1bmN0aW9uIF9nZXRTdGF0
ZU5hbWUoc2VsZiwgdGFyZ2V0KQogICBmb3IgbmFtZSwgc3RhdGUgaW4gcGFpcnMoc2VsZi5jbGFz
cy5zdGF0aWMuc3RhdGVzKSBkbwogICAgICBpZiBzdGF0ZSA9PSB0YXJnZXQgdGhlbiByZXR1cm4g
bmFtZSBlbmQKICAgZW5kCmVuZAoKZnVuY3Rpb24gU3RhdGVmdWw6aW5jbHVkZWQoa2xhc3MpCiAg
IF9hZGRTdGF0ZXNUb0NsYXNzKGtsYXNzKQogICBfbW9kaWZ5SW5zdGFuY2VJbmRleChrbGFzcykK
ICAgX21vZGlmeVN1YmNsYXNzTWV0aG9kKGtsYXNzKQogICBfbW9kaWZ5QWxsb2NhdGVNZXRob2Qo
a2xhc3MpCmVuZAoKZnVuY3Rpb24gU3RhdGVmdWwuc3RhdGljOmFkZFN0YXRlKHN0YXRlTmFtZSwg
c3VwZXJTdGF0ZSkKICAgc3VwZXJTdGF0ZSA9IHN1cGVyU3RhdGUgb3IgX0Jhc2VTdGF0ZQogICBf
YXNzZXJ0VHlwZShzdGF0ZU5hbWUsICJzdGF0ZU5hbWUiLCAic3RyaW5nIikKICAgX2Fzc2VydElu
ZXhpc3RpbmdTdGF0ZShzZWxmLCBzdGF0ZU5hbWUpCiAgIHNlbGYuc3RhdGljLnN0YXRlc1tzdGF0
ZU5hbWVdID0gc2V0bWV0YXRhYmxlKHt9LCB7X19pbmRleCA9IHN1cGVyU3RhdGV9KQogICByZXR1
cm4gc2VsZi5zdGF0aWMuc3RhdGVzW3N0YXRlTmFtZV0KZW5kCgpmdW5jdGlvbiBTdGF0ZWZ1bDpn
b3RvU3RhdGUoc3RhdGVOYW1lLCAuLi4pCiAgIHNlbGY6cG9wQWxsU3RhdGVzKC4uLikKCiAgIGlm
IHN0YXRlTmFtZSA9PSBuaWwgdGhlbgogICAgICBzZWxmLl9fc3RhdGVTdGFjayA9IHt9CiAgIGVs
c2UKICAgICAgX2Fzc2VydFR5cGUoc3RhdGVOYW1lLCAic3RhdGVOYW1lIiwgInN0cmluZyIsICJz
dHJpbmcgb3IgbmlsIikKCiAgICAgIGxvY2FsIG5ld1N0YXRlID0gX2dldFN0YXRlRnJvbUNsYXNz
QnlOYW1lKHNlbGYsIHN0YXRlTmFtZSkKICAgICAgc2VsZi5fX3N0YXRlU3RhY2sgPSB7bmV3U3Rh
dGV9CiAgICAgIF9pbnZva2VDYWxsYmFjayhzZWxmLCBuZXdTdGF0ZSwgImVudGVyZWRTdGF0ZSIs
IC4uLikKICAgZW5kCmVuZAoKZnVuY3Rpb24gU3RhdGVmdWw6cHVzaFN0YXRlKHN0YXRlTmFtZSwg
Li4uKQogICBsb2NhbCBvbGRTdGF0ZSA9IF9nZXRDdXJyZW50U3RhdGUoc2VsZikKICAgX2ludm9r
ZUNhbGxiYWNrKHNlbGYsIG9sZFN0YXRlLCAicGF1c2VkU3RhdGUiKQoKICAgbG9jYWwgbmV3U3Rh
dGUgPSBfZ2V0U3RhdGVGcm9tQ2xhc3NCeU5hbWUoc2VsZiwgc3RhdGVOYW1lKQogICB0YWJsZS5p
bnNlcnQoc2VsZi5fX3N0YXRlU3RhY2ssIG5ld1N0YXRlKQoKICAgX2ludm9rZUNhbGxiYWNrKHNl
bGYsIG5ld1N0YXRlLCAicHVzaGVkU3RhdGUiLCAuLi4pCiAgIF9pbnZva2VDYWxsYmFjayhzZWxm
LCBuZXdTdGF0ZSwgImVudGVyZWRTdGF0ZSIsIC4uLikKZW5kCgpmdW5jdGlvbiBTdGF0ZWZ1bDpw
b3BTdGF0ZShzdGF0ZU5hbWUsIC4uLikKICAgbG9jYWwgb2xkU3RhdGVJbmRleCA9IF9nZXRTdGF0
ZUluZGV4RnJvbVN0YWNrQnlOYW1lKHNlbGYsIHN0YXRlTmFtZSkKICAgbG9jYWwgb2xkU3RhdGUK
ICAgaWYgb2xkU3RhdGVJbmRleCB0aGVuCiAgICAgIG9sZFN0YXRlID0gc2VsZi5fX3N0YXRlU3Rh
Y2tbb2xkU3RhdGVJbmRleF0KCiAgICAgIF9pbnZva2VDYWxsYmFjayhzZWxmLCBvbGRTdGF0ZSwg
InBvcHBlZFN0YXRlIiwgLi4uKQogICAgICBfaW52b2tlQ2FsbGJhY2soc2VsZiwgb2xkU3RhdGUs
ICJleGl0ZWRTdGF0ZSIsIC4uLikKCiAgICAgIHRhYmxlLnJlbW92ZShzZWxmLl9fc3RhdGVTdGFj
aywgb2xkU3RhdGVJbmRleCkKICAgZW5kCgogICBsb2NhbCBuZXdTdGF0ZSA9IF9nZXRDdXJyZW50
U3RhdGUoc2VsZikKCiAgIGlmIG9sZFN0YXRlIH49IG5ld1N0YXRlIHRoZW4KICAgICAgX2ludm9r
ZUNhbGxiYWNrKHNlbGYsIG5ld1N0YXRlLCAiY29udGludWVkU3RhdGUiLCAuLi4pCiAgIGVuZApl
bmQKCmZ1bmN0aW9uIFN0YXRlZnVsOnBvcEFsbFN0YXRlcyguLi4pCiAgIGxvY2FsIHNpemUgPSAj
c2VsZi5fX3N0YXRlU3RhY2sKICAgZm9yIF8gPSAxLCBzaXplIGRvIHNlbGY6cG9wU3RhdGUobmls
LCAuLi4pIGVuZAplbmQKCmZ1bmN0aW9uIFN0YXRlZnVsOmdldFN0YXRlU3RhY2tEZWJ1Z0luZm8o
KQogICBsb2NhbCBpbmZvID0ge30KICAgbG9jYWwgc3RhdGUKICAgZm9yIGkgPSAjc2VsZi5fX3N0
YXRlU3RhY2ssIDEsIC0xIGRvCiAgICAgIHN0YXRlID0gc2VsZi5fX3N0YXRlU3RhY2tbaV0KICAg
ICAgdGFibGUuaW5zZXJ0KGluZm8sIF9nZXRTdGF0ZU5hbWUoc2VsZiwgc3RhdGUpKQogICBlbmQK
ICAgcmV0dXJuIGluZm8KZW5kCgpyZXR1cm4gU3RhdGVmdWw=
:: map/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-04 08:44:13"]]
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTAxLTE3IDEwOjM1OjQ4Iixtb2RpZmllZD0iMjAyNS0x
Mi0yOCAyMjo0MTo1NyIscmV2aXNpb249NjhdXWx6NABaAAAAXQAAAPEie3tibXA9cHh1AEyAICAA
-wAA----AyxoaWRkZW49ZmFsc2UscGFuX3g9NTcuMTg3NQ4A8gV5PS0xNTQuMTI1LHRpbGVfaD0x
NgoAEHcKAIB6b29tPTJ9fQ==
:: sfx/.info.pod
--[[pod,created="2025-11-13 21:07:43",modified="2026-01-04 08:44:13"]]
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI1LTA3LTMxIDA4OjMwOjI4Iixtb2RpZmllZD0iMjAyNS0w
Ny0zMSAwODozMDoyOCIscmV2aXNpb249MF1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oBEAYP
MBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA------_9
H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: src/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/ai/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/ai/enemies/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/ai/enemies/boss.lua
b64$LS0gR3JlZW4gV2l0Y2ggYm9zcyBBSSBwcm9maWxlCgpsb2NhbCBtYWNoaW5lID0gcmVxdWly
ZSgibGliL2x1YS1zdGF0ZS1tYWNoaW5lL3N0YXRlbWFjaGluZSIpCmxvY2FsIEVtb3Rpb25zID0g
cmVxdWlyZSgic3JjL3N5c3RlbXMvZW1vdGlvbnMiKQpsb2NhbCBFbnRpdHlVdGlscyA9IHJlcXVp
cmUoInNyYy91dGlscy9lbnRpdHlfdXRpbHMiKQpsb2NhbCBIaXRib3hVdGlscyA9IHJlcXVpcmUo
InNyYy91dGlscy9oaXRib3hfdXRpbHMiKQpsb2NhbCBEYXNoID0gcmVxdWlyZSgic3JjL2FpL3By
aW1pdGl2ZXMvZGFzaCIpCmxvY2FsIER1bmdlb25NYW5hZ2VyID0gcmVxdWlyZSgic3JjL3dvcmxk
IikuRHVuZ2Vvbk1hbmFnZXIKbG9jYWwgRW50aXRpZXMgPSByZXF1aXJlKCJzcmMvZW50aXRpZXMi
KQoKLS0gUGhhc2UgdGhyZXNob2xkcyAoYXMgZnJhY3Rpb24gb2YgbWF4IEhQKQpsb2NhbCBQSEFT
RTJfVEhSRVNIT0xEID0gMC42Ngpsb2NhbCBQSEFTRTNfVEhSRVNIT0xEID0gMC4zMwoKLS0gQmVo
YXZpb3IgY29uc3RhbnRzCmxvY2FsIEZMRUVfQVJSSVZBTF9USFJFU0hPTEQgPSAxMCAgICAgICAg
ICAgICAgICAgICAgICAgICAgIC0tIERpc3RhbmNlIHRvIHJlYWNoIGZsZWUgdGFyZ2V0CmxvY2Fs
IEZMRUVfTUFSR0lOID0gNDggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0t
IE1hcmdpbiBmcm9tIHdhbGxzIGZvciBmbGVlIHRhcmdldApsb2NhbCBGTEVFX0dSSURfT0ZGU0VU
ID0gMjQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBPZmZzZXQgZnJvbSBncmlk
IGxpbmVzIChjZW50ZXIgb2YgdGlsZSkKbG9jYWwgRkxFRV9ISVNUT1JZX1RIUkVTSE9MRCA9IDUw
ICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gRGlzdGFuY2UgdG8gY2hlY2sgYWdhaW5zdCBo
aXN0b3J5CmxvY2FsIEZMRUVfSElTVE9SWV9QRU5BTFRZID0gMjAwICAgICAgICAgICAgICAgICAg
ICAgICAgICAgIC0tIFNjb3JlIHBlbmFsdHkgZm9yIHJldmlzaXRpbmcgcG9zaXRpb25zCmxvY2Fs
IEZMRUVfSElTVE9SWV9TSVpFID0gMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0t
IE1heCBwb3NpdGlvbnMgdG8gcmVtZW1iZXIKbG9jYWwgRkxFRV9TQ09SRV9SQU5ET00gPSAzMCAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gUmFuZG9tIGZhY3RvciBmb3Igc2Nvcmlu
Zwpsb2NhbCBGTEVFX1NDT1JFX1RIUkVTSE9MRCA9IDIwICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAtLSBTY29yZSBkaWZmZXJlbmNlIGZvciAiY2xvc2UgZW5vdWdoIiBjYW5kaWRhdGVzCmxv
Y2FsIEZMRUVfU0NPUkVfRElTVF9XRUlHSFQgPSAwLjUgICAgICAgICAgICAgICAgICAgICAgICAg
IC0tIFdlaWdodCBmb3IgZGlzdGFuY2UgZnJvbSBzZWxmCmxvY2FsIERBU0hfRFVSQVRJT04gPSA0
MCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIEZyYW1lcyBwZXIgZGFzaAps
b2NhbCBUUkFOU0lUSU9OX0RVUkFUSU9OID0gNjAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAtLSBGcmFtZXMgZm9yIHBoYXNlIHRyYW5zaXRpb24gYW5pbWF0aW9uCmxvY2FsIFNVTU1PTl9Q
QVVTRSA9IDMwICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIFBhdXNlIGFm
dGVyIHN1bW1vbmluZwpsb2NhbCBTVU1NT05fRU5FTVlfVFlQRVMgPSB7IlNrdWxrZXIiLCAiU2hv
b3RlciIsICJEYXNoZXIifSAtLSBSYW5kb20gc3Bhd24gdHlwZXMKbG9jYWwgU1VNTU9OX09GRlNF
VFMgPSB7ey00MCwgMH0sIHs0MCwgMH0sIHswLCAtNDB9fSAgICAgICAgLS0gUmVsYXRpdmUgc3Bh
d24gcG9zaXRpb25zCmxvY2FsIFNVTU1PTl9DQVAgPSA2ICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgIC0tIE1heCB0b3RhbCBtaW5pb25zIGFsaXZlCmxvY2FsIFNVTU1PTl9C
QVRDSF9TSVpFID0gMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIE1pbmlvbnMg
dG8gc3Bhd24gcGVyIGN5Y2xlCgpsb2NhbCBQSEFTRTJfU0VRVUVOQ0UgPSB7InNob290IiwgInN1
bW1vbiJ9CmxvY2FsIFBIQVNFM19TRVFVRU5DRSA9IHsic2hvb3QiLCAic3VtbW9uIiwgIndpbmR1
cCJ9Cgpsb2NhbCBQSEFTRTNfU0hPT1RfREVMQVkgPSAxNSAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gRmFzdGVyIGZpcmUgcmF0ZSBpbiBwaGFz
ZSAzICh3YXMgMjApCmxvY2FsIFBIQVNFM19TSE9UX0NPVU5UID0gNSAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBTaG90cyBwZXIgYnVyc3Qg
aW4gcGhhc2UgMwpsb2NhbCBQSEFTRTNfU0hPT1RfQ09PTERPV04gPSAzMCAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gUmVkdWNlZCBjb29sZG93biBp
biBwaGFzZSAzCmxvY2FsIFBIQVNFM19EQVNIX0FJTV9EVVJBVElPTiA9IDMwICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBBaW0vV2luZHVwIGR1cmF0aW9u
IGJlZm9yZSBkYXNoCgpsb2NhbCBQSEFTRTFfU0hPT1RfREVMQVkgPSA2MCAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLS0gRnJhbWVzIGJldHdlZW4g
c2hvdHMgKHBoYXNlIDEpCmxvY2FsIFBIQVNFMV9TSE9UX0NPVU5UID0gNSAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBTaG90cyBwZXIgYnVy
c3QKbG9jYWwgUEhBU0UyX1NIT1RfQ09VTlQgPSAzICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0tIFNob3RzIHBlciBidXJzdCAocGhhc2UgMikK
CmxvY2FsIEZMRUVfU1BFRURfTVVMVElQTElFUlMgPSB7MiwgMi41LCAzfSAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAtLSBNdWx0aXBsaWVycyBmb3IgUGhhc2UgMSwgMiwg
Mwpsb2NhbCBTSE9PVF9ERUxBWVMgPSB7UEhBU0UxX1NIT09UX0RFTEFZLCBQSEFTRTFfU0hPT1Rf
REVMQVksIFBIQVNFM19TSE9PVF9ERUxBWX0gLS0gU2hvb3QgZGVsYXlzIGZvciBQaGFzZSAxLCAy
LCAzCgotLSBHZXQgY3VycmVudCBwaGFzZSBiYXNlZCBvbiBIUApsb2NhbCBmdW5jdGlvbiBnZXRf
cGhhc2UoZW50aXR5KQogICBsb2NhbCBocF9yYXRpbyA9IGVudGl0eS5ocCAvIGVudGl0eS5tYXhf
aHAKICAgaWYgaHBfcmF0aW8gPiBQSEFTRTJfVEhSRVNIT0xEIHRoZW4KICAgICAgcmV0dXJuIDEK
ICAgZWxzZWlmIGhwX3JhdGlvID4gUEhBU0UzX1RIUkVTSE9MRCB0aGVuCiAgICAgIHJldHVybiAy
CiAgIGVsc2UKICAgICAgcmV0dXJuIDMKICAgZW5kCmVuZAoKLS0gU2hhcmVkIGZsZWUgYmVoYXZp
b3IgZm9yIHBoYXNlIDEgYW5kIDIKLS0gUmV0dXJucyB0cnVlIGlmIHJlYWNoZWQgdGFyZ2V0LCBm
YWxzZSBpZiBzdGlsbCBtb3ZpbmcKbG9jYWwgZnVuY3Rpb24gZG9fZmxlZShlbnRpdHksIHBsYXll
ciwgZHgsIGR5LCBkaXN0KQogICBlbnRpdHkuc2hvb3RfZGlyX3ggPSAwCiAgIGVudGl0eS5zaG9v
dF9kaXJfeSA9IDAKCiAgIGlmIG5vdCBwbGF5ZXIgdGhlbiByZXR1cm4gZmFsc2UgZW5kCgogICAt
LSBHZXQgcm9vbSBib3VuZHMKICAgbG9jYWwgcm9vbSA9IER1bmdlb25NYW5hZ2VyLmN1cnJlbnRf
cm9vbQogICBsb2NhbCBib3VuZHMgPSByb29tOmdldF9pbm5lcl9ib3VuZHMoKQogICBsb2NhbCBt
aW5feCA9IGJvdW5kcy54MSAqIEdSSURfU0laRSArIEZMRUVfR1JJRF9PRkZTRVQKICAgbG9jYWwg
bWF4X3ggPSBib3VuZHMueDIgKiBHUklEX1NJWkUgLSBGTEVFX0dSSURfT0ZGU0VUCiAgIGxvY2Fs
IG1pbl95ID0gYm91bmRzLnkxICogR1JJRF9TSVpFICsgRkxFRV9HUklEX09GRlNFVAogICBsb2Nh
bCBtYXhfeSA9IGJvdW5kcy55MiAqIEdSSURfU0laRSAtIEZMRUVfR1JJRF9PRkZTRVQKCiAgIC0t
IENhbGN1bGF0ZSBmbGVlIHRhcmdldCBpZiBub3Qgc2V0CiAgIGlmIG5vdCBlbnRpdHkuZmxlZV90
YXJnZXRfeCB0aGVuCiAgICAgIC0tIEluaXRpYWxpemUgcG9zaXRpb24gaGlzdG9yeSBpZiBuZWVk
ZWQKICAgICAgZW50aXR5LmZsZWVfaGlzdG9yeSA9IGVudGl0eS5mbGVlX2hpc3Rvcnkgb3Ige30K
CiAgICAgIC0tIEdlbmVyYXRlIGNhbmRpZGF0ZSBwb3NpdGlvbnMgKGNvcm5lcnMgKyBlZGdlIG1p
ZHBvaW50cykKICAgICAgbG9jYWwgY2FuZGlkYXRlcyA9IHsKICAgICAgICAge3ggPSBtaW5feCAr
IEZMRUVfTUFSR0lOLCB5ID0gbWluX3kgKyBGTEVFX01BUkdJTn0sIC0tIFRvcC1sZWZ0CiAgICAg
ICAgIHt4ID0gbWF4X3ggLSBGTEVFX01BUkdJTiwgeSA9IG1pbl95ICsgRkxFRV9NQVJHSU59LCAt
LSBUb3AtcmlnaHQKICAgICAgICAge3ggPSBtaW5feCArIEZMRUVfTUFSR0lOLCB5ID0gbWF4X3kg
LSBGTEVFX01BUkdJTn0sIC0tIEJvdHRvbS1sZWZ0CiAgICAgICAgIHt4ID0gbWF4X3ggLSBGTEVF
X01BUkdJTiwgeSA9IG1heF95IC0gRkxFRV9NQVJHSU59LCAtLSBCb3R0b20tcmlnaHQKICAgICAg
ICAge3ggPSAobWluX3ggKyBtYXhfeCkgLyAyLCB5ID0gbWluX3kgKyBGTEVFX01BUkdJTn0sIC0t
IFRvcC1jZW50ZXIKICAgICAgICAge3ggPSAobWluX3ggKyBtYXhfeCkgLyAyLCB5ID0gbWF4X3kg
LSBGTEVFX01BUkdJTn0sIC0tIEJvdHRvbS1jZW50ZXIKICAgICAgICAge3ggPSBtaW5feCArIEZM
RUVfTUFSR0lOLCB5ID0gKG1pbl95ICsgbWF4X3kpIC8gMn0sIC0tIExlZnQtY2VudGVyCiAgICAg
ICAgIHt4ID0gbWF4X3ggLSBGTEVFX01BUkdJTiwgeSA9IChtaW5feSArIG1heF95KSAvIDJ9LCAt
LSBSaWdodC1jZW50ZXIKICAgICAgfQoKICAgICAgLS0gU2NvcmUgZWFjaCBjYW5kaWRhdGUKICAg
ICAgbG9jYWwgYmVzdF9zY29yZSA9IC1tYXRoLmh1Z2UKICAgICAgbG9jYWwgYmVzdF9jYW5kaWRh
dGVzID0ge30KCiAgICAgIGZvciBfLCBjYW5kIGluIGlwYWlycyhjYW5kaWRhdGVzKSBkbwogICAg
ICAgICAtLSBEaXN0YW5jZSBmcm9tIHBsYXllciAoaGlnaGVyID0gYmV0dGVyKQogICAgICAgICBs
b2NhbCBwZHggPSBjYW5kLnggLSBwbGF5ZXIueAogICAgICAgICBsb2NhbCBwZHkgPSBjYW5kLnkg
LSBwbGF5ZXIueQogICAgICAgICBsb2NhbCBwbGF5ZXJfZGlzdCA9IHNxcnQocGR4ICogcGR4ICsg
cGR5ICogcGR5KQoKICAgICAgICAgLS0gRGlzdGFuY2UgZnJvbSBjdXJyZW50IHBvc2l0aW9uICho
aWdoZXIgPSBiZXR0ZXIpCiAgICAgICAgIGxvY2FsIGNkeCA9IGNhbmQueCAtIGVudGl0eS54CiAg
ICAgICAgIGxvY2FsIGNkeSA9IGNhbmQueSAtIGVudGl0eS55CiAgICAgICAgIGxvY2FsIGN1cnJl
bnRfZGlzdCA9IHNxcnQoY2R4ICogY2R4ICsgY2R5ICogY2R5KQoKICAgICAgICAgLS0gQ2hlY2sg
aWYgaW4gcmVjZW50IGhpc3RvcnkgKHBlbmFsdHkpCiAgICAgICAgIGxvY2FsIGhpc3RvcnlfcGVu
YWx0eSA9IDAKICAgICAgICAgZm9yIF8sIGhpc3QgaW4gaXBhaXJzKGVudGl0eS5mbGVlX2hpc3Rv
cnkpIGRvCiAgICAgICAgICAgIGxvY2FsIGhkeCA9IGNhbmQueCAtIGhpc3QueAogICAgICAgICAg
ICBsb2NhbCBoZHkgPSBjYW5kLnkgLSBoaXN0LnkKICAgICAgICAgICAgbG9jYWwgaGlzdF9kaXN0
ID0gc3FydChoZHggKiBoZHggKyBoZHkgKiBoZHkpCiAgICAgICAgICAgIGlmIGhpc3RfZGlzdCA8
IEZMRUVfSElTVE9SWV9USFJFU0hPTEQgdGhlbgogICAgICAgICAgICAgICBoaXN0b3J5X3BlbmFs
dHkgKz0gRkxFRV9ISVNUT1JZX1BFTkFMVFkKICAgICAgICAgICAgZW5kCiAgICAgICAgIGVuZAoK
ICAgICAgICAgLS0gU2NvcmU6IHByaW9yaXRpemUgZGlzdGFuY2UgZnJvbSBwbGF5ZXIsIHRoZW4g
ZnJvbSBzZWxmLCBwZW5hbGl6ZSBoaXN0b3J5CiAgICAgICAgIGxvY2FsIHNjb3JlID0gcGxheWVy
X2Rpc3QgKyBjdXJyZW50X2Rpc3QgKiBGTEVFX1NDT1JFX0RJU1RfV0VJR0hUIC0gaGlzdG9yeV9w
ZW5hbHR5ICsgcm5kKEZMRUVfU0NPUkVfUkFORE9NKQoKICAgICAgICAgaWYgc2NvcmUgPiBiZXN0
X3Njb3JlIHRoZW4KICAgICAgICAgICAgYmVzdF9zY29yZSA9IHNjb3JlCiAgICAgICAgICAgIGJl
c3RfY2FuZGlkYXRlcyA9IHtjYW5kfQogICAgICAgICBlbHNlaWYgc2NvcmUgPiBiZXN0X3Njb3Jl
IC0gRkxFRV9TQ09SRV9USFJFU0hPTEQgdGhlbgogICAgICAgICAgICAtLSBDbG9zZSBlbm91Z2gs
IGFkZCB0byBwb29sIGZvciByYW5kb21pemF0aW9uCiAgICAgICAgICAgIGFkZChiZXN0X2NhbmRp
ZGF0ZXMsIGNhbmQpCiAgICAgICAgIGVuZAogICAgICBlbmQKCiAgICAgIC0tIFBpY2sgZnJvbSBi
ZXN0IGNhbmRpZGF0ZXMKICAgICAgbG9jYWwgY2hvc2VuID0gYmVzdF9jYW5kaWRhdGVzW2Zscihy
bmQoI2Jlc3RfY2FuZGlkYXRlcykpICsgMV0gb3IgY2FuZGlkYXRlc1sxXQoKICAgICAgLS0gVXBk
YXRlIGhpc3RvcnkgKGtlZXAgbGFzdCAzKQogICAgICBhZGQoZW50aXR5LmZsZWVfaGlzdG9yeSwg
e3ggPSBjaG9zZW4ueCwgeSA9IGNob3Nlbi55fSkKICAgICAgd2hpbGUgI2VudGl0eS5mbGVlX2hp
c3RvcnkgPiBGTEVFX0hJU1RPUllfU0laRSBkbwogICAgICAgICBkZWxpKGVudGl0eS5mbGVlX2hp
c3RvcnksIDEpCiAgICAgIGVuZAoKICAgICAgLS0gQ2xhbXAgdG8gcm9vbSBib3VuZHMKICAgICAg
ZW50aXR5LmZsZWVfdGFyZ2V0X3ggPSBtaWQobWluX3gsIGNob3Nlbi54LCBtYXhfeCkKICAgICAg
ZW50aXR5LmZsZWVfdGFyZ2V0X3kgPSBtaWQobWluX3ksIGNob3Nlbi55LCBtYXhfeSkKICAgZW5k
CgogICAtLSBNb3ZlIHRvd2FyZCBmbGVlIHRhcmdldAogICBsb2NhbCB0eF9kaWZmID0gZW50aXR5
LmZsZWVfdGFyZ2V0X3ggLSBlbnRpdHkueAogICBsb2NhbCB0eV9kaWZmID0gZW50aXR5LmZsZWVf
dGFyZ2V0X3kgLSBlbnRpdHkueQogICBsb2NhbCB0YXJnZXRfZGlzdCA9IHNxcnQodHhfZGlmZiAq
IHR4X2RpZmYgKyB0eV9kaWZmICogdHlfZGlmZikKCiAgIGlmIHRhcmdldF9kaXN0ID4gRkxFRV9B
UlJJVkFMX1RIUkVTSE9MRCB0aGVuCiAgICAgIGxvY2FsIHNwZWVkX211bHRpcGxpZXIgPSBGTEVF
X1NQRUVEX01VTFRJUExJRVJTW2VudGl0eS5ib3NzX3BoYXNlXSBvciAxCiAgICAgIGxvY2FsIG1v
dmVfc3BlZWQgPSBlbnRpdHkubWF4X3NwZWVkICogc3BlZWRfbXVsdGlwbGllcgogICAgICBlbnRp
dHkudmVsX3ggPSAodHhfZGlmZiAvIHRhcmdldF9kaXN0KSAqIG1vdmVfc3BlZWQKICAgICAgZW50
aXR5LnZlbF95ID0gKHR5X2RpZmYgLyB0YXJnZXRfZGlzdCkgKiBtb3ZlX3NwZWVkCiAgICAgIGVu
dGl0eS5kaXJfeCA9IHNnbih0eF9kaWZmKQogICAgICBlbnRpdHkuZGlyX3kgPSBzZ24odHlfZGlm
ZikKICAgICAgZW50aXR5LmN1cnJlbnRfZGlyZWN0aW9uID0gRW50aXR5VXRpbHMuZ2V0X2RpcmVj
dGlvbl9uYW1lKHR4X2RpZmYsIHR5X2RpZmYsIGVudGl0eS5jdXJyZW50X2RpcmVjdGlvbikKICAg
ICAgcmV0dXJuIGZhbHNlCiAgIGVsc2UKICAgICAgcmV0dXJuIHRydWUKICAgZW5kCmVuZAoKLS0g
U2hhcmVkIHN1bW1vbiBsb2dpYwpsb2NhbCBmdW5jdGlvbiBkb19zdW1tb24oZW50aXR5LCB3b3Js
ZCkKICAgZW50aXR5LnZlbF94ID0gMAogICBlbnRpdHkudmVsX3kgPSAwCgogICBpZiBlbnRpdHku
c3VtbW9uX3BlbmRpbmcgYW5kIGVudGl0eS5zdW1tb25fcGVuZGluZyA_IDAgdGhlbgogICAgICBs
b2NhbCBzdW1tb25lZF9jb3VudCA9IDAKICAgICAgd29ybGQuc3lzKCJlbmVteSIsIGZ1bmN0aW9u
KGVuZW15KQogICAgICAgICBpZiBlbmVteSB_PSBlbnRpdHkgdGhlbiAtLSBOb3QgdGhlIGJvc3Mg
aXRzZWxmCiAgICAgICAgICAgIHN1bW1vbmVkX2NvdW50ICs9IDEKICAgICAgICAgZW5kCiAgICAg
IGVuZCkoKQoKICAgICAgLS0gU3Bhd24gdXAgdG8gY2FwCiAgICAgIGxvY2FsIHNwYXduZWQgPSAw
CiAgICAgIGZvciBpID0gMSwgU1VNTU9OX0JBVENIX1NJWkUgZG8KICAgICAgICAgaWYgc3VtbW9u
ZWRfY291bnQgKyBzcGF3bmVkIDwgU1VNTU9OX0NBUCB0aGVuCiAgICAgICAgICAgIGxvY2FsIGVu
ZW15X3R5cGUgPSBTVU1NT05fRU5FTVlfVFlQRVNbcm5kKCNTVU1NT05fRU5FTVlfVFlQRVMpICsg
MV0KICAgICAgICAgICAgbG9jYWwgb3gsIG95ID0gU1VNTU9OX09GRlNFVFNbaV1bMV0sIFNVTU1P
Tl9PRkZTRVRTW2ldWzJdCiAgICAgICAgICAgIEVudGl0aWVzLnNwYXduX2VuZW15KHdvcmxkLCBl
bnRpdHkueCArIG94LCBlbnRpdHkueSArIG95LCBlbmVteV90eXBlKQogICAgICAgICAgICBzcGF3
bmVkICs9IDEKICAgICAgICAgZW5kCiAgICAgIGVuZAogICAgICBlbnRpdHkuc3VtbW9uX3BlbmRp
bmcgPSAwCiAgIGVuZAplbmQKCi0tIFNoYXJlZCBzaG9vdGluZyBsb2dpYwpsb2NhbCBmdW5jdGlv
biBkb19zaG9vdChlbnRpdHksIGZzbSwgcGxheWVyLCBkeCwgZHksIGRpc3QpCiAgIC0tIFN0b3Ag
bW92aW5nCiAgIGVudGl0eS52ZWxfeCA9IDAKICAgZW50aXR5LnZlbF95ID0gMAoKICAgLS0gQWlt
IGF0IHBsYXllcgogICBpZiBwbGF5ZXIgYW5kIGRpc3QgPiAwIHRoZW4KICAgICAgZW50aXR5LnNo
b290X2Rpcl94ID0gZHggLyBkaXN0CiAgICAgIGVudGl0eS5zaG9vdF9kaXJfeSA9IGR5IC8gZGlz
dAogICAgICBlbnRpdHkuY3VycmVudF9kaXJlY3Rpb24gPSBFbnRpdHlVdGlscy5nZXRfZGlyZWN0
aW9uX25hbWUoZHgsIGR5LCBlbnRpdHkuY3VycmVudF9kaXJlY3Rpb24pCiAgIGVuZAoKICAgLS0g
RGV0ZXJtaW5lIGRlbGF5IGJhc2VkIG9uIHBoYXNlCiAgIGxvY2FsIGRlbGF5ID0gU0hPT1RfREVM
QVlTW2VudGl0eS5ib3NzX3BoYXNlXQoKICAgLS0gU2hvb3Qgb24gY29vbGRvd24KICAgZW50aXR5
LmJvc3NfdGltZXIgKz0gMQogICBpZiBlbnRpdHkuYm9zc190aW1lciA_PSBkZWxheSB0aGVuCiAg
ICAgIGVudGl0eS5ib3NzX3RpbWVyID0gMAogICAgICBlbnRpdHkuc2hvdHNfcmVtYWluaW5nIC09
IDEKCiAgICAgIC0tIENoZWNrIGlmIHNob290IGNvbXBsZXRlCiAgICAgIGlmIGVudGl0eS5zaG90
c19yZW1haW5pbmcgPD0gMCB0aGVuCiAgICAgICAgIGZzbTpyZXN1bWUoKQogICAgICBlbmQKICAg
ZW5kCmVuZAoKLS0gSW5pdGlhbGl6ZSBCb3NzIEZTTSBvbiBlbnRpdHkKbG9jYWwgZnVuY3Rpb24g
aW5pdF9mc20oZW50aXR5KQogICBlbnRpdHkuYm9zc19waGFzZSA9IDEKICAgZW50aXR5LmJvc3Nf
dGltZXIgPSAwCiAgIGVudGl0eS5zdW1tb25fdGltZXIgPSAwCiAgIGVudGl0eS5kYXNoX3Rhcmdl
dF9keCA9IDAKICAgZW50aXR5LmRhc2hfdGFyZ2V0X2R5ID0gMAoKICAgZW50aXR5LmJvc3NfZnNt
ID0gbWFjaGluZS5jcmVhdGUoewogICAgICBpbml0aWFsID0gInBoYXNlMV9mbGVlIiwKICAgICAg
ZXZlbnRzID0gewogICAgICAgICAtLSBQaGFzZSAxOiBGbGVlICsgU2hvb3QgKGZsZWUgYXdheSwg
ZmlyZSA1IHNob3RzLCByZXBlYXQpCiAgICAgICAgIHtuYW1lID0gInNob290IiwgICAgICAgIGZy
b20gPSAicGhhc2UxX2ZsZWUiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRv
ID0gInBoYXNlMV9zaG9vdCJ9LAogICAgICAgICB7bmFtZSA9ICJyZXN1bWUiLCAgICAgICBmcm9t
ID0gInBoYXNlMV9zaG9vdCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byA9
ICJwaGFzZTFfZmxlZSJ9LAoKICAgICAgICAgLS0gUGhhc2UgMjogRmxlZSArIFNob290ICgzeCkg
KyBGbGVlICsgU3VtbW9uIChzaG9ydGVyL2Zhc3RlcikKICAgICAgICAge25hbWUgPSAic2hvb3Qi
LCAgICAgICAgZnJvbSA9ICJwaGFzZTJfZmxlZSIsICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgICAgdG8gPSAicGhhc2UyX3Nob290In0sCiAgICAgICAgIHtuYW1lID0gInJlc3VtZSIs
ICAgICAgIGZyb20gPSAicGhhc2UyX3Nob290IiwgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgICAgIHRvID0gInBoYXNlMl9mbGVlIn0sCiAgICAgICAgIHtuYW1lID0gInN1bW1vbiIsICAg
ICAgIGZyb20gPSAicGhhc2UyX2ZsZWUiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgIHRvID0gInBoYXNlMl9zdW1tb24ifSwKICAgICAgICAge25hbWUgPSAicmVzdW1lIiwgICAg
ICAgZnJvbSA9ICJwaGFzZTJfc3VtbW9uIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg
ICAgdG8gPSAicGhhc2UyX2ZsZWUifSwKCiAgICAgICAgIC0tIFBoYXNlIDM6IEVucmFnZWQgKGZs
ZWUg4oaSIHNob290IOKGkiBmbGVlIOKGkiBzdW1tb24g4oaSIGZsZWUg4oaSIGRhc2ggbG9vcCkK
ICAgICAgICAge25hbWUgPSAic2hvb3QiLCAgICAgICAgZnJvbSA9ICJwaGFzZTNfZmxlZSIsICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSAicGhhc2UzX3Nob290In0sCiAg
ICAgICAgIHtuYW1lID0gInN1bW1vbiIsICAgICAgIGZyb20gPSAicGhhc2UzX2ZsZWUiLCAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gInBoYXNlM19zdW1tb24ifSwKICAg
ICAgICAge25hbWUgPSAid2luZHVwIiwgICAgICAgZnJvbSA9ICJwaGFzZTNfZmxlZSIsICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gPSAicGhhc2UzX3dpbmR1cCJ9LAogICAg
ICAgICB7bmFtZSA9ICJkYXNoIiwgICAgICAgICBmcm9tID0gInBoYXNlM193aW5kdXAiLCAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byA9ICJwaGFzZTNfZGFzaCJ9LAogICAgICAg
ICB7bmFtZSA9ICJyZXN1bWUiLCAgICAgICBmcm9tID0gInBoYXNlM19zaG9vdCIsICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICAgICB0byA9ICJwaGFzZTNfZmxlZSJ9LAogICAgICAgICB7
bmFtZSA9ICJyZXN1bWUiLCAgICAgICBmcm9tID0gInBoYXNlM19zdW1tb24iLCAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICAgICB0byA9ICJwaGFzZTNfZmxlZSJ9LAogICAgICAgICB7bmFt
ZSA9ICJyZXN1bWUiLCAgICAgICBmcm9tID0gInBoYXNlM19kYXNoIiwgICAgICAgICAgICAgICAg
ICAgICAgICAgICAgICAgICAgICB0byA9ICJwaGFzZTNfZmxlZSJ9LAoKICAgICAgICAgLS0gUGhh
c2UgdHJhbnNpdGlvbnMKICAgICAgICAge25hbWUgPSAidG9fcGhhc2UyIiwgICAgZnJvbSA9IHsi
cGhhc2UxX2ZsZWUiLCAicGhhc2UxX3Nob290In0sICAgICAgICAgICAgICAgICAgdG8gPSAidHJh
bnNpdGlvbiJ9LAogICAgICAgICB7bmFtZSA9ICJ0b19waGFzZTMiLCAgICBmcm9tID0geyJwaGFz
ZTJfZmxlZSIsICJwaGFzZTJfc2hvb3QiLCAicGhhc2UyX3N1bW1vbiJ9LCB0byA9ICJ0cmFuc2l0
aW9uIn0sCiAgICAgICAgIHtuYW1lID0gImVudGVyX3BoYXNlMiIsIGZyb20gPSAidHJhbnNpdGlv
biIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gInBoYXNlMl9mbGVl
In0sCiAgICAgICAgIHtuYW1lID0gImVudGVyX3BoYXNlMyIsIGZyb20gPSAidHJhbnNpdGlvbiIs
ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvID0gInBoYXNlM19mbGVlIn0s
CiAgICAgIH0sCiAgICAgIGNhbGxiYWNrcyA9IHsKICAgICAgICAgb25lbnRlcnBoYXNlMV9mbGVl
ID0gZnVuY3Rpb24oKQogICAgICAgICAgICAtLSBDYWxjdWxhdGUgZmxlZSB0YXJnZXQgcG9zaXRp
b24gKGF3YXkgZnJvbSBwbGF5ZXIpCiAgICAgICAgICAgIGVudGl0eS5mbGVlX3RhcmdldF94ID0g
bmlsIC0tIFdpbGwgYmUgc2V0IGluIHVwZGF0ZSB3aGVuIHBsYXllciBpcyBrbm93bgogICAgICAg
ICAgICBlbnRpdHkuZmxlZV90YXJnZXRfeSA9IG5pbAogICAgICAgICBlbmQsCiAgICAgICAgIG9u
ZW50ZXJwaGFzZTFfc2hvb3QgPSBmdW5jdGlvbigpCiAgICAgICAgICAgIGVudGl0eS5zaG90c19y
ZW1haW5pbmcgPSBQSEFTRTFfU0hPVF9DT1VOVAogICAgICAgICAgICBlbnRpdHkuYm9zc190aW1l
ciA9IDAgLS0gU3RhcnQgc2hvb3RpbmcgaW1tZWRpYXRlbHkKICAgICAgICAgICAgZW50aXR5LnZl
bF94ID0gMAogICAgICAgICAgICBlbnRpdHkudmVsX3kgPSAwCiAgICAgICAgICAgIGVudGl0eS5m
bGVlX3RhcmdldF94ID0gbmlsCiAgICAgICAgIGVuZCwKICAgICAgICAgb25lbnRlcnRyYW5zaXRp
b24gPSBmdW5jdGlvbigpCiAgICAgICAgICAgIEVtb3Rpb25zLnNldChlbnRpdHksICJhbGVydCIp
CiAgICAgICAgICAgIGVudGl0eS5ib3NzX3RpbWVyID0gVFJBTlNJVElPTl9EVVJBVElPTgogICAg
ICAgICAgICBlbnRpdHkudmVsX3ggPSAwCiAgICAgICAgICAgIGVudGl0eS52ZWxfeSA9IDAKICAg
ICAgICAgZW5kLAogICAgICAgICBvbmVudGVycGhhc2UyX2ZsZWUgPSBmdW5jdGlvbigpCiAgICAg
ICAgICAgIGVudGl0eS5ib3NzX3BoYXNlID0gMgogICAgICAgICAgICBlbnRpdHkuZmxlZV90YXJn
ZXRfeCA9IG5pbCAgICAgICAgICAgICAgICAgICAgICAgLS0gV2lsbCBiZSBzZXQgaW4gdXBkYXRl
CiAgICAgICAgICAgIGVudGl0eS5mbGVlX3RhcmdldF95ID0gbmlsCiAgICAgICAgICAgIGVudGl0
eS5waGFzZV9zdGVwID0gKGVudGl0eS5waGFzZV9zdGVwIG9yIDApICsgMSAtLSBUcmFjayBjeWNs
ZTogMT1zaG9vdCwgMj1zdW1tb24KICAgICAgICAgZW5kLAogICAgICAgICBvbmVudGVycGhhc2Uy
X3Nob290ID0gZnVuY3Rpb24oKQogICAgICAgICAgICBFbW90aW9ucy5zZXQoZW50aXR5LCAiYWxl
cnQiKQogICAgICAgICAgICBlbnRpdHkuc2hvdHNfcmVtYWluaW5nID0gUEhBU0UyX1NIT1RfQ09V
TlQKICAgICAgICAgICAgZW50aXR5LmJvc3NfdGltZXIgPSAwCiAgICAgICAgICAgIGVudGl0eS52
ZWxfeCA9IDAKICAgICAgICAgICAgZW50aXR5LnZlbF95ID0gMAogICAgICAgICAgICBlbnRpdHku
ZmxlZV90YXJnZXRfeCA9IG5pbAogICAgICAgICAgICBlbnRpdHkuZmxlZV90YXJnZXRfeSA9IG5p
bAogICAgICAgICBlbmQsCiAgICAgICAgIG9uZW50ZXJwaGFzZTJfc3VtbW9uID0gZnVuY3Rpb24o
KQogICAgICAgICAgICBFbW90aW9ucy5zZXQoZW50aXR5LCAiYWxlcnQiKQogICAgICAgICAgICBl
bnRpdHkuYm9zc190aW1lciA9IFNVTU1PTl9QQVVTRQogICAgICAgICAgICBlbnRpdHkudmVsX3gg
PSAwCiAgICAgICAgICAgIGVudGl0eS52ZWxfeSA9IDAKICAgICAgICAgICAgZW50aXR5LnN1bW1v
bl9wZW5kaW5nID0gU1VNTU9OX0JBVENIX1NJWkUgLS0gU3Bhd24gMyBlbmVtaWVzCiAgICAgICAg
ICAgIGVudGl0eS5waGFzZV9zdGVwID0gMAogICAgICAgICBlbmQsCiAgICAgICAgIG9uZW50ZXJw
aGFzZTNfZmxlZSA9IGZ1bmN0aW9uKCkKICAgICAgICAgICAgZW50aXR5LmJvc3NfcGhhc2UgPSAz
CiAgICAgICAgICAgIGVudGl0eS5mbGVlX3RhcmdldF94ID0gbmlsCiAgICAgICAgICAgIGVudGl0
eS5mbGVlX3RhcmdldF95ID0gbmlsCiAgICAgICAgICAgIGVudGl0eS5waGFzZV9zdGVwICs9IDEK
ICAgICAgICAgICAgZW50aXR5LnNob290X2Nvb2xkb3duX2R1cmF0aW9uID0gUEhBU0UzX1NIT09U
X0NPT0xET1dOCiAgICAgICAgIGVuZCwKICAgICAgICAgb25lbnRlcnBoYXNlM19zaG9vdCA9IGZ1
bmN0aW9uKCkKICAgICAgICAgICAgRW1vdGlvbnMuc2V0KGVudGl0eSwgImFsZXJ0IikKICAgICAg
ICAgICAgZW50aXR5LnNob3RzX3JlbWFpbmluZyA9IFBIQVNFM19TSE9UX0NPVU5UCiAgICAgICAg
ICAgIGVudGl0eS5ib3NzX3RpbWVyID0gMAogICAgICAgICAgICBlbnRpdHkudmVsX3ggPSAwCiAg
ICAgICAgICAgIGVudGl0eS52ZWxfeSA9IDAKICAgICAgICAgICAgZW50aXR5LmZsZWVfdGFyZ2V0
X3ggPSBuaWwKICAgICAgICAgICAgZW50aXR5LmZsZWVfdGFyZ2V0X3kgPSBuaWwKICAgICAgICAg
ZW5kLAogICAgICAgICBvbmVudGVycGhhc2UzX3N1bW1vbiA9IGZ1bmN0aW9uKCkKICAgICAgICAg
ICAgRW1vdGlvbnMuc2V0KGVudGl0eSwgImFsZXJ0IikKICAgICAgICAgICAgZW50aXR5LmJvc3Nf
dGltZXIgPSBTVU1NT05fUEFVU0UKICAgICAgICAgICAgZW50aXR5LnZlbF94ID0gMAogICAgICAg
ICAgICBlbnRpdHkudmVsX3kgPSAwCiAgICAgICAgICAgIGVudGl0eS5zdW1tb25fcGVuZGluZyA9
IFNVTU1PTl9CQVRDSF9TSVpFCiAgICAgICAgIGVuZCwKICAgICAgICAgb25lbnRlcnBoYXNlM193
aW5kdXAgPSBmdW5jdGlvbigpCiAgICAgICAgICAgIEVtb3Rpb25zLnNldChlbnRpdHksICJhbGVy
dCIpCiAgICAgICAgICAgIGVudGl0eS5ib3NzX3RpbWVyID0gUEhBU0UzX0RBU0hfQUlNX0RVUkFU
SU9OCiAgICAgICAgICAgIGVudGl0eS52ZWxfeCA9IDAKICAgICAgICAgICAgZW50aXR5LnZlbF95
ID0gMAogICAgICAgICAgICBlbnRpdHkuYWltX2xvY2tlZCA9IGZhbHNlCiAgICAgICAgICAgIGVu
dGl0eS5mbGVlX3RhcmdldF94ID0gbmlsCiAgICAgICAgICAgIGVudGl0eS5mbGVlX3RhcmdldF95
ID0gbmlsCiAgICAgICAgIGVuZCwKICAgICAgICAgb25lbnRlcnBoYXNlM19kYXNoID0gZnVuY3Rp
b24oKQogICAgICAgICAgICBlbnRpdHkuYm9zc190aW1lciA9IERBU0hfRFVSQVRJT04KICAgICAg
ICAgICAgZW50aXR5LnBoYXNlX3N0ZXAgPSAwCiAgICAgICAgIGVuZCwKICAgICAgfQogICB9KQpl
bmQKCi0tIE1haW4gQUkgdXBkYXRlIGZvciBHcmVlbiBXaXRjaCBib3NzCmxvY2FsIGZ1bmN0aW9u
IGJvc3NfYWkoZW50aXR5LCBwbGF5ZXIpCiAgIGlmIG5vdCBlbnRpdHkuYm9zc19mc20gdGhlbgog
ICAgICBpbml0X2ZzbShlbnRpdHkpCiAgIGVuZAoKICAgbG9jYWwgZnNtID0gZW50aXR5LmJvc3Nf
ZnNtCgogICAtLSBDYWxjdWxhdGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvbiB0byBwbGF5ZXIKICAg
bG9jYWwgZGlzdCA9IG1hdGguaHVnZQogICBsb2NhbCBkeCwgZHkgPSAwLCAwCiAgIGlmIHBsYXll
ciB0aGVuCiAgICAgIGxvY2FsIGhiX3AgPSBIaXRib3hVdGlscy5nZXRfaGl0Ym94KHBsYXllcikK
ICAgICAgbG9jYWwgaGJfZSA9IEhpdGJveFV0aWxzLmdldF9oaXRib3goZW50aXR5KQogICAgICBk
eCA9IChoYl9wLnggKyBoYl9wLncgLyAyKSAtIChoYl9lLnggKyBoYl9lLncgLyAyKQogICAgICBk
eSA9IChoYl9wLnkgKyBoYl9wLmggLyAyKSAtIChoYl9lLnkgKyBoYl9lLmggLyAyKQogICAgICBk
aXN0ID0gc3FydChkeCAqIGR4ICsgZHkgKiBkeSkKICAgZW5kCgogICAtLSBDaGVjayBmb3IgcGhh
c2UgdHJhbnNpdGlvbnMKICAgbG9jYWwgY3VycmVudF9waGFzZSA9IGdldF9waGFzZShlbnRpdHkp
CiAgIGlmIGN1cnJlbnRfcGhhc2UgPT0gMiBhbmQgZW50aXR5LmJvc3NfcGhhc2UgPT0gMSB0aGVu
CiAgICAgIGlmIGZzbTp0b19waGFzZTIoKSB0aGVuCiAgICAgICAgIExvZy5pbmZvKCJCb3NzIHBo
YXNlIHRyYW5zaXRpb246IDEgLT4gMiAoSFA6ICIuLmVudGl0eS5ocC4uIi8iLi5lbnRpdHkubWF4
X2hwLi4iKSIpCiAgICAgICAgIHJldHVybgogICAgICBlbmQKICAgZWxzZWlmIGN1cnJlbnRfcGhh
c2UgPT0gMyBhbmQgZW50aXR5LmJvc3NfcGhhc2UgPT0gMiB0aGVuCiAgICAgIGlmIGZzbTp0b19w
aGFzZTMoKSB0aGVuCiAgICAgICAgIExvZy5pbmZvKCJCb3NzIHBoYXNlIHRyYW5zaXRpb246IDIg
LT4gMyAoSFA6ICIuLmVudGl0eS5ocC4uIi8iLi5lbnRpdHkubWF4X2hwLi4iKSIpCiAgICAgICAg
IHJldHVybgogICAgICBlbmQKICAgZW5kCgogICAtLSBTdGF0ZS1zcGVjaWZpYyBiZWhhdmlvcgog
ICBpZiBmc206aXMoInBoYXNlMV9mbGVlIikgdGhlbgogICAgICBpZiBkb19mbGVlKGVudGl0eSwg
cGxheWVyLCBkeCwgZHksIGRpc3QpIHRoZW4KICAgICAgICAgZnNtOnNob290KCkKICAgICAgZW5k
CiAgIGVsc2VpZiBmc206aXMoInBoYXNlMV9zaG9vdCIpIHRoZW4KICAgICAgZG9fc2hvb3QoZW50
aXR5LCBmc20sIHBsYXllciwgZHgsIGR5LCBkaXN0KQogICBlbHNlaWYgZnNtOmlzKCJ0cmFuc2l0
aW9uIikgdGhlbgogICAgICAtLSBJbnZ1bG5lcmFibGUgdHJhbnNpdGlvbiBhbmltYXRpb24KICAg
ICAgZW50aXR5LnZlbF94ID0gMAogICAgICBlbnRpdHkudmVsX3kgPSAwCiAgICAgIGVudGl0eS5i
b3NzX3RpbWVyIC09IDEKCiAgICAgIGlmIGVudGl0eS5ib3NzX3RpbWVyIDw9IDAgdGhlbgogICAg
ICAgICBpZiBlbnRpdHkuYm9zc19waGFzZSA9PSAxIHRoZW4KICAgICAgICAgICAgZnNtOmVudGVy
X3BoYXNlMigpCiAgICAgICAgIGVsc2UKICAgICAgICAgICAgZnNtOmVudGVyX3BoYXNlMygpCiAg
ICAgICAgIGVuZAogICAgICBlbmQKICAgZWxzZWlmIGZzbTppcygicGhhc2UyX2ZsZWUiKSB0aGVu
CiAgICAgIGlmIGRvX2ZsZWUoZW50aXR5LCBwbGF5ZXIsIGR4LCBkeSwgZGlzdCkgdGhlbgogICAg
ICAgICBsb2NhbCBzdGVwX2lkeCA9IChlbnRpdHkucGhhc2Vfc3RlcCBvciAxKSAlICNQSEFTRTJf
U0VRVUVOQ0UKICAgICAgICAgaWYgc3RlcF9pZHggPT0gMCB0aGVuIHN0ZXBfaWR4ID0gI1BIQVNF
Ml9TRVFVRU5DRSBlbmQKCiAgICAgICAgIGxvY2FsIGV2ZW50ID0gUEhBU0UyX1NFUVVFTkNFW3N0
ZXBfaWR4XQogICAgICAgICBmc21bZXZlbnRdKGZzbSkKICAgICAgZW5kCiAgIGVsc2VpZiBmc206
aXMoInBoYXNlMl9zaG9vdCIpIHRoZW4KICAgICAgZG9fc2hvb3QoZW50aXR5LCBmc20sIHBsYXll
ciwgZHgsIGR5LCBkaXN0KQogICBlbHNlaWYgZnNtOmlzKCJwaGFzZTJfc3VtbW9uIikgdGhlbgog
ICAgICAtLSBTcGF3biBlbmVtaWVzIGFyb3VuZCB3aXRjaCAoY2FwcGVkIGF0IDYgdG90YWwgc3Vt
bW9uZWQgZW5lbWllcykKICAgICAgZG9fc3VtbW9uKGVudGl0eSwgd29ybGQpCgogICAgICBlbnRp
dHkuYm9zc190aW1lciAtPSAxCiAgICAgIGlmIGVudGl0eS5ib3NzX3RpbWVyIDw9IDAgdGhlbgog
ICAgICAgICBmc206cmVzdW1lKCkKICAgICAgZW5kCiAgIGVsc2VpZiBmc206aXMoInBoYXNlM19m
bGVlIikgdGhlbgogICAgICBpZiBkb19mbGVlKGVudGl0eSwgcGxheWVyLCBkeCwgZHksIGRpc3Qp
IHRoZW4KICAgICAgICAgLS0gQ3ljbGU6IHNob290LCBzdW1tb24sIHdpbmR1cCwgcmVwZWF0CiAg
ICAgICAgIGxvY2FsIHN0ZXBfaWR4ID0gKGVudGl0eS5waGFzZV9zdGVwIG9yIDEpICUgI1BIQVNF
M19TRVFVRU5DRQogICAgICAgICBpZiBzdGVwX2lkeCA9PSAwIHRoZW4gc3RlcF9pZHggPSAjUEhB
U0UzX1NFUVVFTkNFIGVuZAoKICAgICAgICAgbG9jYWwgZXZlbnQgPSBQSEFTRTNfU0VRVUVOQ0Vb
c3RlcF9pZHhdCiAgICAgICAgIGZzbVtldmVudF0oZnNtKQogICAgICBlbmQKICAgZWxzZWlmIGZz
bTppcygicGhhc2UzX3Nob290IikgdGhlbgogICAgICBkb19zaG9vdChlbnRpdHksIGZzbSwgcGxh
eWVyLCBkeCwgZHksIGRpc3QpCiAgIGVsc2VpZiBmc206aXMoInBoYXNlM19zdW1tb24iKSB0aGVu
CiAgICAgIC0tIFNwYXduIGVuZW1pZXMgYXJvdW5kIHdpdGNoIChzYW1lIGNhcCBhcyBwaGFzZSAy
KQogICAgICBkb19zdW1tb24oZW50aXR5LCB3b3JsZCkKCiAgICAgIGVudGl0eS5ib3NzX3RpbWVy
IC09IDEKICAgICAgaWYgZW50aXR5LmJvc3NfdGltZXIgPD0gMCB0aGVuCiAgICAgICAgIGZzbTpy
ZXN1bWUoKQogICAgICBlbmQKICAgZWxzZWlmIGZzbTppcygicGhhc2UzX3dpbmR1cCIpIHRoZW4K
ICAgICAgLS0gQnJpZWYgcGF1c2UgdG8gYWltIGF0IHBsYXllciBiZWZvcmUgZGFzaGluZwogICAg
ICBpZiBEYXNoLndpbmR1cChlbnRpdHksIGR4LCBkeSwgZGlzdCwgZW50aXR5LmFpbV9sb2NrZWQp
IHRoZW4KICAgICAgICAgZW50aXR5LmFpbV9sb2NrZWQgPSB0cnVlCiAgICAgIGVuZAoKICAgICAg
ZW50aXR5LmJvc3NfdGltZXIgLT0gMQogICAgICBpZiBlbnRpdHkuYm9zc190aW1lciA8PSAwIHRo
ZW4KICAgICAgICAgZnNtOmRhc2goKQogICAgICBlbmQKICAgZWxzZWlmIGZzbTppcygicGhhc2Uz
X2Rhc2giKSB0aGVuCiAgICAgIC0tIE1vdmUgdXNpbmcgc2hhcmVkIGRhc2ggbG9naWMKICAgICAg
ZW50aXR5LmhpdF93YWxsID0gRGFzaC51cGRhdGUoZW50aXR5KQogICAgICBlbnRpdHkuZGlyX3gg
PSBzZ24oZW50aXR5LnZlbF94KSAtLSBVcGRhdGUgZmFjaW5nIHRvIG1hdGNoIG1vdmVtZW50CiAg
ICAgIGVudGl0eS5kaXJfeSA9IHNnbihlbnRpdHkudmVsX3kpCgogICAgICBlbnRpdHkuYm9zc190
aW1lciAtPSAxCiAgICAgIGlmIGVudGl0eS5ib3NzX3RpbWVyIDw9IDAgb3IgZW50aXR5LmhpdF93
YWxsIHRoZW4KICAgICAgICAgZW50aXR5LmhpdF93YWxsID0gZmFsc2UKICAgICAgICAgZnNtOnJl
c3VtZSgpCiAgICAgIGVuZAogICBlbmQKZW5kCgpyZXR1cm4gYm9zc19haQ==
:: src/ai/enemies/skull.lua
b64$LS0gU2t1bGwgZW5lbXkgQUkgcHJvZmlsZQotLSBGU006IGlkbGUg4oaUIGNoYXNpbmcKLS0g
U2t1bGwgaXMgYSBwcmVzc3VyZSBtZWNoYW5pYyAtIGFsd2F5cyBjaGFzZXMgd2hlbiBwbGF5ZXIg
ZXhpc3RzLCBpZGxlcyB3aGVuIG5vdAotLSBVc2VzOiBjaGFzZSBwcmltaXRpdmUKCmxvY2FsIG1h
Y2hpbmUgPSByZXF1aXJlKCJsaWIvbHVhLXN0YXRlLW1hY2hpbmUvc3RhdGVtYWNoaW5lIikKbG9j
YWwgQ2hhc2UgPSByZXF1aXJlKCJzcmMvYWkvcHJpbWl0aXZlcy9jaGFzZSIpCmxvY2FsIEVtb3Rp
b25zID0gcmVxdWlyZSgic3JjL3N5c3RlbXMvZW1vdGlvbnMiKQpsb2NhbCBIaXRib3hVdGlscyA9
IHJlcXVpcmUoInNyYy91dGlscy9oaXRib3hfdXRpbHMiKQoKLS0gSW5pdGlhbGl6ZSBTa3VsbCBG
U00gb24gZW50aXR5CmxvY2FsIGZ1bmN0aW9uIGluaXRfZnNtKGVudGl0eSkKICAgZW50aXR5LnNr
dWxsX2ZzbSA9IG1hY2hpbmUuY3JlYXRlKHsKICAgICAgaW5pdGlhbCA9ICJpZGxlIiwKICAgICAg
ZXZlbnRzID0gewogICAgICAgICB7bmFtZSA9ICJzcG90IiwgZnJvbSA9ICJpZGxlIiwgICAgdG8g
PSAiY2hhc2luZyJ9LAogICAgICAgICB7bmFtZSA9ICJsb3NlIiwgZnJvbSA9ICJjaGFzaW5nIiwg
dG8gPSAiaWRsZSJ9LAogICAgICB9LAogICAgICBjYWxsYmFja3MgPSB7CiAgICAgICAgIG9uZW50
ZXJjaGFzaW5nID0gZnVuY3Rpb24oKQogICAgICAgICAgICBFbW90aW9ucy5zZXQoZW50aXR5LCAi
YWxlcnQiKQogICAgICAgICBlbmQsCiAgICAgICAgIG9uZW50ZXJpZGxlID0gZnVuY3Rpb24oKQog
ICAgICAgICAgICBlbnRpdHkudmVsX3ggPSAwCiAgICAgICAgICAgIGVudGl0eS52ZWxfeSA9IDAK
ICAgICAgICAgZW5kLAogICAgICB9CiAgIH0pCmVuZAoKLS0tIE1haW4gQUkgdXBkYXRlIGZvciBT
a3VsbCBlbmVteSB0eXBlCi0tIEBwYXJhbSBlbnRpdHkgVGhlIHNrdWxsIGVudGl0eQotLSBAcGFy
YW0gcGxheWVyIFRoZSBwbGF5ZXIgZW50aXR5ICh0YXJnZXQsIG1heSBiZSBuaWwpCmxvY2FsIGZ1
bmN0aW9uIHNrdWxsX2FpKGVudGl0eSwgcGxheWVyKQogICAtLSBJbml0aWFsaXplIEZTTSBpZiBu
ZWVkZWQKICAgaWYgbm90IGVudGl0eS5za3VsbF9mc20gdGhlbgogICAgICBpbml0X2ZzbShlbnRp
dHkpCiAgIGVuZAoKICAgbG9jYWwgZnNtID0gZW50aXR5LnNrdWxsX2ZzbQoKICAgaWYgZnNtOmlz
KCJpZGxlIikgdGhlbgogICAgICAtLSBTdG9wIG1vdmVtZW50IChhbHJlYWR5IHNldCBieSBjYWxs
YmFjaykKICAgICAgZW50aXR5LnZlbF94ID0gMAogICAgICBlbnRpdHkudmVsX3kgPSAwCgogICAg
ICAtLSBUcmFuc2l0aW9uOiBwbGF5ZXIgZXhpc3RzCiAgICAgIGlmIHBsYXllciB0aGVuCiAgICAg
ICAgIGZzbTpzcG90KCkKICAgICAgZW5kCiAgIGVsc2VpZiBmc206aXMoImNoYXNpbmciKSB0aGVu
CiAgICAgIC0tIFRyYW5zaXRpb246IHBsYXllciBnb25lCiAgICAgIGlmIG5vdCBwbGF5ZXIgdGhl
bgogICAgICAgICBmc206bG9zZSgpCiAgICAgIGVsc2UKICAgICAgICAgLS0gQ2hhc2UgdGhlIHBs
YXllcgogICAgICAgICBsb2NhbCBoYiA9IEhpdGJveFV0aWxzLmdldF9oaXRib3gocGxheWVyKQog
ICAgICAgICBsb2NhbCB0eCA9IGhiLnggKyBoYi53IC8gMgogICAgICAgICBsb2NhbCB0eSA9IGhi
LnkgKyBoYi5oIC8gMgogICAgICAgICBDaGFzZS50b3dhcmQoZW50aXR5LCB0eCwgdHkpCiAgICAg
IGVuZAogICBlbmQKZW5kCgpyZXR1cm4gc2t1bGxfYWk=
:: src/ai/minions/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/ai/primitives/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/data/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/data/room_layout_data.lua
b64$LS0gUm9vbSBMYXlvdXQgRGF0YQotLSBBU0NJSSBncmlkIGRlZmluaXRpb25zIGZvciByb29t
IGludGVyaW9yIHBhdHRlcm5zCi0tIFNlcGFyYXRlZCBmcm9tIHJvb21fbGF5b3V0cy5sdWEgZm9y
IGNsZWFuZXIgZGF0YS9jb2RlIHNlcGFyYXRpb24KLS0KLS0gR1JJRCBTWVNURU06Ci0tIC0gOcOX
NyBncmlkIG1hcHMgdG8gMjfDlzE0IHJvb20gaW50ZXJpb3IgKGVhY2ggY2VsbCA9IDPDlzIgdGls
ZXMpCi0tIC0gY2VsbF9wYXR0ZXJuIGFycmF5IHNwZWNpZmllcyBob3cgZWFjaCBmZWF0dXJlIGlu
c3RhbmNlIGlzIHBsYWNlZDoKLS0gICAiZiIgID0gZnVsbCAzw5cyIGJsb2NrCi0tICAgInRsIiA9
IHRvcC1sZWZ0IHNpbmdsZSB0aWxlCi0tICAgInRtIiA9IHRvcC1taWRkbGUgc2luZ2xlIHRpbGUK
LS0gICAidHIiID0gdG9wLXJpZ2h0IHNpbmdsZSB0aWxlCi0tICAgImJsIiA9IGJvdHRvbS1sZWZ0
IHNpbmdsZSB0aWxlCi0tICAgImJtIiA9IGJvdHRvbS1taWRkbGUgc2luZ2xlIHRpbGUKLS0gICAi
YnIiID0gYm90dG9tLXJpZ2h0IHNpbmdsZSB0aWxlCi0tIC0gUGF0dGVybiBjeWNsZXMgdGhyb3Vn
aCBmZWF0dXJlcyBpbiByZWFkaW5nIG9yZGVyIChsZWZ0LXRvLXJpZ2h0LCB0b3AtdG8tYm90dG9t
KQoKbG9jYWwgTGF5b3V0RGF0YSA9IHt9CgotLSBGZWF0dXJlIGxlZ2VuZCAoY2hhciDihpIgZmVh
dHVyZSB0eXBlKQpMYXlvdXREYXRhLkZFQVRVUkVfTEVHRU5EID0gewogICBbIi4iXSA9ICJmbG9v
ciIsICAgICAgICAgIC0tIE5vcm1hbCBmbG9vciB0aWxlCiAgIFsiUiJdID0gInJvY2siLCAgICAg
ICAgICAgLS0gU29saWQgcm9jayBvYnN0YWNsZQogICBbIlAiXSA9ICJwaXQiLCAgICAgICAgICAg
IC0tIFBpdCAoYmxvY2tzIHdhbGtpbmcsIG5vdCBwcm9qZWN0aWxlcykKICAgWyJEIl0gPSAiZGVz
dHJ1Y3RpYmxlIiwgICAtLSBCcmVha2FibGUgb2JzdGFjbGUKICAgWyJXIl0gPSAid2FsbCIsICAg
ICAgICAgICAtLSBJbnRlcmlvciB3YWxsIChzb2xpZCkKICAgWyJDIl0gPSAiY2hlc3QiLCAgICAg
ICAgICAtLSBOb3JtYWwgY2hlc3QgKGRyb3BzIDEtMyBwaWNrdXBzKQogICBbIkwiXSA9ICJsb2Nr
ZWRfY2hlc3QiLCAgIC0tIExvY2tlZCBjaGVzdCAocmVxdWlyZXMga2V5LCBkcm9wcyAyLTYgcGlj
a3VwcykKICAgWyJTIl0gPSAic2hvcF9pdGVtIiwgICAgICAtLSBTaG9wIGl0ZW0gcGVkZXN0YWwg
KHB1cmNoYXNhYmxlKQogICBbIk4iXSA9ICJub19zcGF3biIsICAgICAgIC0tIE5vIGVuZW15IHNw
YXduIHpvbmUgKHdhbGthYmxlLCBibG9ja3Mgc3Bhd25zKQogICBbIlQiXSA9ICJ0cmVhc3VyZV9j
aGVzdCIsIC0tIFRyZWFzdXJlIGNoZXN0IChkcm9wcyBtdXRhdGlvbikKfQoKLS0gQ2VsbCBwYXR0
ZXJuIHBvc2l0aW9uIG9mZnNldHMgd2l0aGluIDPDlzIgY2VsbAotLSBLZXlzOiBwb3NpdGlvbiBu
YW1lLCBWYWx1ZXM6IHt0aWxlX29mZnNldF94LCB0aWxlX29mZnNldF95LCB3aWR0aCwgaGVpZ2h0
fQpMYXlvdXREYXRhLkNFTExfUE9TSVRJT05TID0gewogICB0bCA9IHswLCAwLCAxLCAxfSwgLS0g
dG9wLWxlZnQgc2luZ2xlIHRpbGUKICAgdG0gPSB7MSwgMCwgMSwgMX0sIC0tIHRvcC1taWRkbGUg
c2luZ2xlIHRpbGUKICAgdHIgPSB7MiwgMCwgMSwgMX0sIC0tIHRvcC1yaWdodCBzaW5nbGUgdGls
ZQogICBibCA9IHswLCAxLCAxLCAxfSwgLS0gYm90dG9tLWxlZnQgc2luZ2xlIHRpbGUKICAgYm0g
PSB7MSwgMSwgMSwgMX0sIC0tIGJvdHRvbS1taWRkbGUgc2luZ2xlIHRpbGUKICAgYnIgPSB7Miwg
MSwgMSwgMX0sIC0tIGJvdHRvbS1yaWdodCBzaW5nbGUgdGlsZQogICBmICA9IHswLCAwLCAzLCAy
fSwgLS0gZnVsbCAzw5cyIGJsb2NrCn0KCi0tIEJpdG1hc2sgYml0IHBvc2l0aW9ucyBmb3IgM8OX
MiBjZWxsICg2IHRpbGVzKToKLS0gKy0tLSstLS0rLS0tKwotLSB8IDEgfCAyIHwgNCB8ICAgKHRv
cCByb3c6IGJpdHMgMCwgMSwgMikKLS0gKy0tLSstLS0rLS0tKwotLSB8IDggfDE2IHwzMiB8ICAg
KGJvdHRvbSByb3c6IGJpdHMgMywgNCwgNSkKLS0gKy0tLSstLS0rLS0tKwotLSBVc2UgaW4gY2Vs
bF9wYXR0ZXJuOiA2MyA9IGZ1bGwgYmxvY2ssIDcgPSB0b3Agcm93LCA1NiA9IGJvdHRvbSByb3cK
TGF5b3V0RGF0YS5CSVRNQVNLX1BPU0lUSU9OUyA9IHsKICAge3ggPSAwLCB5ID0gMH0sIC0tIGJp
dCAwICh2YWx1ZSAxKTogdG9wLWxlZnQKICAge3ggPSAxLCB5ID0gMH0sIC0tIGJpdCAxICh2YWx1
ZSAyKTogdG9wLW1pZGRsZQogICB7eCA9IDIsIHkgPSAwfSwgLS0gYml0IDIgKHZhbHVlIDQpOiB0
b3AtcmlnaHQKICAge3ggPSAwLCB5ID0gMX0sIC0tIGJpdCAzICh2YWx1ZSA4KTogYm90dG9tLWxl
ZnQKICAge3ggPSAxLCB5ID0gMX0sIC0tIGJpdCA0ICh2YWx1ZSAxNik6IGJvdHRvbS1taWRkbGUK
ICAge3ggPSAyLCB5ID0gMX0sIC0tIGJpdCA1ICh2YWx1ZSAzMik6IGJvdHRvbS1yaWdodAp9Cgot
LSBHcmlkIGRpbWVuc2lvbnMKTGF5b3V0RGF0YS5HUklEX0NPTFMgPSA5CkxheW91dERhdGEuR1JJ
RF9ST1dTID0gNwpMYXlvdXREYXRhLkNFTExfV0lEVEggPSAzICAtLSB0aWxlcyBwZXIgY2VsbCBo
b3Jpem9udGFsbHkKTGF5b3V0RGF0YS5DRUxMX0hFSUdIVCA9IDIgLS0gdGlsZXMgcGVyIGNlbGwg
dmVydGljYWxseQoKLS0gTGF5b3V0IGRlZmluaXRpb25zCi0tIEVhY2ggbGF5b3V0IGhhczoKLS0g
ICByb29tX3R5cGVzOiB0YWJsZSBvZiByb29tIHR5cGVzIHRoaXMgbGF5b3V0IGNhbiBhcHBlYXIg
aW4KLS0gICBsYXlvdXRfdHlwZTogdmlzdWFsIGNhdGVnb3J5IG5hbWUKLS0gICBmbG9vcl9wYXR0
ZXJuOiBmbG9vciB0aWxlIHBhdHRlcm4KLS0gICBncmlkOiBBU0NJSSBncmlkIChuaWwgPSBwdXJl
IGZsb29yKSAtIDkgY29sdW1ucyB4IDcgcm93cwotLSAgIGNlbGxfcGF0dGVybjogb3B0aW9uYWwg
YXJyYXkgb2YgcG9zaXRpb25zIGZvciBlYWNoIGZlYXR1cmUgaW5zdGFuY2UKTGF5b3V0RGF0YS5M
YXlvdXRzID0gewogICAtLSBPUEVOIGxheW91dHMgKHVzZWQgZm9yIHNwZWNpYWwgcm9vbXMpCiAg
IG9wZW4gPSB7CiAgICAgIHJvb21fdHlwZXMgPSB7InN0YXJ0IiwgImJvc3MiLCAiY29tYmF0In0s
CiAgICAgIGxheW91dF90eXBlID0gIm9wZW4iLAogICAgICBmbG9vcl9wYXR0ZXJuID0gInJhbmRv
bSIsCiAgICAgIGdyaWQgPSBuaWwKICAgfSwKCiAgIHRyZWFzdXJlID0gewogICAgICByb29tX3R5
cGVzID0geyJ0cmVhc3VyZSJ9LAogICAgICBsYXlvdXRfdHlwZSA9ICJ0cmVhc3VyZSIsCiAgICAg
IGZsb29yX3BhdHRlcm4gPSAicmFuZG9tIiwKICAgICAgY2VsbF9wYXR0ZXJuID0geyJibSJ9LAog
ICAgICBncmlkID0gewogICAgICAgICAiLi4uLi4uLi4uIiwKICAgICAgICAgIi4uLi4uLi4uLiIs
CiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAgICAiLi4uLlQuLi4uIiwKICAgICAgICAgIi4u
Li4uLi4uLiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAgICAiLi4uLi4uLi4uIiwKICAg
ICAgfQogICB9LAoKICAgLS0gU0hPUCBsYXlvdXQgLSAzIGl0ZW0gcGVkZXN0YWxzCiAgIHNob3Bf
bGF5b3V0ID0gewogICAgICByb29tX3R5cGVzID0geyJzaG9wIn0sCiAgICAgIGxheW91dF90eXBl
ID0gInNob3AiLAogICAgICBmbG9vcl9wYXR0ZXJuID0gInJhbmRvbSIsCiAgICAgIGNlbGxfcGF0
dGVybiA9IHsiYm0iLCAiYm0iLCAiYm0ifSwKICAgICAgZ3JpZCA9IHsKICAgICAgICAgIi4uLi4u
Li4uLiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAgICAiLi4uLi4uLi4uIiwKICAgICAg
ICAgIi4uUy5TLlMuLiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAgICAiLi4uLi4uLi4u
IiwKICAgICAgICAgIi4uLi4uLi4uLiIsCiAgICAgIH0KICAgfSwKCiAgIC0tIENPTUJBVCBsYXlv
dXRzIC0gdmFyaWV0eSBvZiBvYnN0YWNsZSBwYXR0ZXJucwogICBjb3JuZXJzID0gewogICAgICBy
b29tX3R5cGVzID0geyJjb21iYXQifSwKICAgICAgbGF5b3V0X3R5cGUgPSAiY29ybmVycyIsCiAg
ICAgIGZsb29yX3BhdHRlcm4gPSAicmFuZG9tIiwKICAgICAgY2VsbF9wYXR0ZXJuID0gewogICAg
ICAgICAiZiIsIDE2LCAiZiIsICJmIiwgMTYsICJmIiwKICAgICAgICAgMiwgMiwKICAgICAgICAg
MTYsIDE2LAogICAgICAgICAiZiIsIDIsICJmIiwgImYiLCAyLCAiZiIsCiAgICAgIH0sCiAgICAg
IGdyaWQgPSB7CiAgICAgICAgICJSQ1IuLi5STFIiLAogICAgICAgICAiLlIuLi4uLlIuIiwKICAg
ICAgICAgIi4uLi4uLi4uLiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAgICAiLi4uLi4u
Li4uIiwKICAgICAgICAgIi5SLi4uLi5SLiIsCiAgICAgICAgICJSTFIuLi5SQ1IiLAogICAgICB9
CiAgIH0sCgogICBjcm9zc19yb2NrcyA9IHsKICAgICAgcm9vbV90eXBlcyA9IHsiY29tYmF0In0s
CiAgICAgIGxheW91dF90eXBlID0gImNyb3NzIiwKICAgICAgZmxvb3JfcGF0dGVybiA9ICJyYW5k
b20iLAogICAgICBncmlkID0gewogICAgICAgICAiLi4uUi5SLi4uIiwKICAgICAgICAgIi4uLi4u
Li4uLiIsCiAgICAgICAgICJSUi4uLi4uUlIiLAogICAgICAgICAiLi4uLi4uLi4uIiwKICAgICAg
ICAgIlJSLi4uLi5SUiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAgICAiLi4uUi5SLi4u
IiwKICAgICAgfQogICB9LAoKICAgY2VudGVyX2Jsb2NrID0gewogICAgICByb29tX3R5cGVzID0g
eyJjb21iYXQifSwKICAgICAgbGF5b3V0X3R5cGUgPSAiY2VudGVyIiwKICAgICAgZmxvb3JfcGF0
dGVybiA9ICJyYW5kb20iLAogICAgICBjZWxsX3BhdHRlcm4gPSB7CiAgICAgICAgICJiciIsICJm
IiwgImJsIiwKICAgICAgICAgImYiLCAxNiwgImYiLAogICAgICAgICAidHIiLCAiZiIsICJ0bCIs
CiAgICAgIH0sCiAgICAgIGdyaWQgPSB7CiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAgICAi
Li4uLi4uLi4uIiwKICAgICAgICAgIi4uLlJSUi4uLiIsCiAgICAgICAgICIuLi5STFIuLi4iLAog
ICAgICAgICAiLi4uUlJSLi4uIiwKICAgICAgICAgIi4uLi4uLi4uLiIsCiAgICAgICAgICIuLi4u
Li4uLi4iLAogICAgICB9CiAgIH0sCgogICBkaWFnb25hbF9yb2NrcyA9IHsKICAgICAgcm9vbV90
eXBlcyA9IHsiY29tYmF0In0sCiAgICAgIGxheW91dF90eXBlID0gImRpYWdvbmFsIiwKICAgICAg
Zmxvb3JfcGF0dGVybiA9ICJyYW5kb20iLAogICAgICAtLSBCaXRtYXNrIDMzID0gMGIxMDAwMDEg
PSB0b3AtbGVmdCArIGJvdHRvbS1yaWdodCB0aWxlcwogICAgICBjZWxsX3BhdHRlcm4gPSB7CiAg
ICAgICAgIDMzLCAzMywKICAgICAgICAgMTYsCiAgICAgICAgIDMzLCAzMywKICAgICAgfSwKICAg
ICAgZ3JpZCA9IHsKICAgICAgICAgIlIuLi4uLi4uUiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAog
ICAgICAgICAiLi4uLi4uLi4uIiwKICAgICAgICAgIi4uLi5MLi4uLiIsCiAgICAgICAgICIuLi4u
Li4uLi4iLAogICAgICAgICAiLi4uLi4uLi4uIiwKICAgICAgICAgIlIuLi4uLi4uUiIsCiAgICAg
IH0KICAgfSwKCiAgIHBpdF9jcm9zcyA9IHsKICAgICAgcm9vbV90eXBlcyA9IHsiY29tYmF0In0s
CiAgICAgIGxheW91dF90eXBlID0gImNyb3NzIiwKICAgICAgZmxvb3JfcGF0dGVybiA9ICJyYW5k
b20iLAogICAgICBjZWxsX3BhdHRlcm4gPSB7CiAgICAgICAgIDU2LAogICAgICAgICAiYnIiLCAi
ZiIsICJibCIsCiAgICAgICAgICJmIiwgImYiLCAxNiwgImYiLCAiZiIsCiAgICAgICAgICJ0ciIs
ICJmIiwgInRsIiwKICAgICAgICAgNywKICAgICAgfSwKICAgICAgZ3JpZCA9IHsKICAgICAgICAg
Ii4uLi4uLi4uLiIsCiAgICAgICAgICIuLi4uUC4uLi4iLAogICAgICAgICAiLi4uUFBQLi4uIiwK
ICAgICAgICAgIi4uUk5DTlIuLiIsCiAgICAgICAgICIuLi5QUFAuLi4iLAogICAgICAgICAiLi4u
LlAuLi4uIiwKICAgICAgICAgIi4uLi4uLi4uLiIsCiAgICAgIH0KICAgfSwKCiAgIHBpdF9jb3Ju
ZXJzID0gewogICAgICByb29tX3R5cGVzID0geyJjb21iYXQifSwKICAgICAgbGF5b3V0X3R5cGUg
PSAiY29ybmVycyIsCiAgICAgIGZsb29yX3BhdHRlcm4gPSAicmFuZG9tIiwKICAgICAgY2VsbF9w
YXR0ZXJuID0gewogICAgICAgICAiYnIiLCAiZiIsICJmIiwgImYiLCAiZiIsICJibCIsCiAgICAg
ICAgICJmIiwgImYiLAogICAgICAgICAiZiIsICJmIiwKICAgICAgICAgInRyIiwgImYiLCAiZiIs
ICJmIiwgImYiLCAidGwiLAogICAgICB9LAogICAgICBncmlkID0gewogICAgICAgICAiLlBQUC5Q
UFAuIiwKICAgICAgICAgIi5QLi4uLi5QLiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAg
ICAiLi4uLi4uLi4uIiwKICAgICAgICAgIi4uLi4uLi4uLiIsCiAgICAgICAgICIuUC4uLi4uUC4i
LAogICAgICAgICAiLlBQUC5QUFAuIiwKICAgICAgfQogICB9LAoKICAgcmluZyA9IHsKICAgICAg
cm9vbV90eXBlcyA9IHsiY29tYmF0In0sCiAgICAgIGxheW91dF90eXBlID0gInJpbmciLAogICAg
ICBmbG9vcl9wYXR0ZXJuID0gInJhbmRvbSIsCiAgICAgIGNlbGxfcGF0dGVybiA9IHsKICAgICAg
ICAgNTYsIDU2LCA1NiwKICAgICAgICAgMzYsICJmIiwgImYiLCAiZiIsIDksCiAgICAgICAgIDM2
LCAiZiIsIDE2LCAiZiIsIDksCiAgICAgICAgIDM2LCAiZiIsICJmIiwgImYiLCA5LAogICAgICAg
ICA3LCA3LCA3LAogICAgICB9LAogICAgICBncmlkID0gewogICAgICAgICAiLi4uLi4uLi4uIiwK
ICAgICAgICAgIi4uLlJSUi4uLiIsCiAgICAgICAgICIuLlJQUFBSLi4iLAogICAgICAgICAiLi5S
TkxOUi4uIiwKICAgICAgICAgIi4uUlBQUFIuLiIsCiAgICAgICAgICIuLi5SUlIuLi4iLAogICAg
ICAgICAiLi4uLi4uLi4uIiwKICAgICAgfQogICB9LAoKICAgc2NhdHRlcmVkX3JvY2tzID0gewog
ICAgICByb29tX3R5cGVzID0geyJjb21iYXQifSwKICAgICAgbGF5b3V0X3R5cGUgPSAic2NhdHRl
cmVkIiwKICAgICAgZmxvb3JfcGF0dGVybiA9ICJyYW5kb20iLAogICAgICBjZWxsX3BhdHRlcm4g
PSB7CiAgICAgICAgICJ0bCIsICJ0ciIsCiAgICAgICAgICJibSIsCiAgICAgICAgICJ0bSIsICJm
IiwgInRtIiwKICAgICAgICAgImYiLCAxNiwgImYiLAogICAgICAgICAiYm0iLCAiZiIsICJibSIs
CiAgICAgICAgICJ0bSIsCiAgICAgICAgICJibCIsICJiciIKICAgICAgfSwKICAgICAgZ3JpZCA9
IHsKICAgICAgICAgIi5SLi4uLi5SLiIsCiAgICAgICAgICIuLi4uUi4uLi4iLAogICAgICAgICAi
Li4uUk5SLi4uIiwKICAgICAgICAgIi4uLlJDUi4uLiIsCiAgICAgICAgICIuLi5STlIuLi4iLAog
ICAgICAgICAiLi4uLlIuLi4uIiwKICAgICAgICAgIi5SLi4uLi5SLiIsCiAgICAgIH0KICAgfSwK
CiAgIGRlc3RydWN0aWJsZV9jb3JuZXJzID0gewogICAgICByb29tX3R5cGVzID0geyJjb21iYXQi
fSwKICAgICAgbGF5b3V0X3R5cGUgPSAiY29ybmVycyIsCiAgICAgIGZsb29yX3BhdHRlcm4gPSAi
cmFuZG9tIiwKICAgICAgY2VsbF9wYXR0ZXJuID0gewogICAgICAgICAiZiIsICJ0bCIsICJ0ciIs
ICJmIiwKICAgICAgICAgImYiLCAiZiIsCiAgICAgICAgICJmIiwgImYiLAogICAgICAgICAiZiIs
ICJibCIsICJiciIsICJmIiwKICAgICAgfSwKICAgICAgZ3JpZCA9IHsKICAgICAgICAgIkRELi4u
Li5ERCIsCiAgICAgICAgICJELi4uLi4uLkQiLAogICAgICAgICAiLi4uLi4uLi4uIiwKICAgICAg
ICAgIi4uLi4uLi4uLiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAgICAiRC4uLi4uLi5E
IiwKICAgICAgICAgIkRELi4uLi5ERCIsCiAgICAgIH0KICAgfSwKCiAgIG1peGVkID0gewogICAg
ICByb29tX3R5cGVzID0geyJjb21iYXQifSwKICAgICAgbGF5b3V0X3R5cGUgPSAibWl4ZWQiLAog
ICAgICBmbG9vcl9wYXR0ZXJuID0gInJhbmRvbSIsCiAgICAgIGNlbGxfcGF0dGVybiA9IHsKICAg
ICAgICAgImYiLCAiZiIsCiAgICAgICAgICJibSIsCiAgICAgICAgICJmIiwgImJtIiwgImYiLAog
ICAgICAgICAidG0iLAogICAgICAgICAiZiIsICJmIiwKICAgICAgfSwKICAgICAgZ3JpZCA9IHsK
ICAgICAgICAgIlIuLi4uLi4uUiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAgICAiLi4u
LkQuLi4uIiwKICAgICAgICAgIi4uLlBMUC4uLiIsCiAgICAgICAgICIuLi4uRC4uLi4iLAogICAg
ICAgICAiLi4uLi4uLi4uIiwKICAgICAgICAgIlIuLi4uLi4uUiIsCiAgICAgIH0KICAgfSwKCiAg
IGNvcnJpZG9yX3ZlcnRpY2FsID0gewogICAgICByb29tX3R5cGVzID0geyJjb21iYXQifSwKICAg
ICAgcmVxdWlyZXNfbm9fZG9vcnMgPSB7ImVhc3QiLCAid2VzdCJ9LAogICAgICBsYXlvdXRfdHlw
ZSA9ICJjb3JyaWRvciIsCiAgICAgIGZsb29yX3BhdHRlcm4gPSAicmFuZG9tIiwKICAgICAgZ3Jp
ZCA9IHsKICAgICAgICAgIlBQUC4uLlBQUCIsCiAgICAgICAgICJQUFAuLi5QUFAiLAogICAgICAg
ICAiUFBQLi4uUFBQIiwKICAgICAgICAgIlBQUC4uLlBQUCIsCiAgICAgICAgICJQUFAuLi5QUFAi
LAogICAgICAgICAiUFBQLi4uUFBQIiwKICAgICAgICAgIlBQUC4uLlBQUCIsCiAgICAgIH0KICAg
fSwKCiAgIGNvcnJpZG9yX2hvcml6b250YWwgPSB7CiAgICAgIHJvb21fdHlwZXMgPSB7ImNvbWJh
dCJ9LAogICAgICByZXF1aXJlc19ub19kb29ycyA9IHsibm9ydGgiLCAic291dGgifSwKICAgICAg
bGF5b3V0X3R5cGUgPSAiY29ycmlkb3IiLAogICAgICBmbG9vcl9wYXR0ZXJuID0gInJhbmRvbSIs
CiAgICAgIGNlbGxfcGF0dGVybiA9IHsKICAgICAgICAgImYiLCAiZiIsICJmIiwgImYiLCAiZiIs
ICJmIiwgImYiLCAiZiIsICJmIiwKICAgICAgICAgInRtIiwgInRtIiwgInRtIiwgInRtIiwgInRt
IiwgInRtIiwgInRtIiwgInRtIiwgInRtIiwKICAgICAgICAgImJtIiwgImJtIiwgImJtIiwgImJt
IiwgImJtIiwgImJtIiwgImJtIiwgImJtIiwgImJtIiwKICAgICAgICAgImYiLCAiZiIsICJmIiwg
ImYiLCAiZiIsICJmIiwgImYiLCAiZiIsICJmIiwKICAgICAgfSwKICAgICAgZ3JpZCA9IHsKICAg
ICAgICAgIlBQUFBQUFBQUCIsCiAgICAgICAgICJQUFBQUFBQUFAiLAogICAgICAgICAiLi4uLi4u
Li4uIiwKICAgICAgICAgIi4uLi4uLi4uLiIsCiAgICAgICAgICIuLi4uLi4uLi4iLAogICAgICAg
ICAiUFBQUFBQUFBQIiwKICAgICAgICAgIlBQUFBQUFBQUCIsCiAgICAgIH0KICAgfSwKfQoKcmV0
dXJuIExheW91dERhdGE=
:: src/entities/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/game/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/game/config/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/game/config/effects.lua
b64$LS0gRWZmZWN0cyBjb25maWd1cmF0aW9uczogUGxhY2VkQm9tYiwgRXhwbG9zaW9uLCBFbW90
aW9ucywgRmxvYXRpbmdUZXh0CgpyZXR1cm4gewogICAtLSBQbGFjZWQgYm9tYiBlbnRpdHkgKG5v
dCB0aGUgcGlja3VwKQogICBQbGFjZWRCb21iID0gewogICAgICBlbnRpdHlfdHlwZSA9ICJQbGFj
ZWRCb21iIiwKICAgICAgdGFncyA9ICJib21iLGRyYXdhYmxlLHNwcml0ZSx0aW1lcnMsc2hhZG93
LG1pZGRsZWdyb3VuZCIsCiAgICAgIHdpZHRoID0gMTYsCiAgICAgIGhlaWdodCA9IDE2LAogICAg
ICBzcHJpdGVfaW5kZXggPSAzOCwgLS0gQm9tYiBwbGFjZWQgc3ByaXRlCiAgICAgIHNwcml0ZV9p
bmRleF9vZmZzZXRzID0gewogICAgICAgICBkb3duID0gMzgsCiAgICAgICAgIHVwID0gMzgsCiAg
ICAgICAgIGxlZnQgPSAzOCwKICAgICAgICAgcmlnaHQgPSAzOCwKICAgICAgfSwKICAgICAgZnVz
ZV90aW1lID0gMTgwLCAgICAgIC0tIDMgc2Vjb25kcyBhdCA2MGZwcwogICAgICBleHBsb3Npb25f
cmFkaXVzID0gMSwgLS0gMSB0aWxlID0gM3gzIGdyaWQgY2VudGVyZWQgb24gYm9tYgogICAgICBz
aGFkb3dfb2Zmc2V0X3kgPSAzLAogICAgICBzaGFkb3dfd2lkdGggPSAxMiwKICAgfSwKICAgLS0g
RXhwbG9zaW9uIGVmZmVjdCBlbnRpdHkgKHJldXNhYmxlIGZvciBib21icywgZW5lbXkgYXR0YWNr
cywgZXRjLikKICAgRXhwbG9zaW9uID0gewogICAgICBlbnRpdHlfdHlwZSA9ICJFeHBsb3Npb24i
LAogICAgICB0YWdzID0gImV4cGxvc2lvbixjb2xsaWRhYmxlLGRyYXdhYmxlLHNwcml0ZSx0aW1l
cnMsbWlkZGxlZ3JvdW5kIiwKICAgICAgd2lkdGggPSAxNiwKICAgICAgaGVpZ2h0ID0gMTYsCiAg
ICAgIHNwcml0ZV9pbmRleCA9IDQ0LAogICAgICBzcHJpdGVfaW5kZXhfb2Zmc2V0cyA9IHsKICAg
ICAgICAgZG93biA9IDQ0LAogICAgICAgICB1cCA9IDQ0LAogICAgICAgICBsZWZ0ID0gNDQsCiAg
ICAgICAgIHJpZ2h0ID0gNDQsCiAgICAgIH0sCiAgICAgIGhpdGJveF93aWR0aCA9IDE0LAogICAg
ICBoaXRib3hfaGVpZ2h0ID0gMTQsCiAgICAgIGhpdGJveF9vZmZzZXRfeCA9IDEsCiAgICAgIGhp
dGJveF9vZmZzZXRfeSA9IDEsCiAgICAgIGxpZmVzcGFuID0gMzAsCiAgIH0sCiAgIEVtb3Rpb25z
ID0gewogICAgICBhbGVydCA9IHt0ZXh0ID0gIiEiLCBjb2xvciA9IDgsIGR1cmF0aW9uID0gNjB9
LCAtLSByZWQgIiEiIHdoZW4gc3BvdHRpbmcgcGxheWVyCiAgICAgIGNvbmZ1c2VkID0ge3RleHQg
PSAiPyIsIGNvbG9yID0gMTIsIGR1cmF0aW9uID0gOTB9LCAtLSBjeWFuICI-IiB3aGVuIGxvc2lu
ZyBwbGF5ZXIKICAgICAgaWRsZSA9IHt0ZXh0ID0gIuKZqiIsIGNvbG9yID0gMTEsIGR1cmF0aW9u
ID0gMTIwfSwgLS0gZ3JlZW4gIuKZqiIgd2hlbiB3YW5kZXJpbmcKICAgICAgc3R1bm5lZCA9IHt0
ZXh0ID0gIuKYhSIsIGNvbG9yID0gMTAsIGR1cmF0aW9uID0gOTB9LCAtLSB5ZWxsb3cgIuKYhSIg
d2hlbiBzdHVubmVkCiAgICAgIGZvbGxvd2luZyA9IHt0ZXh0ID0gIkAiLCBjb2xvciA9IDE0LCBk
dXJhdGlvbiA9IDYwfSwgLS0gcGluay9mbGVzaCAiQCIgd2hlbiBmb2xsb3dpbmcKICAgICAgY2hh
c2luZyA9IHt0ZXh0ID0gIvCfkLEiLCBjb2xvciA9IDgsIGR1cmF0aW9uID0gNjB9LCAtLSByZWQg
ImNhdCIgd2hlbiBjaGFzaW5nIGVuZW15CiAgICAgIHNlZWtpbmdfZm9vZCA9IHt0ZXh0ID0gIvCf
mJAiLCBjb2xvciA9IDEzLCBkdXJhdGlvbiA9IDYwfSwgLS0gaW5kaWdvL2JsdWUgIm5ldXRyYWwi
IHdoZW4gaHVuZ3J5CiAgICAgIG9mZnNldF95ID0gLTE4LCAgICAgIC0tIFZlcnRpY2FsIG9mZnNl
dCBhYm92ZSBlbnRpdHkKICAgICAgYm91bmNlX3NwZWVkID0gMC4xNSwgLS0gQm91bmNlIGFuaW1h
dGlvbiBzcGVlZAogICAgICBib3VuY2VfaGVpZ2h0ID0gMiwgICAtLSBCb3VuY2UgYW1wbGl0dWRl
IGluIHBpeGVscwogICAgICBvdXRsaW5lX2NvbG9yID0gMCwgICAtLSBCbGFjayBvdXRsaW5lIGZv
ciB2aXNpYmlsaXR5CiAgIH0sCiAgIEZsb2F0aW5nVGV4dCA9IHsKICAgICAgcmlzZV9zcGVlZCA9
IDAuNSwgICAtLSBQaXhlbHMgcGVyIGZyYW1lIHRvIHJpc2UKICAgICAgZHVyYXRpb24gPSA0NSwg
ICAgICAtLSBUb3RhbCBmcmFtZXMgYmVmb3JlIHJlbW92YWwKICAgICAgZmFkZV9kdXJhdGlvbiA9
IDE1LCAtLSBGcmFtZXMgZm9yIGZhZGUgb3V0CiAgICAgIGRhbWFnZV9jb2xvciA9IDgsICAgLS0g
UmVkIGZvciBkYW1hZ2UKICAgICAgaGVhbF9jb2xvciA9IDExLCAgICAtLSBHcmVlbiBmb3IgaGVh
bGluZwogICAgICBwaWNrdXBfY29sb3IgPSAxMCwgIC0tIFllbGxvdyBmb3IgcGlja3VwcwogICAg
ICBvdXRsaW5lX2NvbG9yID0gMCwgIC0tIEJsYWNrIG91dGxpbmUgZm9yIHZpc2liaWxpdHkKICAg
ICAgb2Zmc2V0X3kgPSAtOCwgICAgICAtLSBJbml0aWFsIHZlcnRpY2FsIG9mZnNldCBmcm9tIGVu
dGl0eSB0b3AKICAgICAgc3ByZWFkID0gOCwgICAgICAgICAtLSBIb3Jpem9udGFsIHNwcmVhZCBm
b3IgbXVsdGlwbGUgdGV4dHMKICAgICAgaWNvbl9vZmZzZXRfeCA9IC00LCAtLSBIb3Jpem9udGFs
IG9mZnNldCBmb3IgdGhlIGljb24gcmVsYXRpdmUgdG8gdGV4dCBjZW50ZXIKICAgICAgaWNvbl9v
ZmZzZXRfeSA9IDAsICAtLSBWZXJ0aWNhbCBvZmZzZXQgZm9yIHRoZSBpY29uIHJlbGF0aXZlIHRv
IHRleHQgYmFzZWxpbmUKICAgICAgaWNvbl9zaXplID0gOCwgICAgICAtLSBUYXJnZXQgc2l6ZSB0
byBkcmF3IHRoZSBpY29uIChlLmcuIDh4OCkKICAgfSwKfQ==
:: src/lifecycle/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/physics/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/physics/handlers/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/scenes/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/systems/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/ui/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/utils/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/world/.info.pod
--[[pod,created="2026-01-04 08:23:28",modified="2026-01-04 08:44:13"]]
:: src/world/room_layouts.lua
b64$LS0gUm9vbSBMYXlvdXQgU3lzdGVtIHdpdGggQVNDSUkgRFNMCi0tIExheW91dHMgZGVmaW5l
IGludGVyaW9yIHBhdHRlcm5zIG9mIHJvb21zIChvYnN0YWNsZXMsIHBpdHMsIHJvY2tzKQotLSBE
YXRhIGlzIGxvYWRlZCBmcm9tIGRhdGEvcm9vbV9sYXlvdXRfZGF0YS5sdWEKLS0KLS0gR1JJRCBT
WVNURU06Ci0tIC0gOcOXNyBncmlkIG1hcHMgdG8gMjfDlzE0IHJvb20gaW50ZXJpb3IgKGVhY2gg
Y2VsbCA9IDPDlzIgdGlsZXMpCi0tIC0gY2VsbF9wYXR0ZXJuIGFycmF5IHNwZWNpZmllcyBob3cg
ZWFjaCBmZWF0dXJlIGluc3RhbmNlIGlzIHBsYWNlZAotLSAtIEZlYXR1cmVzIGN5Y2xlIHRocm91
Z2ggY2VsbF9wYXR0ZXJuIGluIHJlYWRpbmcgb3JkZXIKCmxvY2FsIExheW91dERhdGEgPSByZXF1
aXJlKCJzcmMvZGF0YS9yb29tX2xheW91dF9kYXRhIikKCmxvY2FsIFJvb21MYXlvdXRzID0ge30K
Ci0tIEltcG9ydCBkYXRhCmxvY2FsIEZFQVRVUkVfTEVHRU5EID0gTGF5b3V0RGF0YS5GRUFUVVJF
X0xFR0VORApsb2NhbCBDRUxMX1BPU0lUSU9OUyA9IExheW91dERhdGEuQ0VMTF9QT1NJVElPTlMK
bG9jYWwgTGF5b3V0cyA9IExheW91dERhdGEuTGF5b3V0cwoKLS0gR3JpZCBjb25zdGFudHMKbG9j
YWwgQ0VMTF9XSURUSCA9IExheW91dERhdGEuQ0VMTF9XSURUSCBvciAzCmxvY2FsIENFTExfSEVJ
R0hUID0gTGF5b3V0RGF0YS5DRUxMX0hFSUdIVCBvciAyCgotLSBCdWlsZCBMYXlvdXRzQnlSb29t
VHlwZSBkeW5hbWljYWxseSBmcm9tIGVhY2ggbGF5b3V0J3Mgcm9vbV90eXBlcyBmaWVsZApsb2Nh
bCBMYXlvdXRzQnlSb29tVHlwZSA9IHt9CmZvciBuYW1lLCBsYXlvdXQgaW4gcGFpcnMoTGF5b3V0
cykgZG8KICAgaWYgbGF5b3V0LnJvb21fdHlwZXMgdGhlbgogICAgICBmb3IgXywgcm9vbV90eXBl
IGluIGlwYWlycyhsYXlvdXQucm9vbV90eXBlcykgZG8KICAgICAgICAgTGF5b3V0c0J5Um9vbVR5
cGVbcm9vbV90eXBlXSA9IExheW91dHNCeVJvb21UeXBlW3Jvb21fdHlwZV0gb3Ige30KICAgICAg
ICAgYWRkKExheW91dHNCeVJvb21UeXBlW3Jvb21fdHlwZV0sIG5hbWUpCiAgICAgIGVuZAogICBl
bmQKZW5kCgotLS0gUGFyc2UgYSBncmlkIHJvdyBpbnRvIGNlbGxzIChuby1zcGFjZSBmb3JtYXQ6
ICJSLi5SLi5SIikKLS0tIEBwYXJhbSByb3cgU3RyaW5nIGxpa2UgIlIuLlIuLlIuLiIKLS0tIEBy
ZXR1cm4gVGFibGUgb2YgY2hhcmFjdGVycwpsb2NhbCBmdW5jdGlvbiBwYXJzZV9yb3cocm93KQog
ICBsb2NhbCBjZWxscyA9IHt9CiAgIGZvciBpID0gMSwgI3JvdyBkbwogICAgICBsb2NhbCBjaGFy
ID0gcm93OnN1YihpLCBpKQogICAgICBpZiBjaGFyIH49ICIgIiB0aGVuIC0tIFNraXAgc3BhY2Vz
IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5CiAgICAgICAgIGFkZChjZWxscywgY2hhcikKICAg
ICAgZW5kCiAgIGVuZAogICByZXR1cm4gY2VsbHMKZW5kCgotLS0gUGFyc2UgZW50aXJlIGdyaWQg
aW50byAyRCBzdHJ1Y3R1cmUgKGNhY2hlZCBvbiBsYXlvdXQpCi0tLSBAcGFyYW0gbGF5b3V0IExh
eW91dCBkZWZpbml0aW9uCi0tLSBAcmV0dXJuIHtyb3dzLCBjb2xzLCBjZWxsc30KbG9jYWwgZnVu
Y3Rpb24gZ2V0X3BhcnNlZF9ncmlkKGxheW91dCkKICAgaWYgbm90IGxheW91dCBvciBub3QgbGF5
b3V0LmdyaWQgdGhlbiByZXR1cm4gbmlsIGVuZAoKICAgLS0gUmV0dXJuIGNhY2hlZCB2ZXJzaW9u
IGlmIGF2YWlsYWJsZQogICBpZiBsYXlvdXQuX3BhcnNlZCB0aGVuIHJldHVybiBsYXlvdXQuX3Bh
cnNlZCBlbmQKCiAgIGxvY2FsIHJvd3MgPSAjbGF5b3V0LmdyaWQKICAgbG9jYWwgY2VsbHMgPSB7
fQogICBsb2NhbCBjb2xzID0gMAoKICAgZm9yIHIsIHJvd19zdHIgaW4gaXBhaXJzKGxheW91dC5n
cmlkKSBkbwogICAgICBjZWxsc1tyXSA9IHBhcnNlX3Jvdyhyb3dfc3RyKQogICAgICBjb2xzID0g
bWF4KGNvbHMsICNjZWxsc1tyXSkKICAgZW5kCgogICBsYXlvdXQuX3BhcnNlZCA9IHtyb3dzID0g
cm93cywgY29scyA9IGNvbHMsIGNlbGxzID0gY2VsbHN9CiAgIHJldHVybiBsYXlvdXQuX3BhcnNl
ZAplbmQKCi0tLSBDaGVjayBpZiBhIGxheW91dCBpcyB2YWxpZCBmb3IgYSByb29tIGJhc2VkIG9u
IGRvb3IgcmVxdWlyZW1lbnRzCi0tLSBAcGFyYW0gbGF5b3V0X25hbWUgTmFtZSBvZiB0aGUgbGF5
b3V0Ci0tLSBAcGFyYW0gcm9vbSBSb29tIG9iamVjdCB3aXRoIGRvb3JzIHRhYmxlCi0tLSBAcmV0
dXJuIHRydWUgaWYgbGF5b3V0IGNhbiBiZSB1c2VkCmxvY2FsIGZ1bmN0aW9uIGlzX2xheW91dF92
YWxpZF9mb3Jfcm9vbShsYXlvdXRfbmFtZSwgcm9vbSkKICAgbG9jYWwgbGF5b3V0ID0gTGF5b3V0
c1tsYXlvdXRfbmFtZV0KICAgaWYgbm90IGxheW91dCBvciBub3QgbGF5b3V0LnJlcXVpcmVzX25v
X2Rvb3JzIHRoZW4gcmV0dXJuIHRydWUgZW5kCiAgIGlmIG5vdCByb29tIG9yIG5vdCByb29tLmRv
b3JzIHRoZW4gcmV0dXJuIHRydWUgZW5kCgogICAtLSBDaGVjayBpZiByb29tIGhhcyBhbnkgb2Yg
dGhlIGZvcmJpZGRlbiBkb29ycwogICBmb3IgXywgZm9yYmlkZGVuX2RpciBpbiBpcGFpcnMobGF5
b3V0LnJlcXVpcmVzX25vX2Rvb3JzKSBkbwogICAgICBpZiByb29tLmRvb3JzW2ZvcmJpZGRlbl9k
aXJdIHRoZW4KICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgIGVuZAogICBlbmQKICAgcmV0dXJu
IHRydWUKZW5kCgotLS0gR2V0IGEgcmFuZG9tIGxheW91dCBmb3IgYSByb29tIHR5cGUKLS0tIEBw
YXJhbSByb29tX3R5cGUgImNvbWJhdCIsICJzdGFydCIsICJib3NzIiwgZXRjLgotLS0gQHBhcmFt
IHJvb20gT3B0aW9uYWwgcm9vbSBvYmplY3QgKGZvciBkb29yLWJhc2VkIGZpbHRlcmluZykKLS0t
IEByZXR1cm4gTGF5b3V0IGRlZmluaXRpb24KZnVuY3Rpb24gUm9vbUxheW91dHMuZ2V0X3JhbmRv
bV9sYXlvdXQocm9vbV90eXBlLCByb29tKQogICBsb2NhbCBhbGxfY2FuZGlkYXRlcyA9IExheW91
dHNCeVJvb21UeXBlW3Jvb21fdHlwZV0gb3IgTGF5b3V0c0J5Um9vbVR5cGUuY29tYmF0IG9yIHsi
b3BlbiJ9CgogICAtLSBGaWx0ZXIgYnkgZG9vciByZXF1aXJlbWVudHMgaWYgcm9vbSBwcm92aWRl
ZAogICBsb2NhbCBjYW5kaWRhdGVzID0ge30KICAgZm9yIF8sIG5hbWUgaW4gaXBhaXJzKGFsbF9j
YW5kaWRhdGVzKSBkbwogICAgICBpZiBpc19sYXlvdXRfdmFsaWRfZm9yX3Jvb20obmFtZSwgcm9v
bSkgdGhlbgogICAgICAgICBhZGQoY2FuZGlkYXRlcywgbmFtZSkKICAgICAgZW5kCiAgIGVuZAoK
ICAgLS0gRmFsbGJhY2sgdG8gb3BlbiBpZiBubyB2YWxpZCBjYW5kaWRhdGVzCiAgIGlmICNjYW5k
aWRhdGVzID09IDAgdGhlbgogICAgICBjYW5kaWRhdGVzID0geyJvcGVuIn0KICAgZW5kCgogICBs
b2NhbCBuYW1lID0gY2FuZGlkYXRlc1tmbHIocm5kKCNjYW5kaWRhdGVzKSkgKyAxXQogICBsb2Nh
bCBsYXlvdXQgPSBMYXlvdXRzW25hbWVdCiAgIGxheW91dC5uYW1lID0gbmFtZQogICByZXR1cm4g
bGF5b3V0CmVuZAoKLS0tIEdldCBhIHNwZWNpZmljIGxheW91dCBieSBuYW1lCi0tIEBwYXJhbSBu
YW1lIExheW91dCBuYW1lCi0tIEByZXR1cm4gTGF5b3V0IGRlZmluaXRpb24gb3IgbmlsCmZ1bmN0
aW9uIFJvb21MYXlvdXRzLmdldF9sYXlvdXQobmFtZSkKICAgcmV0dXJuIExheW91dHNbbmFtZV0K
ZW5kCgotLS0gR2V0IGFsbCBmZWF0dXJlcyBmcm9tIGEgbGF5b3V0IHdpdGggdGhlaXIgdGlsZSBw
b3NpdGlvbnMKLS0tIFJldHVybnMgYSBsaXN0IG9mIHtmZWF0dXJlLCB0aWxlX3gsIHRpbGVfeX0g
Zm9yIGVhY2ggZmVhdHVyZSB0aWxlCi0tLSBAcGFyYW0gbGF5b3V0IExheW91dCBkZWZpbml0aW9u
Ci0tLSBAcGFyYW0gcm9vbV9pbm5lcl94IFJvb20gaW5uZXIgbGVmdCBlZGdlIGluIHRpbGVzIChh
ZnRlciB3YWxsKQotLS0gQHBhcmFtIHJvb21faW5uZXJfeSBSb29tIGlubmVyIHRvcCBlZGdlIGlu
IHRpbGVzIChhZnRlciB3YWxsKQotLS0gQHJldHVybiBBcnJheSBvZiB7ZmVhdHVyZSwgdHgsIHR5
fQpmdW5jdGlvbiBSb29tTGF5b3V0cy5nZXRfYWxsX2ZlYXR1cmVzKGxheW91dCwgcm9vbV9pbm5l
cl94LCByb29tX2lubmVyX3kpCiAgIGxvY2FsIHBhcnNlZCA9IGdldF9wYXJzZWRfZ3JpZChsYXlv
dXQpCiAgIGlmIG5vdCBwYXJzZWQgdGhlbiByZXR1cm4ge30gZW5kCgogICBsb2NhbCBmZWF0dXJl
cyA9IHt9CiAgIGxvY2FsIGNlbGxfcGF0dGVybiA9IGxheW91dC5jZWxsX3BhdHRlcm4KICAgbG9j
YWwgcGF0dGVybl9pbmRleCA9IDEKCiAgIC0tIEl0ZXJhdGUgZ3JpZCBpbiByZWFkaW5nIG9yZGVy
ICh0b3AtdG8tYm90dG9tLCBsZWZ0LXRvLXJpZ2h0KQogICBmb3IgZ3kgPSAxLCBwYXJzZWQucm93
cyBkbwogICAgICBmb3IgZ3ggPSAxLCAjcGFyc2VkLmNlbGxzW2d5XSBkbwogICAgICAgICBsb2Nh
bCBjaGFyID0gcGFyc2VkLmNlbGxzW2d5XVtneF0KICAgICAgICAgbG9jYWwgZmVhdHVyZV90eXBl
ID0gRkVBVFVSRV9MRUdFTkRbY2hhcl0KCiAgICAgICAgIGlmIGZlYXR1cmVfdHlwZSBhbmQgZmVh
dHVyZV90eXBlIH49ICJmbG9vciIgdGhlbgogICAgICAgICAgICAtLSBHZXQgcG9zaXRpb24gbW9k
ZSBmb3IgdGhpcyBmZWF0dXJlCiAgICAgICAgICAgIGxvY2FsIHBvc19tb2RlID0gNjMgLS0gZGVm
YXVsdCB0byBmdWxsIChhbGwgNiBiaXRzIHNldCkKICAgICAgICAgICAgaWYgY2VsbF9wYXR0ZXJu
IHRoZW4KICAgICAgICAgICAgICAgcG9zX21vZGUgPSBjZWxsX3BhdHRlcm5bcGF0dGVybl9pbmRl
eF0gb3IgNjMKICAgICAgICAgICAgICAgcGF0dGVybl9pbmRleCA9IHBhdHRlcm5faW5kZXggKyAx
CiAgICAgICAgICAgICAgIGlmIHBhdHRlcm5faW5kZXggPiAjY2VsbF9wYXR0ZXJuIHRoZW4KICAg
ICAgICAgICAgICAgICAgcGF0dGVybl9pbmRleCA9IDEgLS0gY3ljbGUKICAgICAgICAgICAgICAg
ZW5kCiAgICAgICAgICAgIGVuZAoKICAgICAgICAgICAgLS0gQ2FsY3VsYXRlIGJhc2UgdGlsZSBw
b3NpdGlvbiAoMC1pbmRleGVkIGZyb20gcm9vbSBpbm5lcikKICAgICAgICAgICAgbG9jYWwgYmFz
ZV90eCA9IChneCAtIDEpICogQ0VMTF9XSURUSAogICAgICAgICAgICBsb2NhbCBiYXNlX3R5ID0g
KGd5IC0gMSkgKiBDRUxMX0hFSUdIVAoKICAgICAgICAgICAgaWYgdHlwZShwb3NfbW9kZSkgPT0g
Im51bWJlciIgdGhlbgogICAgICAgICAgICAgICAtLSBCaXRtYXNrIG1vZGU6IGl0ZXJhdGUgYml0
cyBhbmQgYWRkIHRpbGVzIGZvciBlYWNoIHNldCBiaXQKICAgICAgICAgICAgICAgbG9jYWwgQklU
TUFTS19QT1NJVElPTlMgPSBMYXlvdXREYXRhLkJJVE1BU0tfUE9TSVRJT05TCiAgICAgICAgICAg
ICAgIGZvciBiaXRfaWR4ID0gMCwgNSBkbwogICAgICAgICAgICAgICAgICBpZiAocG9zX21vZGUg
JiAoMSA8PCBiaXRfaWR4KSkgfj0gMCB0aGVuCiAgICAgICAgICAgICAgICAgICAgIGxvY2FsIHBv
cyA9IEJJVE1BU0tfUE9TSVRJT05TW2JpdF9pZHggKyAxXQogICAgICAgICAgICAgICAgICAgICBs
b2NhbCB0eCA9IHJvb21faW5uZXJfeCArIGJhc2VfdHggKyBwb3MueAogICAgICAgICAgICAgICAg
ICAgICBsb2NhbCB0eSA9IHJvb21faW5uZXJfeSArIGJhc2VfdHkgKyBwb3MueQogICAgICAgICAg
ICAgICAgICAgICBhZGQoZmVhdHVyZXMsIHtmZWF0dXJlID0gZmVhdHVyZV90eXBlLCB0eCA9IHR4
LCB0eSA9IHR5fSkKICAgICAgICAgICAgICAgICAgZW5kCiAgICAgICAgICAgICAgIGVuZAogICAg
ICAgICAgICBlbHNlCiAgICAgICAgICAgICAgIC0tIFN0cmluZyBtb2RlOiBleGlzdGluZyBzaW5n
bGUtcG9zaXRpb24gbG9naWMKICAgICAgICAgICAgICAgbG9jYWwgcG9zX2RhdGEgPSBDRUxMX1BP
U0lUSU9OU1twb3NfbW9kZV0gb3IgQ0VMTF9QT1NJVElPTlMuZgogICAgICAgICAgICAgICBsb2Nh
bCBvZmZzZXRfeCwgb2Zmc2V0X3ksIHdpZHRoLCBoZWlnaHQgPSBwb3NfZGF0YVsxXSwgcG9zX2Rh
dGFbMl0sIHBvc19kYXRhWzNdLCBwb3NfZGF0YVs0XQoKICAgICAgICAgICAgICAgLS0gQWRkIHRp
bGVzIGJhc2VkIG9uIHdpZHRoL2hlaWdodAogICAgICAgICAgICAgICBmb3IgZHkgPSAwLCBoZWln
aHQgLSAxIGRvCiAgICAgICAgICAgICAgICAgIGZvciBkeCA9IDAsIHdpZHRoIC0gMSBkbwogICAg
ICAgICAgICAgICAgICAgICBsb2NhbCB0eCA9IHJvb21faW5uZXJfeCArIGJhc2VfdHggKyBvZmZz
ZXRfeCArIGR4CiAgICAgICAgICAgICAgICAgICAgIGxvY2FsIHR5ID0gcm9vbV9pbm5lcl95ICsg
YmFzZV90eSArIG9mZnNldF95ICsgZHkKICAgICAgICAgICAgICAgICAgICAgYWRkKGZlYXR1cmVz
LCB7ZmVhdHVyZSA9IGZlYXR1cmVfdHlwZSwgdHggPSB0eCwgdHkgPSB0eX0pCiAgICAgICAgICAg
ICAgICAgIGVuZAogICAgICAgICAgICAgICBlbmQKICAgICAgICAgICAgZW5kCiAgICAgICAgIGVu
ZAogICAgICBlbmQKICAgZW5kCgogICByZXR1cm4gZmVhdHVyZXMKZW5kCgotLS0gR2V0IHRoZSBm
ZWF0dXJlIGF0IGEgc3BlY2lmaWMgdGlsZSBwb3NpdGlvbiAoZm9yIHNwYXduIHZhbGlkYXRpb24p
Ci0tLSBAcGFyYW0gbGF5b3V0IExheW91dCBkZWZpbml0aW9uCi0tLSBAcGFyYW0gZ3ggR3JpZCBY
IHBvc2l0aW9uICgwLWluZGV4ZWQgZnJvbSByb29tIGxlZnQgaW5uZXIpCi0tLSBAcGFyYW0gZ3kg
R3JpZCBZIHBvc2l0aW9uICgwLWluZGV4ZWQgZnJvbSByb29tIHRvcCBpbm5lcikKLS0tIEBwYXJh
bSByb29tX3cgUm9vbSBpbm5lciB3aWR0aCBpbiB0aWxlcyAoc2hvdWxkIGJlIDI3KQotLS0gQHBh
cmFtIHJvb21faCBSb29tIGlubmVyIGhlaWdodCBpbiB0aWxlcyAoc2hvdWxkIGJlIDE0KQotLS0g
QHJldHVybiBGZWF0dXJlIHR5cGUgc3RyaW5nIG9yIG5pbCBmb3IgZmxvb3IKZnVuY3Rpb24gUm9v
bUxheW91dHMuZ2V0X2ZlYXR1cmVfYXQobGF5b3V0LCBneCwgZ3ksIHJvb21fdywgcm9vbV9oKQog
ICBsb2NhbCBwYXJzZWQgPSBnZXRfcGFyc2VkX2dyaWQobGF5b3V0KQogICBpZiBub3QgcGFyc2Vk
IHRoZW4gcmV0dXJuIG5pbCBlbmQKCiAgIC0tIE1hcCB0aWxlIHBvc2l0aW9uIHRvIGdyaWQgY2Vs
bAogICBsb2NhbCBncmlkX3ggPSBmbHIoZ3ggLyBDRUxMX1dJRFRIKSArIDEKICAgbG9jYWwgZ3Jp
ZF95ID0gZmxyKGd5IC8gQ0VMTF9IRUlHSFQpICsgMQoKICAgLS0gQm91bmRzIGNoZWNrCiAgIGlm
IGdyaWRfeSA8IDEgb3IgZ3JpZF95ID4gcGFyc2VkLnJvd3MgdGhlbiByZXR1cm4gbmlsIGVuZAog
ICBpZiBncmlkX3ggPCAxIG9yIGdyaWRfeCA_ICNwYXJzZWQuY2VsbHNbZ3JpZF95XSB0aGVuIHJl
dHVybiBuaWwgZW5kCgogICBsb2NhbCBjaGFyID0gcGFyc2VkLmNlbGxzW2dyaWRfeV1bZ3JpZF94
XQogICBsb2NhbCBmZWF0dXJlID0gRkVBVFVSRV9MRUdFTkRbY2hhcl0KCiAgIGlmIGZlYXR1cmUg
PT0gImZsb29yIiB0aGVuIHJldHVybiBuaWwgZW5kCgogICAtLSBGb3Igc2ltcGxlIGNoZWNrLCBh
c3N1bWUgZmVhdHVyZSBmaWxscyB0aGUgY2VsbAogICAtLSBNb3JlIHByZWNpc2UgY2hlY2tpbmcg
d291bGQgbmVlZCB0byBjb3VudCBmZWF0dXJlcyBhbmQgYXBwbHkgY2VsbF9wYXR0ZXJuCiAgIHJl
dHVybiBmZWF0dXJlCmVuZAoKLS0tIEdldCB0aWxlIGZvciBhIGZlYXR1cmUgdHlwZQotLS0gQHBh
cmFtIGZlYXR1cmUgRmVhdHVyZSB0eXBlIHN0cmluZyAoInJvY2siLCAicGl0IiwgImRlc3RydWN0
aWJsZSIsICJjaGVzdCIsICJsb2NrZWRfY2hlc3QiLCAidHJlYXN1cmVfY2hlc3QiKQotLS0gQHJl
dHVybiBUaWxlIG51bWJlcgpmdW5jdGlvbiBSb29tTGF5b3V0cy5nZXRfZmVhdHVyZV90aWxlKGZl
YXR1cmUpCiAgIGlmIGZlYXR1cmUgPT0gInJvY2siIHRoZW4KICAgICAgcmV0dXJuIFJPQ0tfVElM
RVNbZmxyKHJuZCgjUk9DS19USUxFUykpICsgMV0KICAgZWxzZWlmIGZlYXR1cmUgPT0gInBpdCIg
dGhlbgogICAgICByZXR1cm4gUElUX1RJTEUKICAgZWxzZWlmIGZlYXR1cmUgPT0gImRlc3RydWN0
aWJsZSIgdGhlbgogICAgICByZXR1cm4gREVTVFJVQ1RJQkxFX1RJTEVTW2ZscihybmQoI0RFU1RS
VUNUSUJMRV9USUxFUykpICsgMV0KICAgZWxzZWlmIGZlYXR1cmUgPT0gIndhbGwiIHRoZW4KICAg
ICAgcmV0dXJuIFdBTExfVElMRQogICBlbHNlaWYgZmVhdHVyZSA9PSAiY2hlc3QiIHRoZW4KICAg
ICAgcmV0dXJuIENIRVNUX1RJTEUKICAgZWxzZWlmIGZlYXR1cmUgPT0gImxvY2tlZF9jaGVzdCIg
dGhlbgogICAgICByZXR1cm4gTE9DS0VEX0NIRVNUX1RJTEUKICAgZWxzZWlmIGZlYXR1cmUgPT0g
InRyZWFzdXJlX2NoZXN0IiB0aGVuCiAgICAgIHJldHVybiBUUkVBU1VSRV9DSEVTVF9USUxFCiAg
IGVuZAogICByZXR1cm4gbmlsCmVuZAoKLS0tIENoZWNrIGlmIGEgdGlsZSBpcyBhIGZlYXR1cmUg
dGlsZSAocm9jaywgcGl0LCBkZXN0cnVjdGlibGUsIG9yIGNoZXN0KQotLSBAcGFyYW0gdGlsZSBU
aWxlIG51bWJlcgotLSBAcmV0dXJuIEZlYXR1cmUgdHlwZSBzdHJpbmcgb3IgbmlsCmZ1bmN0aW9u
IFJvb21MYXlvdXRzLmdldF90aWxlX2ZlYXR1cmVfdHlwZSh0aWxlKQogICAtLSBDaGVjayByb2Nr
cwogICBmb3IgXywgdCBpbiBpcGFpcnMoUk9DS19USUxFUykgZG8KICAgICAgaWYgdGlsZSA9PSB0
IHRoZW4gcmV0dXJuICJyb2NrIiBlbmQKICAgZW5kCiAgIC0tIENoZWNrIHBpdAogICBpZiB0aWxl
ID09IFBJVF9USUxFIHRoZW4gcmV0dXJuICJwaXQiIGVuZAogICAtLSBDaGVjayBkZXN0cnVjdGli
bGVzCiAgIGZvciBfLCB0IGluIGlwYWlycyhERVNUUlVDVElCTEVfVElMRVMpIGRvCiAgICAgIGlm
IHRpbGUgPT0gdCB0aGVuIHJldHVybiAiZGVzdHJ1Y3RpYmxlIiBlbmQKICAgZW5kCiAgIC0tIENo
ZWNrIGNoZXN0cwogICBpZiB0aWxlID09IENIRVNUX1RJTEUgdGhlbiByZXR1cm4gImNoZXN0IiBl
bmQKICAgaWYgdGlsZSA9PSBMT0NLRURfQ0hFU1RfVElMRSB0aGVuIHJldHVybiAibG9ja2VkX2No
ZXN0IiBlbmQKICAgaWYgdGlsZSA9PSBUUkVBU1VSRV9DSEVTVF9USUxFIHRoZW4gcmV0dXJuICJ0
cmVhc3VyZV9jaGVzdCIgZW5kCiAgIHJldHVybiBuaWwKZW5kCgotLS0gQ2hlY2sgaWYgYSB0aWxl
IHBvc2l0aW9uIGlzIGEgZmxvb3IgdGlsZSAoZm9yIHNwYXduIHZhbGlkYXRpb24pCi0tIEBwYXJh
bSB0eCBUaWxlIFggcG9zaXRpb24KLS0gQHBhcmFtIHR5IFRpbGUgWSBwb3NpdGlvbgotLSBAcmV0
dXJuIHRydWUgaWYgZmxvb3IgdGlsZQpmdW5jdGlvbiBSb29tTGF5b3V0cy5pc19mbG9vcl90aWxl
KHR4LCB0eSkKICAgbG9jYWwgdGlsZSA9IG1nZXQodHgsIHR5KQogICBpZiB0aWxlID09IDAgdGhl
biByZXR1cm4gZmFsc2UgZW5kCiAgIGZvciBfLCBmIGluIGlwYWlycyhGTE9PUl9USUxFUykgZG8K
ICAgICAgaWYgdGlsZSA9PSBmIHRoZW4gcmV0dXJuIHRydWUgZW5kCiAgIGVuZAogICByZXR1cm4g
ZmFsc2UKZW5kCgpyZXR1cm4gUm9vbUxheW91dHM=
:: src/world/wave_patterns.lua
b64$LS0gV2F2ZSBQYXR0ZXJuIFN5c3RlbSB3aXRoIFBvc2l0aW9uYWwgRFNMCi0tIFBhdHRlcm5z
IGFyZSBBU0NJSSBncmlkcyB0aGF0IG1hcCB0byByb29tIHBvc2l0aW9ucwoKbG9jYWwgV2F2ZVBh
dHRlcm5zID0ge30KCi0tIEVuZW15IHR5cGUgbGVnZW5kIChjaGFyIOKGkiBlbmVteSB0eXBlKQps
b2NhbCBFTkVNWV9MRUdFTkQgPSB7CiAgIFMgPSAiU2t1bGtlciIsCiAgIEggPSAiU2hvb3RlciIs
CiAgIEQgPSAiRGFzaGVyIgp9CgotLSBQYXR0ZXJuIGRlZmluaXRpb25zIHdpdGggZGlmZmljdWx0
eSByYXRpbmdzCmxvY2FsIFBhdHRlcm5zID0gewogICAtLSBFQVNZIChkaWZmaWN1bHR5IDEpCiAg
IHNrdWxrZXJfcGFpciA9IHsKICAgICAgZGlmZmljdWx0eSA9IDEsCiAgICAgIGdyaWQgPSB7CiAg
ICAgICAgICIuIC4gLiIsCiAgICAgICAgICJTIC4gUyIsCiAgICAgICAgICIuIC4gLiIsCiAgICAg
IH0KICAgfSwKICAgbG9uZV9zaG9vdGVyID0gewogICAgICBkaWZmaWN1bHR5ID0gMSwKICAgICAg
Z3JpZCA9IHsKICAgICAgICAgIi4gLiAuIiwKICAgICAgICAgIi4gSCAuIiwKICAgICAgICAgIi4g
LiAuIiwKICAgICAgfQogICB9LAogICBza3Vsa2VyX2xpbmUgPSB7CiAgICAgIGRpZmZpY3VsdHkg
PSAxLAogICAgICBncmlkID0gewogICAgICAgICAiLiAuIC4gLiAuIiwKICAgICAgICAgIi4gUyBT
IFMgLiIsCiAgICAgICAgICIuIC4gLiAuIC4iLAogICAgICB9CiAgIH0sCgogICAtLSBNRURJVU0g
KGRpZmZpY3VsdHkgMikKICAgYW1idXNoID0gewogICAgICBkaWZmaWN1bHR5ID0gMiwKICAgICAg
Z3JpZCA9IHsKICAgICAgICAgIlMgLiAuIC4gUyIsCiAgICAgICAgICIuIC4gLiAuIC4iLAogICAg
ICAgICAiLiAuIEggLiAuIiwKICAgICAgICAgIi4gLiAuIC4gLiIsCiAgICAgICAgICJTIC4gLiAu
IFMiLAogICAgICB9CiAgIH0sCiAgIGZsYW5rZXJzID0gewogICAgICBkaWZmaWN1bHR5ID0gMiwK
ICAgICAgZ3JpZCA9IHsKICAgICAgICAgIi4gRCAuIEQgLiIsCiAgICAgICAgICIuIC4gLiAuIC4i
LAogICAgICAgICAiLiAuIC4gLiAuIiwKICAgICAgfQogICB9LAogICBzaG9vdGVyX2d1YXJkID0g
ewogICAgICBkaWZmaWN1bHR5ID0gMiwKICAgICAgZ3JpZCA9IHsKICAgICAgICAgIi4gLiAuIC4g
LiIsCiAgICAgICAgICIuIFMgLiBTIC4iLAogICAgICAgICAiLiAuIEggLiAuIiwKICAgICAgICAg
Ii4gUyAuIFMgLiIsCiAgICAgICAgICIuIC4gLiAuIC4iLAogICAgICB9CiAgIH0sCgogICAtLSBI
QVJEIChkaWZmaWN1bHR5IDMpCiAgIGNoYW9zID0gewogICAgICBkaWZmaWN1bHR5ID0gMywKICAg
ICAgZ3JpZCA9IHsKICAgICAgICAgIlMgLiBTIC4gUyIsCiAgICAgICAgICIuIC4gLiAuIC4iLAog
ICAgICAgICAiLiAuIEQgLiAuIiwKICAgICAgICAgIi4gLiAuIC4gLiIsCiAgICAgICAgICJIIC4g
LiAuIEgiLAogICAgICB9CiAgIH0sCiAgIGRhc2hlcl93YWxsID0gewogICAgICBkaWZmaWN1bHR5
ID0gMywKICAgICAgZ3JpZCA9IHsKICAgICAgICAgIi4gLiAuIC4gLiIsCiAgICAgICAgICJEIC4g
RCAuIEQiLAogICAgICAgICAiLiAuIC4gLiAuIiwKICAgICAgICAgIi4gLiBIIC4gLiIsCiAgICAg
ICAgICIuIC4gLiAuIC4iLAogICAgICB9CiAgIH0sCiAgIHNob290ZXJfbmVzdCA9IHsKICAgICAg
ZGlmZmljdWx0eSA9IDMsCiAgICAgIGdyaWQgPSB7CiAgICAgICAgICJIIC4gLiAuIEgiLAogICAg
ICAgICAiLiAuIFMgLiAuIiwKICAgICAgICAgIi4gUyAuIFMgLiIsCiAgICAgICAgICIuIC4gUyAu
IC4iLAogICAgICAgICAiSCAuIC4gLiBIIiwKICAgICAgfQogICB9LAp9CgotLS0gUGFyc2UgYSBn
cmlkIHJvdyBpbnRvIGNlbGxzCi0tIEBwYXJhbSByb3cgU3RyaW5nIGxpa2UgIlMgLiAuIC4gUyIK
LS0gQHJldHVybiBUYWJsZSBvZiBjaGFyYWN0ZXJzCmxvY2FsIGZ1bmN0aW9uIHBhcnNlX3Jvdyhy
b3cpCiAgIGxvY2FsIGNlbGxzID0ge30KICAgZm9yIGNoYXIgaW4gcm93OmdtYXRjaCgiJVMiKSBk
bwogICAgICBhZGQoY2VsbHMsIGNoYXIpCiAgIGVuZAogICByZXR1cm4gY2VsbHMKZW5kCgotLS0g
UGFyc2UgZW50aXJlIGdyaWQgaW50byAyRCBzdHJ1Y3R1cmUKLS0gQHBhcmFtIGdyaWQgQXJyYXkg
b2Ygcm93IHN0cmluZ3MKLS0gQHJldHVybiB7cm93cywgY29scywgY2VsbHN9CmxvY2FsIGZ1bmN0
aW9uIHBhcnNlX2dyaWQoZ3JpZCkKICAgbG9jYWwgcm93cyA9ICNncmlkCiAgIGxvY2FsIGNlbGxz
ID0ge30KICAgbG9jYWwgY29scyA9IDAKCiAgIGZvciByLCByb3dfc3RyIGluIGlwYWlycyhncmlk
KSBkbwogICAgICBjZWxsc1tyXSA9IHBhcnNlX3Jvdyhyb3dfc3RyKQogICAgICBjb2xzID0gbWF4
KGNvbHMsICNjZWxsc1tyXSkKICAgZW5kCgogICByZXR1cm4ge3Jvd3MgPSByb3dzLCBjb2xzID0g
Y29scywgY2VsbHMgPSBjZWxsc30KZW5kCgotLS0gQ2FsY3VsYXRlIHNwYXduIHBvc2l0aW9ucyBm
cm9tIHBhdHRlcm4gZ3JpZAotLSBAcGFyYW0gcGF0dGVybiBQYXR0ZXJuIGRlZmluaXRpb24gd2l0
aCBncmlkCi0tIEBwYXJhbSBib3VuZHMgUm9vbSBpbm5lciBib3VuZHMge3gxLCB5MSwgeDIsIHky
fSBpbiB0aWxlcwotLSBAcmV0dXJuIEFycmF5IG9mIHt4LCB5LCB0eXBlfSBpbiBwaXhlbHMKZnVu
Y3Rpb24gV2F2ZVBhdHRlcm5zLmNhbGN1bGF0ZV9wb3NpdGlvbnMocGF0dGVybiwgYm91bmRzKQog
ICBpZiBub3QgcGF0dGVybiBvciBub3QgcGF0dGVybi5ncmlkIHRoZW4gcmV0dXJuIHt9IGVuZAoK
ICAgbG9jYWwgcGFyc2VkID0gcGFyc2VfZ3JpZChwYXR0ZXJuLmdyaWQpCiAgIGxvY2FsIHBvc2l0
aW9ucyA9IHt9CgogICAtLSBDYWxjdWxhdGUgcm9vbSBkaW1lbnNpb25zIGluIHBpeGVscwogICBs
b2NhbCByb29tX3gxID0gYm91bmRzLngxICogR1JJRF9TSVpFCiAgIGxvY2FsIHJvb21feTEgPSBi
b3VuZHMueTEgKiBHUklEX1NJWkUKICAgbG9jYWwgcm9vbV93ID0gKGJvdW5kcy54MiAtIGJvdW5k
cy54MSArIDEpICogR1JJRF9TSVpFCiAgIGxvY2FsIHJvb21faCA9IChib3VuZHMueTIgLSBib3Vu
ZHMueTEgKyAxKSAqIEdSSURfU0laRQoKICAgLS0gQ2VsbCBzaXplIGluIHJvb20gc3BhY2UKICAg
bG9jYWwgY2VsbF93ID0gcm9vbV93IC8gcGFyc2VkLmNvbHMKICAgbG9jYWwgY2VsbF9oID0gcm9v
bV9oIC8gcGFyc2VkLnJvd3MKCiAgIC0tIEl0ZXJhdGUgZ3JpZCBhbmQgbWFwIHRvIHJvb20gcG9z
aXRpb25zCiAgIGZvciByID0gMSwgcGFyc2VkLnJvd3MgZG8KICAgICAgZm9yIGMgPSAxLCBwYXJz
ZWQuY29scyBkbwogICAgICAgICBsb2NhbCBjaGFyID0gcGFyc2VkLmNlbGxzW3JdIGFuZCBwYXJz
ZWQuY2VsbHNbcl1bY10KICAgICAgICAgbG9jYWwgZW5lbXlfdHlwZSA9IEVORU1ZX0xFR0VORFtj
aGFyXQoKICAgICAgICAgaWYgZW5lbXlfdHlwZSB0aGVuCiAgICAgICAgICAgIC0tIENlbnRlciBv
ZiBjZWxsIGluIHJvb20gY29vcmRpbmF0ZXMKICAgICAgICAgICAgbG9jYWwgeCA9IHJvb21feDEg
KyAoYyAtIDAuNSkgKiBjZWxsX3cgLSA4IC0tIE9mZnNldCBieSBoYWxmIHNwcml0ZSBzaXplCiAg
ICAgICAgICAgIGxvY2FsIHkgPSByb29tX3kxICsgKHIgLSAwLjUpICogY2VsbF9oIC0gOAogICAg
ICAgICAgICBhZGQocG9zaXRpb25zLCB7eCA9IHgsIHkgPSB5LCB0eXBlID0gZW5lbXlfdHlwZX0p
CiAgICAgICAgIGVuZAogICAgICBlbmQKICAgZW5kCgogICByZXR1cm4gcG9zaXRpb25zCmVuZAoK
LS0tIEdldCBhbGwgcGF0dGVybnMgYXQgYSBzcGVjaWZpYyBkaWZmaWN1bHR5Ci0tIEBwYXJhbSBk
aWZmaWN1bHR5IDEtMwotLSBAcmV0dXJuIEFycmF5IG9mIHBhdHRlcm4ga2V5cwpmdW5jdGlvbiBX
YXZlUGF0dGVybnMuZ2V0X3BhdHRlcm5zX2Zvcl9kaWZmaWN1bHR5KGRpZmZpY3VsdHkpCiAgIGxv
Y2FsIHJlc3VsdCA9IHt9CiAgIGZvciBuYW1lLCBwYXR0ZXJuIGluIHBhaXJzKFBhdHRlcm5zKSBk
bwogICAgICBpZiBwYXR0ZXJuLmRpZmZpY3VsdHkgPT0gZGlmZmljdWx0eSB0aGVuCiAgICAgICAg
IGFkZChyZXN1bHQsIG5hbWUpCiAgICAgIGVuZAogICBlbmQKICAgcmV0dXJuIHJlc3VsdAplbmQK
Ci0tLSBHZXQgYSByYW5kb20gcGF0dGVybiBhdCBhIHNwZWNpZmljIGRpZmZpY3VsdHkKLS0gQHBh
cmFtIGRpZmZpY3VsdHkgMS0zCi0tIEByZXR1cm4gUGF0dGVybiBkZWZpbml0aW9uIG9yIG5pbApm
dW5jdGlvbiBXYXZlUGF0dGVybnMuZ2V0X3JhbmRvbV9wYXR0ZXJuKGRpZmZpY3VsdHkpCiAgIGxv
Y2FsIGNhbmRpZGF0ZXMgPSBXYXZlUGF0dGVybnMuZ2V0X3BhdHRlcm5zX2Zvcl9kaWZmaWN1bHR5
KGRpZmZpY3VsdHkpCiAgIGlmICNjYW5kaWRhdGVzID09IDAgdGhlbgogICAgICAtLSBGYWxsYmFj
ayB0byBsb3dlciBkaWZmaWN1bHR5CiAgICAgIGlmIGRpZmZpY3VsdHkgPiAxIHRoZW4KICAgICAg
ICAgcmV0dXJuIFdhdmVQYXR0ZXJucy5nZXRfcmFuZG9tX3BhdHRlcm4oZGlmZmljdWx0eSAtIDEp
CiAgICAgIGVuZAogICAgICByZXR1cm4gbmlsCiAgIGVuZAoKICAgbG9jYWwgbmFtZSA9IGNhbmRp
ZGF0ZXNbZmxyKHJuZCgjY2FuZGlkYXRlcykpICsgMV0KICAgbG9jYWwgcGF0dGVybiA9IFBhdHRl
cm5zW25hbWVdCiAgIHBhdHRlcm4ubmFtZSA9IG5hbWUgLS0gQXR0YWNoIG5hbWUgZm9yIGxvZ2dp
bmcKICAgcmV0dXJuIHBhdHRlcm4KZW5kCgotLS0gR2V0IGEgc3BlY2lmaWMgcGF0dGVybiBieSBu
YW1lCi0tIEBwYXJhbSBuYW1lIFBhdHRlcm4gbmFtZQotLSBAcmV0dXJuIFBhdHRlcm4gZGVmaW5p
dGlvbiBvciBuaWwKZnVuY3Rpb24gV2F2ZVBhdHRlcm5zLmdldF9wYXR0ZXJuKG5hbWUpCiAgIHJl
dHVybiBQYXR0ZXJuc1tuYW1lXQplbmQKCnJldHVybiBXYXZlUGF0dGVybnM=
:: [eoc]
